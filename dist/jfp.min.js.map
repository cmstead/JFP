{"version":3,"file":"jfp.min.js","sources":["jfp.js"],"names":["jfp","resolveFunction","functionValue","curryAlias","args","slice","arguments","apply","curry","pickAlias","key","value","cleanKey","Boolean","pick","partial","chooseResolver","resolveToPick","charAt","resolver","j","isUndefined","undefined","not","equal","a","b","missingValues","isType","typeString","getType","isArray","isNumeric","pattern","number","numericString","match","isTruthy","typeCheckReduction","result","isPrimitive","primitiveNames","reduce","bind","isBoolean","isEmptyString","isFunction","isNull","isNumber","isObject","isString","identity","valueType","Object","prototype","toString","call","begin","valueSet","end","values","Array","shortCircuit","defaultValue","userFn","testValue","maybe","type","typeOkay","either","when","checkValue","eitherIf","predicateValue","safePredicate","eitherWhen","sanitizedFn","concat","original","extension","sanitizedExtension","i","length","push","basePartial","direction","appliedFunction","applicationArgs","splitPartial","baseFn","left","right","leftApplied","reverseArgs","reverse","countArguments","execute","rpartial","toDec","parseInt","copyArray","makeValueArray","conj","dest","cons","source","first","lastIndex","last","drop","index","finalIndex","sanitizedIndex","firstArray","secondArray","dropLast","nth","rest","take","count","naturalComparator","comparison","sort","optionValue","comparator","finalSet","each","userArray","sanitizedArray","dropFirst","init","valueMap","pickResult","merge","defaultObj","mergeData","finalObj","argumentCount","appliedFn","recursor","recurFn","recursorFn","localRecursor","verifyRecurValue","recurValue","recur","recursingFn","reducer","reduction","collection","appliedReducer","initialState","hasInitialState","initialValue","remainder","compositor","f","g","$f","$g","compositeFn","compose","pipeline","partialReverse","clone","originalValue","depth","depthOkay","geq","copyOkay","copy","keys","container","newDepth","err","RangeError","maybeType","eitherType","mapper","finalArray","map","mapperFn","filterer","userPredicate","filter","predicate","filterFn","compact","valueList","predicateAccumulator","total","sanitizedTotal","numberOf","accumulator","captureUnique","finalList","unique","union","set1","set2","addToHash","finalObject","buildValueHash","captureIntersection","valueHash","intersect","setHash","captureDifference","difference","symmetricDifference","setUnion","setIntersection","everyReducer","every","finder","done","find","someRecur","some","contains","partitioner","partitions","partition","list","sanitizedPredicate","multiPartitioner","partitionPredicate","computedPartitions","multiPartition","predicateArgs","sanitizedArgs","sanitizedList","firstExists","ander","orer","reduceConditions","conditionArgs","operator","initialCondition","and","or","xor","equivalent","keyReduction","baseObj","toValues","dereferencer","dataObject","token","trim","internalDeref","baseData","sanitizedDefault","keyTokens","split","deref","sanitizedKey","sanitizedData","plucker","pluckKeys","sanitizedObject","pluck","adder","current","add","divider","divide","multiplier","multiply","subtractor","subtract","rangeRecurCheck","m","n","inc","rangeBuilder","currentRange","finalRange","range","start","increment","mod","modulo","_a","_b","Math","floor","abs","truncate","max","maxValue","Number","MAX_VALUE","min","minValue","fac","factorial","greater","throwWhenNotComparable","TypeError","less","isInt","isNegative","isPositive","isZero","isEven","isNonNegative","isNonPositive","isNonZero","isOdd","leq","module","exports"],"mappings":"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","sourcesContent":["var jfp = (function(){\r\n    'use strict';\r\n    \r\n    function resolveFunction(functionValue){\r\n        return typeof functionValue === 'string' ? jfp[functionValue] : functionValue;\r\n    }\r\n    \r\n    function curryAlias(){\r\n        var args = jfp.slice(0, arguments);\r\n\r\n        args[0] = resolveFunction(args[0]);\r\n        \r\n        return jfp.apply(jfp.curry, args);\r\n    }\r\n    \r\n    function pickAlias(key, value){\r\n        var cleanKey = key.slice(1);\r\n        \r\n        return Boolean(value) ? jfp.pick(cleanKey, value) : jfp.partial(jfp.pick, cleanKey);\r\n    }\r\n    \r\n    function chooseResolver(value){\r\n        var resolveToPick = typeof value === 'string' && value.charAt(0) === ':';\r\n        \r\n        return resolveToPick ? pickAlias : curryAlias;\r\n    }\r\n    \r\n    return function(){\r\n        var args = jfp.slice(0, arguments),\r\n            resolver = chooseResolver(args[0]);\r\n        \r\n        return jfp.apply(resolver, args);\r\n    };\r\n    \r\n})();\r\n\r\n(function(j){\r\n    'use strict';\r\n\r\n    function isUndefined(value){\r\n        return value === undefined;\r\n    }\r\n    \r\n    function not(value){\r\n        return !Boolean(value);\r\n    }\r\n    \r\n    function equal (a, b) {\r\n        var missingValues = isUndefined(a) || isUndefined(b);\r\n        return not(missingValues) && a === b;\r\n    }\r\n\r\n    function isType (typeString, value) {\r\n        return j.equal(j.getType(value), typeString);\r\n    }\r\n    \r\n    function isArray(value){\r\n        return isType('array', value);\r\n    }\r\n    \r\n    function isNumeric(value){\r\n        var pattern = /^(0x)?[0-9]+((\\.[0-9]+)|(e\\-?[0-9]+))?$/,\r\n            number = isType('number', value),\r\n            numericString = isType('string', value) && Boolean(value.match(pattern));\r\n            \r\n        return number || numericString;\r\n    }\r\n    \r\n    function isTruthy(value){\r\n        return Boolean(value);\r\n    }\r\n    \r\n    function typeCheckReduction (value, result, typeString){\r\n        return result || isType(typeString, value);\r\n    }\r\n    \r\n    function isPrimitive (value) {\r\n        var primitiveNames = ['number',\r\n                              'string',\r\n                              'boolean',\r\n                              'undefined'];\r\n\r\n        return primitiveNames.reduce(typeCheckReduction.bind(null, value), equal(null, value));\r\n    }\r\n\r\n    j.equal = equal;\r\n    j.isArray = isArray;\r\n    j.isBoolean = isType.bind(null, 'boolean');\r\n    j.isEmptyString = equal.bind(null, '');\r\n    j.isFunction = isType.bind(null, 'function');\r\n    j.isNull = equal.bind(null, null);\r\n    j.isNumber = isType.bind(null, 'number');\r\n    j.isNumeric = isNumeric;\r\n    j.isObject = isType.bind(null, 'object');\r\n    j.isPrimitive = isPrimitive;\r\n    j.isString = isType.bind(null, 'string');\r\n    j.isType = isType;\r\n    j.isTruthy = isTruthy;\r\n    j.isUndefined = isType.bind(null, 'undefined');\r\n    j.not = not;\r\n\r\n})(jfp);\r\n\r\n\r\n(function(j){\r\n    'use strict';\r\n\r\n    function identity(value){\r\n        return value;\r\n    }\r\n\r\n    function getType (value) {\r\n        var valueType = typeof value,\r\n            isArray = valueType === 'object' && Object.prototype.toString.call(value) === '[object Array]';\r\n            \r\n        return isArray ? 'array' : valueType;\r\n    }\r\n\r\n    function slice(begin, valueSet, end){\r\n        var values = j.not(j.isTruthy(valueSet)) ? [] : valueSet;\r\n\r\n        return j.not(j.isTruthy(end)) ?\r\n                    Array.prototype.slice.call(values, begin) :\r\n                    Array.prototype.slice.call(values, begin, end);\r\n    }\r\n\r\n    function shortCircuit(defaultValue, userFn, testValue){\r\n        return (j.isTruthy(testValue) || testValue === 0) ?\r\n            userFn(testValue) :\r\n            defaultValue;\r\n    }\r\n\r\n    function maybe(value){\r\n        var type = arguments[1],\r\n            valueType = getType(value),\r\n            typeOkay = valueType === type || valueType === 'array' && type === 'object';\r\n        \r\n        return typeOkay || (!type && Boolean(value)) ? value : null;\r\n    }\r\n\r\n    function either(defaultValue, testValue){\r\n        var type = arguments[2];\r\n        return maybe(testValue, type) === null ? defaultValue : testValue;\r\n    }\r\n    \r\n    function apply(userFn, args){\r\n        return userFn.apply(null, args);\r\n    }\r\n\r\n    function when(checkValue, userFn){\r\n        var args = slice(2, arguments);\r\n        return j.isTruthy(checkValue) ? apply(userFn, args) : null;\r\n    }\r\n\r\n    function eitherIf(defaultValue, testValue, predicateValue){\r\n        var safePredicate = j.isUndefined(predicateValue) ? true : predicateValue;\r\n\r\n        return j.either(defaultValue, j.when(safePredicate, j.partial(j.identity, testValue)));\r\n    }\r\n\r\n    function eitherWhen(defaultValue, predicateValue, userFn){\r\n        var sanitizedFn = eitherIf(j.identity, userFn, j.isFunction(userFn));\r\n\r\n        return j.either(defaultValue, j.when(predicateValue, sanitizedFn));\r\n    }\r\n\r\n    function concat(original, extension){\r\n        var result = slice(0, either([], original)),\r\n            sanitizedExtension = either([], extension),\r\n            i;\r\n\r\n        //This is the most performant way to handle concatenation. Trust me.\r\n        for(i = 0; i < sanitizedExtension.length; i++){\r\n            result.push(sanitizedExtension[i]);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    function basePartial(direction, userFn){\r\n        var args = slice(2, arguments);\r\n\r\n        return function appliedFunction(){\r\n            var applicationArgs = (direction === 'left') ?\r\n                                    concat(args, slice(0, arguments)) :\r\n                                    concat(slice(0, arguments), args);\r\n\r\n            return apply(userFn, applicationArgs);\r\n        };\r\n    }\r\n\r\n    function splitPartial (baseFn, left, right) {\r\n        var leftApplied = apply(basePartial, concat(['left', baseFn], left));\r\n        return apply(basePartial, concat(['right', leftApplied], right));\r\n    }\r\n\r\n    function reverseArgs(userFn){\r\n        return function(){\r\n            var args = j.slice(0, arguments).reverse();\r\n            return j.apply(userFn, args);\r\n        };\r\n    }\r\n\r\n    function countArguments(userFn){\r\n        return either(function(){}, userFn).length;\r\n    }\r\n\r\n    function execute(userFn){\r\n        return j.apply(userFn, j.slice(1, arguments));\r\n    }\r\n    \r\n    j.apply = apply;\r\n    j.concat = concat;\r\n    j.countArguments = countArguments;\r\n    j.either = either;\r\n    j.eitherIf = eitherIf;\r\n    j.eitherWhen = eitherWhen;\r\n    j.execute = execute;\r\n    j.getType = getType;\r\n    j.identity = identity;\r\n    j.maybe = maybe;\r\n    j.partial = basePartial('left', basePartial, 'left');\r\n    j.reverseArgs = reverseArgs;\r\n    j.rpartial = basePartial('left', basePartial, 'right');\r\n    j.shortCircuit = shortCircuit;\r\n    j.slice = slice;\r\n    j.splitPartial = splitPartial;\r\n    j.when = when;\r\n\r\n})(jfp);\r\n\r\n\r\n(function(j){\r\n    'use strict';\r\n\r\n    function toDec(value){\r\n        return (j.isNumeric(value)) ? parseInt(value, 10) : null;\r\n    }\r\n\r\n    j.toDec = toDec;\r\n\r\n})(jfp);\r\n\r\n(function(j){\r\n    'use strict';\r\n\r\n    function copyArray(valueSet){\r\n        return j.slice(0, valueSet);\r\n    }\r\n\r\n    function makeValueArray(value){\r\n        return j.not(j.isUndefined(value)) ? [value] : [];\r\n    }\r\n\r\n    function conj(value, dest){\r\n        return j.concat(copyArray(dest), makeValueArray(value));\r\n    }\r\n\r\n    function cons(value, source){\r\n        return j.concat(makeValueArray(value), source);\r\n    }\r\n\r\n    function first(values){\r\n        return j.isArray(values) ? j.either(null, values[0]) : null;\r\n    }\r\n\r\n    function lastIndex(values){\r\n        return j.isArray(values) ? values.length - 1 : null;\r\n    }\r\n\r\n    function last(values){\r\n        return j.isArray(values) ? values[lastIndex(values)] : null;\r\n    }\r\n\r\n    function drop(index, valueSet){\r\n        var finalIndex = lastIndex(valueSet),\r\n\r\n            sanitizedIndex = (index === 0 || index === finalIndex) ?\r\n                index : j.either(1, index) - 1,\r\n\r\n            firstArray = (sanitizedIndex === 0) ?\r\n                [] : j.slice(0, valueSet, sanitizedIndex),\r\n\r\n            secondArray = (sanitizedIndex === finalIndex)?\r\n                [] : j.slice(sanitizedIndex + 1, valueSet);\r\n\r\n        return j.concat(firstArray, secondArray);\r\n    }\r\n\r\n    function dropLast(valueSet){\r\n        return drop(lastIndex(valueSet), valueSet);\r\n    }\r\n\r\n    function nth(index, valueSet){\r\n        return j.either(null, j.either([], valueSet)[index]);\r\n    }\r\n\r\n    function rest(values){\r\n        return j.slice(1, values);\r\n    }\r\n\r\n    function take(count, values){\r\n        return j.isArray(values) ? j.slice(0, values, count) : null;\r\n    }\r\n\r\n    function naturalComparator(a, b){\r\n        var comparison = a < b ? -1 : 1;\r\n        return a === b ? 0 : comparison;\r\n    }\r\n\r\n    function sort(optionValue, valueSet){\r\n        var comparator = j.isFunction(optionValue) ? optionValue : naturalComparator,\r\n            finalSet = j.isArray(optionValue) ? j.slice(0, optionValue) : j.slice(0, valueSet);\r\n\r\n        return finalSet.sort(comparator);\r\n    }\r\n\r\n    function each(userFn, userArray){\r\n        var sanitizedArray = j.either([], userArray),\r\n            sanitizedFn = j.either(j.identity, userFn),\r\n            i;\r\n\r\n        for(i = 0; i < sanitizedArray.length; i++){\r\n            if(sanitizedFn(sanitizedArray[i], i) === false){\r\n                break;\r\n            }\r\n        }\r\n\r\n        return sanitizedArray;\r\n    }\r\n\r\n    j.conj = conj;\r\n    j.cons = cons;\r\n    j.copyArray = copyArray;\r\n    j.drop = drop;\r\n    j.dropFirst = j.partial(drop, 0);\r\n    j.dropLast = dropLast;\r\n    j.each = each;\r\n    j.first = first;\r\n    j.init = j.dropLast;\r\n    j.last = last;\r\n    j.lastIndex = lastIndex;\r\n    j.nth = nth;\r\n    j.rest = rest;\r\n    j.sort = sort;\r\n    j.take = take;\r\n\r\n})(jfp);\r\n\r\n\r\n(function(j){\r\n    'use strict';\r\n\r\n    function pick(key, valueMap){\r\n        var pickResult = j.either({}, valueMap)[key];\r\n        return j.isUndefined(pickResult) ? null : pickResult;\r\n    }\r\n\r\n    function merge(defaultObj, mergeData){\r\n        var finalObj = {},\r\n            key;\r\n\r\n        for(key in j.either({}, defaultObj)){\r\n            finalObj[key] = defaultObj[key];\r\n        }\r\n\r\n        for(key in j.either({}, mergeData)){\r\n            finalObj[key] = mergeData[key];\r\n        }\r\n\r\n        return j.eitherIf(null, finalObj, j.isTruthy(defaultObj));\r\n    }\r\n\r\n    j.merge = merge;\r\n    j.pick = pick;\r\n\r\n})(jfp);\r\n\r\n\r\n(function(j){\r\n    'use strict';\r\n\r\n    //This is complicated and I don't expect people to grok it on first read.\r\n    function curry(userFn){\r\n        var args = j.slice(1, arguments),\r\n            argumentCount = j.countArguments(userFn),\r\n            appliedFn = (args.length < argumentCount) ? j.apply(j.partial, j.concat([curry, userFn], args)) : null,\r\n            result = (Boolean(userFn) && args.length >= argumentCount) ? j.apply(userFn, args) : null;\r\n\r\n        return j.either(appliedFn, result);\r\n    }\r\n\r\n    //zOMG! TAIL OPTIMIZED RECURSION\r\n    function recursor(recurFn){\r\n        var args = j.slice(1, arguments);\r\n\r\n        //This is to make the returned function distinct and identifiable.\r\n        return function recursorFn(localRecursor){\r\n            return j.apply(recurFn, j.concat([localRecursor], args));\r\n        };\r\n    }\r\n\r\n    function verifyRecurValue(recurValue){\r\n        return typeof recurValue === 'function' &&\r\n            recurValue.toString().match('recursorFn');\r\n    }\r\n\r\n    //Tail optimization with managed recursion is really complicated.\r\n    //Please don't muck with this unless you TRULY understand what is happening.\r\n    function recur(userFn){\r\n        var recursingFn = j.either(j.identity, userFn, 'function'),\r\n            localRecursor = j.partial(recursor, recursingFn),\r\n            recurValue = j.apply(localRecursor, j.slice(1, arguments));\r\n\r\n        while(verifyRecurValue(recurValue = recurValue(localRecursor)) && recursingFn !== j.identity);\r\n\r\n        return recurValue;\r\n    }\r\n\r\n\t/*\r\n     * Reduce uses tail-optimized (while-trampolined, fully returning) recursion to resolve reductions.\r\n     * Reducer is a pure function for handling a single reduction step.\r\n     * Reduce manages the setup and recursion execution.\r\n     */\r\n    function reducer(userFn, recur, reduction, collection){\r\n        return collection.length === 0 ?\r\n                    reduction :\r\n                    recur(userFn(reduction, j.first(collection)),\r\n                          j.rest(collection));\r\n    }\r\n\r\n    function reduce(userFn, values){\r\n        var appliedReducer = j.partial(reducer, userFn),\r\n            initialState = arguments[2],\r\n            hasInitialState = typeof initialState !== 'undefined',\r\n            \r\n            initialValue = !hasInitialState ? j.first(values) : initialState,\r\n            remainder = !hasInitialState ? j.rest(values) : values;\r\n\r\n        return (Boolean(values) && values.length > 0) ? j.recur(appliedReducer, initialValue, remainder) : initialValue;\r\n    }\r\n\r\n    //Produces a function that returns f(g(x))\r\n    function compositor(f, g){\r\n        var $f = typeof f !== 'function' ? j.identity : f,\r\n            $g = typeof g !== 'function' ? j.identity : g;\r\n            \r\n        function compositeFn () {\r\n            return $f(j.apply($g, j.slice(0, arguments)));\r\n        }\r\n        \r\n        return compositeFn;\r\n    }\r\n\r\n    function compose(){\r\n        return reduce(compositor, j.slice(0, arguments), j.identity);\r\n    }\r\n\r\n    function pipeline(value){\r\n        return j.apply(compose, j.slice(1, arguments).reverse())(value);\r\n    }\r\n\r\n    function partialReverse(){\r\n        return j.apply(j.compose(j.reverseArgs, j.partial),\r\n                       j.slice(0, arguments));\r\n    }\r\n\r\n    function clone (originalValue, depth) {\r\n        var depthOkay = j.isUndefined(depth) || j.geq(depth, 0),\r\n            copyOkay = j.isType('object', originalValue) || j.isType('array', originalValue);\r\n        \r\n        function copy () {\r\n            var keys = Object.keys(originalValue),\r\n                container = j.isArray(originalValue) ? [] : {};\r\n            \r\n            j.each(function (key) {\r\n                var newDepth = j.isNumber(depth) ? depth - 1 : undefined;\r\n                \r\n                try {\r\n                    container[key] = clone(originalValue[key], newDepth);\r\n                } catch (err) {\r\n                    throw new RangeError('Object contains circular reference or is too deep to clone.');\r\n                }\r\n                \r\n            }, keys);\r\n            \r\n            return container;\r\n        }\r\n        \r\n        return copyOkay && depthOkay ? copy() : originalValue;\r\n    }\r\n\r\n    function maybeType (typeString) {\r\n        return j.curry(function (value) {\r\n            return j.maybe(value, typeString);\r\n        }).apply(j, j.slice(1, arguments));\r\n    }\r\n    \r\n    function eitherType (typeString) {\r\n        return j.curry(function (defaultValue, optionValue) {\r\n            return j.either(defaultValue, optionValue, typeString);\r\n        }).apply(j, j.slice(1, arguments));\r\n    }\r\n    \r\n    j.clone = clone;\r\n    j.compose = compose;\r\n    j.curry = curry;\r\n    j.eitherType = eitherType;\r\n    j.maybeType = maybeType;\r\n    j.partialReverse = partialReverse;\r\n    j.pipeline = pipeline;\r\n    j.recur = recur;\r\n    j.reduce = reduce;\r\n\r\n})(jfp);\r\n\r\n\r\n(function(j){\r\n\t\r\n    /*\r\n     * Map uses reduce to produce a new, completely reference-decoupled list of values\r\n     * Mapper handles a single update step for the final output array\r\n     */\r\n    function mapper(userFn, finalArray, value){\r\n        finalArray.push(userFn(value));\r\n        return finalArray;\r\n    }\r\n\r\n    function map (userFn, values) {\r\n        var mapperFn = j.partial(mapper, userFn);\r\n        return j.reduce(mapperFn, values, []);\r\n    }\r\n    \r\n    /*\r\n     * Filter uses reduce to produce a new, completely reference-decoupled list of values\r\n     * Filterer handles a single update step for the final output array\r\n     */\r\n    function filterer(userPredicate, finalArray, value){\r\n        return userPredicate(value) ? j.conj(value, finalArray) : finalArray;\r\n    }\r\n\r\n    function filter (predicate, values) {\r\n        var filterFn = j.partial(filterer, predicate);\r\n        return j.reduce(filterFn, values, []);\r\n    }\r\n    \r\n    function compact(valueList){\r\n        return filter(j.isTruthy, valueList);\r\n    }\r\n\r\n    function predicateAccumulator(predicate, total, value){\r\n        var sanitizedTotal = j.either(0, total, 'number');\r\n        return predicate(value) ? sanitizedTotal + 1 : sanitizedTotal;\r\n    }\r\n\r\n    function numberOf(predicate, valueSet){\r\n        var accumulator = j.partial(predicateAccumulator, predicate);\r\n        return j.reduce(accumulator, j.either([], valueSet), 0);\r\n    }\r\n\r\n    function captureUnique(finalList, value){\r\n        return j.last(finalList) === value ? finalList : j.conj(value, finalList);\r\n    }\r\n    \r\n    function unique(valueSet){\r\n        return j.reduce(captureUnique, j.sort(j.slice(0, valueSet)), []);\r\n    }\r\n\r\n    function union(set1, set2){\r\n        return j.compose(j.unique, j.concat)(set1, set2);\r\n    }\r\n\r\n    function addToHash(finalObject, value){\r\n        finalObject[value] = true;\r\n        return finalObject;\r\n    }\r\n\r\n    function buildValueHash(valueList){\r\n        return j.either({}, j.reduce(addToHash, valueList, {}));\r\n    }\r\n\r\n    function captureIntersection(valueHash, finalList, value){\r\n        return valueHash[value] ? j.conj(value, finalList) : finalList;\r\n    }\r\n    \r\n    function intersect(set1, set2){\r\n        var setHash = buildValueHash(j.either([], set2));\r\n        return j.reduce(j.partial(captureIntersection, setHash), set1, []); \r\n    }\r\n\r\n    function captureDifference(valueHash, finalList, value){\r\n        return !valueHash[value] ? j.conj(value, finalList) : finalList;\r\n    }\r\n    \r\n    function difference(set1, set2){\r\n        var setHash = buildValueHash(j.either([], set2));\r\n        return j.reduce(j.partial(captureDifference, setHash), set1, []);\r\n    }\r\n\r\n    function symmetricDifference(set1, set2){\r\n        var setUnion = union(set1, set2),\r\n            setIntersection = intersect(set1, set2);\r\n\r\n        return difference(setUnion, setIntersection);\r\n    }\r\n\r\n    function everyReducer (predicate, result, valueList){\r\n        return result && predicate(valueList);\r\n    }\r\n\r\n    function every (predicate, valueList){\r\n        var reducer = j.partial(everyReducer, predicate);\r\n        return Boolean(j.reduce(reducer, valueList, true));\r\n    }\r\n\r\n    function finder (recur, predicate, valueList) {\r\n        var done = !Boolean(valueList) || valueList.length === 0,\r\n            result = done ? null : j.first(valueList);\r\n        \r\n        return done || predicate(result) ? result : recur(predicate, j.rest(valueList));\r\n    }\r\n\r\n    function find (predicate, valueList){\r\n        return j.recur(finder, predicate, valueList);\r\n    }\r\n\r\n    function someRecur(recur, predicate, valueList){\r\n        var done = valueList.length === 0,\r\n            result = done ? false : predicate(j.first(valueList));\r\n            \r\n        return result || done ? result : recur(predicate, j.rest(valueList));\r\n    }\r\n\r\n    function some(predicate, valueList){\r\n        return Boolean(j.recur(someRecur, predicate, valueList));\r\n    }\r\n    \r\n    function contains(value, valueList){\r\n        return some(j.partial(j.equal, value), valueList);\r\n    }\r\n\r\n    function partitioner(predicate, partitions, value){\r\n        var index = predicate(value) ? 0 : 1;\r\n\r\n        partitions[index].push(value);\r\n\r\n        return partitions;\r\n    }\r\n\r\n    function partition(predicate, list){\r\n        var sanitizedPredicate = j.either(j.identity, predicate, 'function');\r\n        \r\n        return j.reduce(j.partial(partitioner, sanitizedPredicate),\r\n                        j.either([], list),\r\n                        [[], []]);\r\n    }\r\n\r\n    function multiPartitioner(predicate, partitions, value){\r\n        var partitionPredicate = j.rpartial(predicate, value),\r\n            computedPartitions = j.dropLast(partitions);\r\n        \r\n        return j.concat(computedPartitions, partition(partitionPredicate, j.last(partitions)));\r\n    }\r\n    \r\n    function multiPartition(predicate, predicateArgs, list){\r\n        var sanitizedArgs = j.either([], predicateArgs),\r\n            sanitizedPredicate = j.either(j.identity, predicate),\r\n            sanitizedList = j.either([], list);\r\n            \r\n        return !Boolean(list) ?\r\n                [[], []] :\r\n                j.reduce(j.partial(multiPartitioner, sanitizedPredicate),\r\n                         sanitizedArgs,\r\n                         [sanitizedList]);\r\n    }\r\n\r\n    function firstExists (list) {\r\n        return j.not(j.isNull(j.first(list)));\r\n    }\r\n\r\n    j.contains = contains;\r\n    j.compact = compact;\r\n    j.difference = difference;\r\n    j.every = every;\r\n\tj.filter = filter;\r\n    j.find = find;\r\n    j.firstExists = firstExists;\r\n    j.intersect = intersect;\r\n\tj.map = map;\r\n\tj.multiPartition = multiPartition;\r\n\tj.numberOf = numberOf;\r\n    j.partition = partition;\r\n    j.some = some;\r\n    j.symmetricDifference = symmetricDifference;\r\n    j.union = union;\r\n    j.unique = unique;\r\n\r\n})(jfp);\r\n\r\n(function (j) {\r\n\t'use strict';\r\n\t\r\n\t//Performs 'and' operation on valueSet\r\n    function ander(a, b){\r\n        return a && b;\r\n    }\r\n\r\n    function orer(a, b){\r\n        return a || b;\r\n    }\r\n\r\n    function reduceConditions(conditionArgs, operator, initialCondition){\r\n        var args = j.map(Boolean, j.slice(0, conditionArgs));\r\n        return Boolean(j.reduce(operator, args, initialCondition));\r\n    }\r\n\r\n    function and(a, b){\r\n        return reduceConditions(arguments, ander, true);\r\n    }\r\n\r\n    function or(a, b){\r\n        return reduceConditions(arguments, orer, false);\r\n    }\r\n\r\n    function xor(a, b){\r\n        var equivalent = Boolean(a) === Boolean(b);\r\n        return or(a, b) && j.not(equivalent);\r\n    }\r\n\r\n\tj.and = and;\r\n\tj.or = or;\r\n\tj.xor = xor;\r\n\r\n})(jfp);\r\n\r\n(function (j) {\r\n\t'use strict';\r\n\t\r\n    /*\r\n     * toValues converts an object to an array of values\r\n     * This is necessary for reduce to convert objects into\r\n     * processible arrays in an upcoming version.\r\n     */\r\n\tfunction keyReduction (baseObj, finalList, key) {\r\n\t\treturn j.conj(baseObj[key], finalList);\r\n\t}\r\n\t\r\n\tfunction toValues (baseObj) {\r\n\t\tvar reducer = j.partial(keyReduction, baseObj);\r\n\t\treturn j.isNull(j.maybe(baseObj, 'object')) ? null : j.reduce(reducer, Object.keys(baseObj), []);\r\n\t}\r\n\r\n\tfunction dereferencer(dataObject, token){\r\n        var key = j.either('', token).trim();\r\n        return key === '' ? dataObject : j.pick(token, dataObject);\r\n    }\r\n\r\n    function internalDeref(key, baseData, defaultValue){\r\n        var sanitizedDefault = defaultValue === undefined ? null : defaultValue,\r\n            keyTokens = key.split('.'),\r\n            result = j.reduce(dereferencer, keyTokens, baseData);\r\n        \r\n        return j.either(sanitizedDefault, result);\r\n    }\r\n    \r\n    function deref(key, baseData, defaultValue){\r\n        // Satisifes backwards-compatibility case where key an data are reversed\r\n        var sanitizedKey = typeof key === 'string' ? key : baseData,\r\n            sanitizedData = typeof baseData === 'object' ? baseData : key;\r\n        \r\n        // Fully sanitize data before executing the dereference function\r\n        sanitizedKey = j.either('', sanitizedKey, 'string');\r\n        sanitizedData = j.either(null, sanitizedData, 'object');\r\n        \r\n        return internalDeref(j.either('', sanitizedKey), sanitizedData, defaultValue);\r\n    }\r\n    \r\n    function plucker (baseObj, finalObj, key){\r\n        finalObj[key] = baseObj[key];\r\n        return finalObj;\r\n    }\r\n    \r\n    function pluckKeys (keys, baseObj){\r\n        var sanitizedObject = j.either({}, baseObj, 'object');\r\n        return j.reduce(j.partial(plucker, sanitizedObject), keys, {});\r\n    }\r\n    \r\n    function pluck (key, baseObj) {\r\n        return pluckKeys([key], baseObj);\r\n    }\r\n\r\n\tj.deref = deref;\r\n    j.pluck = pluck;\r\n    j.pluckKeys = pluckKeys;\r\n    j.toValues = toValues;\r\n\r\n})(jfp);\r\n\r\n(function(j){\r\n    'use strict';\r\n\r\n//This is a recursive add fn\r\n    function adder(recur, current, valueSet){\r\n        return (valueSet.length === 0) ?\r\n                current :\r\n                recur(current + j.first(valueSet), j.rest(valueSet));\r\n    }\r\n    \r\n    function add(a, b){\r\n        return j.recur(adder, 0, j.slice(0, arguments));\r\n    }\r\n    \r\n    //This is a recursive divide fn\r\n    function divider(recur, current, valueSet){\r\n        return (valueSet.length === 0) ?\r\n                current :\r\n                recur(current / j.first(valueSet), j.rest(valueSet));\r\n    }\r\n    \r\n    function divide(){\r\n        var args = j.slice(0, arguments),\r\n            first = args.length ? j.first(args) : 1;\r\n        return j.recur(divider, first, j.rest(args));\r\n    }\r\n    \r\n    //This is a recursive multiply fn\r\n    function multiplier(recur, current, valueSet){\r\n        return (valueSet.length === 0) ?\r\n                current :\r\n                recur(current * j.first(valueSet), j.rest(valueSet));\r\n    }\r\n    \r\n    function multiply(){\r\n        return j.recur(multiplier, 1, j.slice(0, arguments));\r\n    }\r\n    \r\n    //This is a recursive subtraction fn\r\n    function subtractor(recur, current, valueSet){\r\n        return (valueSet.length === 0) ?\r\n                current :\r\n                recur(current - j.first(valueSet), j.rest(valueSet));\r\n    }\r\n    \r\n    function subtract(){\r\n        var args = j.slice(0, arguments),\r\n            first = args.length ? j.first(args) : 0;\r\n        return j.recur(subtractor, first, j.rest(args));\r\n    }\r\n\r\n    //This is a recursive constructor function for ranges\r\n    function rangeRecurCheck(m, n, inc){\r\n        return inc > 0 ? (m + inc) < n : (m + inc) > n;\r\n    }\r\n\r\n    function rangeBuilder(recur, currentRange, m, n, inc){\r\n        var finalRange = rangeRecurCheck(m - inc, n, inc) ?\r\n                            j.conj(m, currentRange) :\r\n                            currentRange;\r\n        \r\n        return rangeRecurCheck(m, n, inc) ?\r\n                recur(finalRange, m + inc, n, inc) :\r\n                finalRange;\r\n    }\r\n    \r\n    function range(a, b, inc){\r\n        var start = j.isUndefined(b) ? 0 : a,\r\n            end = j.isUndefined(b) ? j.either(0, a) : b,\r\n            increment = (!inc) ? 1 : inc;\r\n            \r\n        return j.recur(rangeBuilder,\r\n                       [],\r\n                       j.either(0, start),\r\n                       j.either(0, end),\r\n                       increment);\r\n    }\r\n\r\n    function mod(a, b){\r\n        return j.isUndefined(b) ? j.either(0, a) : a%b;\r\n    }\r\n\r\n    function modulo(a, b){\r\n        var _a = j.either(0, a),\r\n            _b = j.either(0, b);\r\n\r\n        return (_a > 0) ? mod(_a, _b) : _b * (Math.floor(Math.abs(_a)/_b) + 1) + _a;\r\n    }\r\n\r\n    function truncate(value){\r\n        return (value > 0) ? Math.floor(value) : Math.floor(value) + 1;\r\n    }\r\n    \r\n    function max(a, b){\r\n        var maxValue = -Number.MAX_VALUE,\r\n            _a = j.isUndefined(a) ? maxValue : a,\r\n            _b = j.isUndefined(b) ? maxValue : b;\r\n            \r\n        maxValue = (_a > maxValue) ? _a : maxValue;\r\n        maxValue = (_b > maxValue) ? _b : maxValue;\r\n        \r\n        return maxValue;\r\n    }\r\n    \r\n    function min(a, b){\r\n        var minValue = Number.MAX_VALUE,\r\n            _a = j.isUndefined(a) ? minValue : a,\r\n            _b = j.isUndefined(b) ? minValue : b;\r\n        \r\n        minValue = (_a < minValue) ? _a : minValue;\r\n        minValue = (_b < minValue) ? _b : minValue;\r\n        \r\n        return minValue;\r\n    }\r\n\r\n    function fac(value){\r\n        var factorial = j.compose(j.partial(j.reduce, multiply),\r\n                                  j.partial(range, 1),\r\n                                  j.partial(add, 1));\r\n\r\n        return j.either(1, j.when(j.greater(value, 0), factorial, value));\r\n    }\r\n\r\n    j.add = add;\r\n    j.divide = divide;\r\n    j.fac = fac;\r\n    j.inc = j.partial(j.add, 1);\r\n    j.max = max;\r\n    j.min = min;\r\n    j.mod = mod;\r\n    j.modulo = modulo;\r\n    j.multiply = multiply;\r\n    j.range = range;\r\n    j.subtract = subtract;\r\n    j.truncate = truncate;\r\n\r\n})(jfp);\r\n\r\n\r\n(function(j){\r\n\r\n    function throwWhenNotComparable(a, b){\r\n        j.when(j.isUndefined(a) || j.isUndefined(b), function(){\r\n            throw new TypeError('Inequality comparisons require two values');\r\n        });\r\n    }\r\n\r\n    function greater(a, b){\r\n        throwWhenNotComparable(a, b);\r\n        return a > b;\r\n    }\r\n\r\n    function less(a, b){\r\n        throwWhenNotComparable(a, b);\r\n        return a < b;\r\n    }\r\n\r\n    function isInt(value){\r\n        return j.equal(j.truncate(value), value);\r\n    }\r\n\r\n    var isNegative = j.partial(greater, 0),\r\n        isPositive = j.partial(less, 0),\r\n        isZero = j.partial(j.equal, 0),\r\n        isEven = j.compose(isZero, j.rpartial(j.mod, 2));\r\n\r\n    j.isEven = isEven;\r\n    j.isInt = isInt;\r\n    j.isNegative = isNegative;\r\n    j.isNonNegative = j.compose(j.not, isNegative);\r\n    j.isNonPositive = j.compose(j.not, isPositive);\r\n    j.isNonZero = j.compose(j.not, isZero);\r\n    j.isOdd = j.compose(j.not, isEven);\r\n    j.isPositive = isPositive;\r\n    j.isZero = isZero;\r\n\r\n    //Special case predicate naming is intended for these functions\r\n    //There is a general expectation that these not be named with 'is'\r\n    j.geq = j.compose(j.not, less);\r\n    j.greater = greater;\r\n    j.leq = j.compose(j.not, greater);\r\n    j.less = less;\r\n\r\n})(jfp);\r\n\r\nvar j = jfp;\r\n\r\nif(typeof module !== 'undefined' && Boolean(module.exports)){\r\n    module.exports = j;\r\n}\r\n\r\n\r\n"]}