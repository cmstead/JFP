{"version":3,"file":"jfp.min.js","sources":["jfp.js"],"names":["jfp","resolveFunction","functionValue","curryAlias","args","slice","arguments","apply","curry","pickAlias","key","value","cleanKey","Boolean","pick","partial","chooseResolver","resolveToPick","charAt","resolver","j","isBoolean","isFunction","testFn","isObject","isArray","Object","prototype","toString","call","isString","isEmptyString","isNull","isNumber","isNumeric","pattern","match","isTruthy","isUndefined","undefined","not","identity","begin","valueSet","end","values","Array","shortCircuit","defaultValue","userFn","testValue","maybe","type","typeOkay","either","when","checkValue","eitherIf","predicateValue","safePredicate","eitherWhen","sanitizedFn","concat","original","extension","result","sanitizedExtension","i","length","push","basePartial","direction","appliedFunction","applicationArgs","reverseArgs","reverse","countArguments","execute","rpartial","toDec","parseInt","copyArray","makeValueArray","conj","dest","cons","source","first","lastIndex","last","drop","index","finalIndex","sanitizedIndex","firstArray","secondArray","dropLast","nth","rest","take","count","naturalComparator","a","b","comparison","sort","optionValue","comparator","finalSet","each","userArray","sanitizedArray","dropFirst","init","valueMap","pickResult","merge","defaultObj","mergeData","finalObj","argumentCount","appliedFn","recursor","recurFn","recursorFn","localRecursor","verifyRecurValue","recurValue","recur","recursingFn","valueReducer","baseObj","finalList","keyList","toValues","baseIsValid","keys","reducer","reduction","collection","finished","newReduction","reduce","initialState","appliedReducer","initialValue","remainder","compositor","f","g","compose","pipeline","partialReverse","map","filter","arrayReduceAdapter","reducerFn","valueList","mapper","finalArray","filterer","userPredicate","compact","predicateAccumulator","predicate","total","sanitizedTotal","numberOf","accumulator","captureUnique","unique","union","set1","set2","addToHash","finalObject","buildValueHash","captureIntersection","valueHash","intersect","setHash","captureDifference","difference","symmetricDifference","setUnion","setIntersection","everyReducer","every","finder","done","find","someRecur","some","contains","equal","ander","orer","reduceConditions","conditionArgs","operator","initialCondition","and","or","xor","equivalent","dereferencer","dataObject","token","trim","deref","baseData","sanitizedDefault","keyTokens","split","plucker","pluckKeys","sanitizedObject","pluck","adder","current","add","divider","divide","multiplier","multiply","subtractor","subtract","rangeRecurCheck","m","n","inc","rangeBuilder","currentRange","finalRange","range","start","increment","mod","modulo","_a","_b","Math","floor","abs","truncate","max","maxValue","Number","MAX_VALUE","min","minValue","fac","factorial","greater","throwWhenNotComparable","TypeError","isNotUndefined","less","isEven","isPositive","isZero","isNegative","isInt","isNonNegative","isNonPositive","isNonZero","isOdd","geq","leq","module","exports"],"mappings":"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","sourcesContent":["var jfp = (function(){\r\n    'use strict';\r\n    \r\n    function resolveFunction(functionValue){\r\n        return typeof functionValue === 'string' ? jfp[functionValue] : functionValue;\r\n    }\r\n    \r\n    function curryAlias(){\r\n        var args = jfp.slice(0, arguments);\r\n\r\n        args[0] = resolveFunction(args[0]);\r\n        \r\n        return jfp.apply(jfp.curry, args);\r\n    }\r\n    \r\n    function pickAlias(key, value){\r\n        var cleanKey = key.slice(1);\r\n        \r\n        return Boolean(value) ? jfp.pick(cleanKey, value) : jfp.partial(jfp.pick, cleanKey);\r\n    }\r\n    \r\n    function chooseResolver(value){\r\n        var resolveToPick = typeof value === 'string' && value.charAt(0) === ':';\r\n        \r\n        return resolveToPick ? pickAlias : curryAlias;\r\n    }\r\n    \r\n    return function(){\r\n        var args = jfp.slice(0, arguments),\r\n            resolver = chooseResolver(args[0]);\r\n        \r\n        return jfp.apply(resolver, args);\r\n    };\r\n    \r\n})();\r\n\r\n(function(j){\r\n    'use strict';\r\n    \r\n    function isBoolean(value){\r\n        return typeof value === 'boolean';\r\n    }\r\n\r\n    function isFunction(testFn){\r\n        return typeof testFn === 'function';\r\n    }\r\n    \r\n    function isObject(value){\r\n        return (typeof value == 'object');\r\n    }\r\n    \r\n    function isArray(value){\r\n        return (isObject(value) && Object.prototype.toString.call(value) === '[object Array]');\r\n    }\r\n    \r\n    function isString(value){\r\n        return typeof value === 'string';\r\n    }\r\n\r\n    function isEmptyString(value){\r\n        return isString(value) && value === '';\r\n    }\r\n    \r\n    function isNull(value){\r\n        return value === null;\r\n    }\r\n    \r\n    function isNumber(value){\r\n        return typeof value === 'number';\r\n    }\r\n    \r\n    function isNumeric(value){\r\n        var pattern = /^(0x)?[0-9]+((\\.[0-9]+)|(e\\-?[0-9]+))?$/;\r\n        return isNumber(value) || (isString(value) && !!value.match(pattern));\r\n    }\r\n    \r\n    function isTruthy(value){\r\n        return !!value;\r\n    }\r\n    \r\n    function isUndefined(value){\r\n        return value === undefined;\r\n    }\r\n\r\n    function not(value){\r\n        return !value;\r\n    }\r\n\r\n    j.isArray = isArray;\r\n    j.isBoolean = isBoolean;\r\n    j.isEmptyString = isEmptyString;\r\n    j.isFunction = isFunction;\r\n    j.isNull = isNull;\r\n    j.isNumber = isNumber;\r\n    j.isNumeric = isNumeric;\r\n    j.isObject = isObject;\r\n    j.isString = isString;\r\n    j.isTruthy = isTruthy;\r\n    j.isUndefined = isUndefined;\r\n    j.not = not;\r\n\r\n})(jfp);\r\n\r\n\r\n(function(j){\r\n    'use strict';\r\n\r\n    function identity(value){\r\n        return value;\r\n    }\r\n\r\n    function slice(begin, valueSet, end){\r\n        var values = j.not(j.isTruthy(valueSet)) ? [] : valueSet;\r\n\r\n        return j.not(j.isTruthy(end)) ?\r\n                    Array.prototype.slice.call(values, begin) :\r\n                    Array.prototype.slice.call(values, begin, end);\r\n    }\r\n\r\n    function shortCircuit(defaultValue, userFn, testValue){\r\n        return (j.isTruthy(testValue) || testValue === 0) ?\r\n            userFn(testValue) :\r\n            defaultValue;\r\n    }\r\n\r\n    function maybe(value){\r\n        var type = arguments[1],\r\n            typeOkay = typeof value === type;\r\n\r\n        return typeOkay || (!type && !!value) ? value : null;\r\n    }\r\n\r\n    function either(defaultValue, testValue){\r\n        var type = arguments[2];\r\n        return maybe(testValue, type) === null ? defaultValue : testValue;\r\n    }\r\n\r\n    function apply(userFn, args){\r\n        return userFn.apply(null, args);\r\n    }\r\n\r\n    function when(checkValue, userFn){\r\n        var args = slice(2, arguments);\r\n        return j.isTruthy(checkValue) ? apply(userFn, args) : null;\r\n    }\r\n\r\n    function eitherIf(defaultValue, testValue, predicateValue){\r\n        var safePredicate = j.isUndefined(predicateValue) ? true : predicateValue;\r\n\r\n        return j.either(defaultValue, j.when(safePredicate, j.partial(j.identity, testValue)));\r\n    }\r\n\r\n    function eitherWhen(defaultValue, predicateValue, userFn){\r\n        var sanitizedFn = eitherIf(j.identity, userFn, j.isFunction(userFn));\r\n\r\n        return j.either(defaultValue, j.when(predicateValue, sanitizedFn));\r\n    }\r\n\r\n    function concat(original, extension){\r\n        var result = slice(0, either([], original)),\r\n            sanitizedExtension = either([], extension),\r\n            i;\r\n\r\n        //This is the most performant way to handle concatenation. Trust me.\r\n        for(i = 0; i < sanitizedExtension.length; i++){\r\n            result.push(sanitizedExtension[i]);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    function basePartial(direction, userFn){\r\n        var args = slice(2, arguments);\r\n\r\n        return function appliedFunction(){\r\n            var applicationArgs = (direction === 'left') ?\r\n                                    concat(args, slice(0, arguments)) :\r\n                                    concat(slice(0, arguments), args);\r\n\r\n            return apply(userFn, applicationArgs);\r\n        };\r\n    }\r\n\r\n    function reverseArgs(userFn){\r\n        return function(){\r\n            var args = j.slice(0, arguments).reverse();\r\n            return j.apply(userFn, args);\r\n        };\r\n    }\r\n\r\n    function countArguments(userFn){\r\n        return either(function(){}, userFn).length;\r\n    }\r\n\r\n    function execute(userFn){\r\n        return j.apply(userFn, j.slice(1, arguments));\r\n    }\r\n\r\n    j.apply = apply;\r\n    j.concat = concat;\r\n    j.countArguments = countArguments;\r\n    j.either = either;\r\n    j.eitherIf = eitherIf;\r\n    j.eitherWhen = eitherWhen;\r\n    j.execute = execute;\r\n    j.identity = identity;\r\n    j.maybe = maybe;\r\n    j.partial = basePartial('left', basePartial, 'left');\r\n    j.reverseArgs = reverseArgs;\r\n    j.rpartial = basePartial('left', basePartial, 'right');\r\n    j.shortCircuit = shortCircuit;\r\n    j.slice = slice;\r\n    j.when = when;\r\n\r\n})(jfp);\r\n\r\n\r\n(function(j){\r\n    'use strict';\r\n\r\n    function toDec(value){\r\n        return (j.isNumeric(value)) ? parseInt(value, 10) : null;\r\n    }\r\n\r\n    j.toDec = toDec;\r\n\r\n})(jfp);\r\n\r\n(function(j){\r\n    'use strict';\r\n\r\n    function copyArray(valueSet){\r\n        return j.slice(0, valueSet);\r\n    }\r\n\r\n    function makeValueArray(value){\r\n        return j.not(j.isUndefined(value)) ? [value] : [];\r\n    }\r\n\r\n    function conj(value, dest){\r\n        return j.concat(copyArray(dest), makeValueArray(value));\r\n    }\r\n\r\n    function cons(value, source){\r\n        return j.concat(makeValueArray(value), source);\r\n    }\r\n\r\n    function first(values){\r\n        return j.isArray(values) ? j.either(null, values[0]) : null;\r\n    }\r\n\r\n    function lastIndex(values){\r\n        return j.isArray(values) ? values.length - 1 : null;\r\n    }\r\n\r\n    function last(values){\r\n        return j.isArray(values) ? values[lastIndex(values)] : null;\r\n    }\r\n\r\n    function drop(index, valueSet){\r\n        var finalIndex = lastIndex(valueSet),\r\n\r\n            sanitizedIndex = (index === 0 || index === finalIndex) ?\r\n                index : j.either(1, index) - 1,\r\n\r\n            firstArray = (sanitizedIndex === 0) ?\r\n                [] : j.slice(0, valueSet, sanitizedIndex),\r\n\r\n            secondArray = (sanitizedIndex === finalIndex)?\r\n                [] : j.slice(sanitizedIndex + 1, valueSet);\r\n\r\n        return j.concat(firstArray, secondArray);\r\n    }\r\n\r\n    function dropLast(valueSet){\r\n        return drop(lastIndex(valueSet), valueSet);\r\n    }\r\n\r\n    function nth(index, valueSet){\r\n        return j.either(null, j.either([], valueSet)[index]);\r\n    }\r\n\r\n    function rest(values){\r\n        return j.slice(1, values);\r\n    }\r\n\r\n    function take(count, values){\r\n        return j.isArray(values) ? j.slice(0, values, count) : null;\r\n    }\r\n\r\n    function naturalComparator(a, b){\r\n        var comparison = a < b ? -1 : 1;\r\n        return a === b ? 0 : comparison;\r\n    }\r\n\r\n    function sort(optionValue, valueSet){\r\n        var comparator = j.isFunction(optionValue) ? optionValue : naturalComparator,\r\n            finalSet = j.isArray(optionValue) ? j.slice(0, optionValue) : j.slice(0, valueSet);\r\n\r\n        return finalSet.sort(comparator);\r\n    }\r\n\r\n    function each(userFn, userArray){\r\n        var sanitizedArray = j.either([], userArray),\r\n            sanitizedFn = j.either(j.identity, userFn),\r\n            i;\r\n\r\n        for(i = 0; i < sanitizedArray.length; i++){\r\n            if(sanitizedFn(sanitizedArray[i], i) === false){\r\n                break;\r\n            }\r\n        }\r\n\r\n        return sanitizedArray;\r\n    }\r\n\r\n    j.conj = conj;\r\n    j.cons = cons;\r\n    j.copyArray = copyArray;\r\n    j.drop = drop;\r\n    j.dropFirst = j.partial(drop, 0);\r\n    j.dropLast = dropLast;\r\n    j.each = each;\r\n    j.first = first;\r\n    j.init = j.dropLast;\r\n    j.last = last;\r\n    j.lastIndex = lastIndex;\r\n    j.nth = nth;\r\n    j.rest = rest;\r\n    j.sort = sort;\r\n    j.take = take;\r\n\r\n})(jfp);\r\n\r\n\r\n(function(j){\r\n    'use strict';\r\n\r\n    function pick(key, valueMap){\r\n        var pickResult = j.either({}, valueMap)[key];\r\n        return j.isUndefined(pickResult) ? null : pickResult;\r\n    }\r\n\r\n    function merge(defaultObj, mergeData){\r\n        var finalObj = {},\r\n            key;\r\n\r\n        for(key in j.either({}, defaultObj)){\r\n            finalObj[key] = defaultObj[key];\r\n        }\r\n\r\n        for(key in j.either({}, mergeData)){\r\n            finalObj[key] = mergeData[key];\r\n        }\r\n\r\n        return j.eitherIf(null, finalObj, j.isTruthy(defaultObj));\r\n    }\r\n\r\n    j.merge = merge;\r\n    j.pick = pick;\r\n\r\n})(jfp);\r\n\r\n\r\n(function(j){\r\n    'use strict';\r\n\r\n    //This is complicated and I don't expect people to grok it on first read.\r\n    function curry(userFn){\r\n        var args = j.slice(1, arguments),\r\n            argumentCount = j.countArguments(userFn),\r\n            appliedFn = (args.length < argumentCount) ? j.apply(j.partial, j.concat([curry, userFn], args)) : null,\r\n            result = (!!userFn && args.length >= argumentCount) ? j.apply(userFn, args) : null;\r\n\r\n        return j.either(appliedFn, result);\r\n    }\r\n\r\n    //zOMG! TAIL RECURSION\r\n    function recursor(recurFn){\r\n        var args = j.slice(1, arguments);\r\n\r\n        //This is to make the returned function distinct and identifiable.\r\n        return function recursorFn(localRecursor){\r\n            return j.apply(recurFn, j.concat([localRecursor], args));\r\n        };\r\n    }\r\n\r\n    function verifyRecurValue(recurValue){\r\n        return typeof recurValue === 'function' &&\r\n            recurValue.toString().match('recursorFn');\r\n    }\r\n\r\n    //Tail optimization with managed recursion is really complicated.\r\n    //Please don't muck with this unless you TRULY understand what is happening.\r\n    function recur(userFn){\r\n        var recursingFn = j.either(j.identity, userFn),\r\n            localRecursor = j.partial(recursor, recursingFn),\r\n            recurValue = j.apply(localRecursor, j.slice(1, arguments));\r\n\r\n        while(verifyRecurValue(recurValue = recurValue(localRecursor)) && recursingFn !== j.identity);\r\n\r\n        return recurValue;\r\n    }\r\n\r\n    /*\r\n     * toValues converts an object to an array of values\r\n     * This is necessary for reduce to convert objects into\r\n     * processible arrays in an upcoming version.\r\n     */\r\n    function valueReducer (recur, baseObj, finalList, keyList) {\r\n        finalList.push(baseObj[j.first(keyList)]);\r\n        return keyList.length === 1 ? finalList : recur(baseObj, finalList, j.rest(keyList));\r\n    }\r\n    \r\n    function toValues (baseObj) {\r\n        var baseIsValid = typeof baseObj === 'object';\r\n        return !baseIsValid ? null : j.recur(valueReducer, baseObj, [], Object.keys(baseObj));\r\n    }\r\n    \r\n\t/*\r\n     * Reduce uses tail-optimized (while-trampolined, fully returning) recursion to resolve reductions.\r\n     * Reducer is a pure function for handling a single reduction step.\r\n     * Reduce manages the setup and recursion execution.\r\n     */\r\n    function reducer(userFn, recur, reduction, collection){\r\n        var finished = collection.length === 0,\r\n            newReduction = finished ? reduction : userFn(reduction, j.first(collection));\r\n            \r\n        return finished ? reduction : recur(newReduction, j.rest(collection));\r\n    }\r\n\r\n    function reduce(userFn, values, initialState){\r\n        var appliedReducer = j.partial(reducer, userFn),\r\n            initialValue = j.isUndefined(initialState) ? j.first(values) : initialState,\r\n            remainder = j.isUndefined(initialState) ? j.rest(values) : values;\r\n            \r\n        return (!!values && values.length > 0) ? j.recur(appliedReducer, initialValue, remainder) : initialValue;\r\n    }\r\n\r\n    //Produces a function that returns f(g(x))\r\n    function compositor(f, g){\r\n        return function(){\r\n            return f(j.apply(g, j.slice(0, arguments)));\r\n        };\r\n    }\r\n\r\n    function compose(){\r\n        return reduce(compositor, j.slice(0, arguments), j.identity);\r\n    }\r\n\r\n    function pipeline(value){\r\n        return j.apply(compose, j.slice(1, arguments).reverse())(value);\r\n    }\r\n\r\n    function partialReverse(){\r\n        return j.apply(j.compose(j.reverseArgs, j.partial),\r\n                       j.slice(0, arguments));\r\n    }\r\n\r\n    j.compose = compose;\r\n    j.curry = curry;\r\n    j.partialReverse = partialReverse;\r\n    j.pipeline = pipeline;\r\n    j.recur = recur;\r\n    j.reduce = reduce;\r\n    j.toValues = toValues;\r\n\r\n})(jfp);\r\n\r\n\r\n(function(j){\r\n\t\r\n    var map, filter;\r\n    \r\n    // Adapter function for reduce to allow for simplification of\r\n    // array construction behaviors like map and filter\r\n    function arrayReduceAdapter(reducerFn, userFn, valueList){\r\n        var appliedReducer = j.partial(reducerFn, userFn),\r\n            result = j.reduce(appliedReducer, valueList, []);\r\n        \r\n        return j.either([], result);\r\n    }\r\n\r\n    /*\r\n     * Map uses reduce to produce a new, completely reference-decoupled list of values\r\n     * Mapper handles a single update step for the final output array\r\n     */\r\n    function mapper(userFn, finalArray, value){\r\n        finalArray.push(userFn(value));\r\n        return finalArray;\r\n    }\r\n\r\n    map = j.partial(arrayReduceAdapter, mapper);\r\n\r\n    /*\r\n     * Filter uses reduce to produce a new, completely reference-decoupled list of values\r\n     * Filterer handles a single update step for the final output array\r\n     */\r\n    function filterer(userPredicate, finalArray, value){\r\n        return userPredicate(value) ? j.conj(value, finalArray) : finalArray;\r\n    }\r\n\r\n    filter = j.partial(arrayReduceAdapter, filterer);\r\n    \r\n    function compact(valueList){\r\n        return filter(j.isTruthy, valueList);\r\n    }\r\n\r\n    function predicateAccumulator(predicate, total, value){\r\n        var sanitizedTotal = j.either(0, total, 'number');\r\n        return predicate(value) ? sanitizedTotal + 1 : sanitizedTotal;\r\n    }\r\n\r\n    function numberOf(predicate, valueSet){\r\n        var accumulator = j.partial(predicateAccumulator, predicate);\r\n        return j.reduce(accumulator, j.either([], valueSet), 0);\r\n    }\r\n\r\n    function captureUnique(finalList, value){\r\n        return j.last(finalList) === value ? finalList : j.conj(value, finalList);\r\n    }\r\n    \r\n    function unique(valueSet){\r\n        return j.reduce(captureUnique, j.sort(j.slice(0, valueSet)), []);\r\n    }\r\n\r\n    function union(set1, set2){\r\n        return j.compose(j.unique, j.concat)(set1, set2);\r\n    }\r\n\r\n    function addToHash(finalObject, value){\r\n        finalObject[value] = true;\r\n        return finalObject;\r\n    }\r\n\r\n    function buildValueHash(valueList){\r\n        return j.either({}, j.reduce(addToHash, valueList, {}));\r\n    }\r\n\r\n    function captureIntersection(valueHash, finalList, value){\r\n        return valueHash[value] ? j.conj(value, finalList) : finalList;\r\n    }\r\n    \r\n    function intersect(set1, set2){\r\n        var setHash = buildValueHash(j.either([], set2));\r\n        return j.reduce(j.partial(captureIntersection, setHash), set1, []); \r\n    }\r\n\r\n    function captureDifference(valueHash, finalList, value){\r\n        return !valueHash[value] ? j.conj(value, finalList) : finalList;\r\n    }\r\n    \r\n    function difference(set1, set2){\r\n        var setHash = buildValueHash(j.either([], set2));\r\n        return j.reduce(j.partial(captureDifference, setHash), set1, []);\r\n    }\r\n\r\n    function symmetricDifference(set1, set2){\r\n        var setUnion = union(set1, set2),\r\n            setIntersection = intersect(set1, set2);\r\n\r\n        return difference(setUnion, setIntersection);\r\n    }\r\n\r\n    function everyReducer (predicate, result, valueList){\r\n        return result && predicate(valueList);\r\n    }\r\n\r\n    function every (predicate, valueList){\r\n        var reducer = j.partial(everyReducer, predicate);\r\n        return Boolean(j.reduce(reducer, valueList, true));\r\n    }\r\n\r\n    function finder (recur, predicate, valueList) {\r\n        var done = !Boolean(valueList) || valueList.length === 0,\r\n            result = done ? null : j.first(valueList);\r\n        \r\n        return done || predicate(result) ? result : recur(predicate, j.rest(valueList));\r\n    }\r\n\r\n    function find (predicate, valueList){\r\n        return j.recur(finder, predicate, valueList);\r\n    }\r\n\r\n    function someRecur(recur, predicate, valueList){\r\n        var done = valueList.length === 0,\r\n            result = done ? false : predicate(j.first(valueList));\r\n            \r\n        return result || done ? result : recur(predicate, j.rest(valueList));\r\n    }\r\n\r\n    function some(predicate, valueList){\r\n        return Boolean(j.recur(someRecur, predicate, valueList));\r\n    }\r\n    \r\n    function contains(value, valueList){\r\n        return some(j.partial(j.equal, value), valueList);\r\n    }\r\n\r\n    j.contains = contains;\r\n    j.compact = compact;\r\n    j.difference = difference;\r\n    j.every = every;\r\n\tj.filter = filter;\r\n    j.find = find;\r\n    j.intersect = intersect;\r\n\tj.map = map;\r\n\tj.numberOf = numberOf;\r\n    j.some = some;\r\n    j.symmetricDifference = symmetricDifference;\r\n    j.union = union;\r\n    j.unique = unique;\r\n\r\n})(jfp);\r\n\r\n(function (j) {\r\n\t'use strict';\r\n\t\r\n\t//Performs 'and' operation on valueSet\r\n    function ander(a, b){\r\n        return a && b;\r\n    }\r\n\r\n    function orer(a, b){\r\n        return a || b;\r\n    }\r\n\r\n    function reduceConditions(conditionArgs, operator, initialCondition){\r\n        var args = j.map(Boolean, j.slice(0, conditionArgs));\r\n        return Boolean(j.reduce(operator, args, initialCondition));\r\n    }\r\n\r\n    function and(a, b){\r\n        return reduceConditions(arguments, ander, true);\r\n    }\r\n\r\n    function or(a, b){\r\n        return reduceConditions(arguments, orer, false);\r\n    }\r\n\r\n    function xor(a, b){\r\n        var equivalent = Boolean(a) === Boolean(b);\r\n        return or(a, b) && j.not(equivalent);\r\n    }\r\n\r\n\tj.and = and;\r\n\tj.or = or;\r\n\tj.xor = xor;\r\n\r\n})(jfp);\r\n\r\n(function (j) {\r\n\t'use strict';\r\n\t\r\n\tfunction dereferencer(dataObject, token){\r\n        var key = j.either('', token).trim();\r\n        return key === '' ? dataObject : j.pick(token, dataObject);\r\n    }\r\n\r\n    function deref(baseData, key, defaultValue){\r\n        var sanitizedDefault = defaultValue === undefined ? null : defaultValue,\r\n            keyTokens = j.either('', key, 'string').split('.'),\r\n            result = j.reduce(dereferencer, keyTokens, j.either(null, baseData, 'object'));\r\n        \r\n        return j.either(sanitizedDefault, result);\r\n    }\r\n    \r\n    function plucker (baseObj, finalObj, key){\r\n        finalObj[key] = baseObj[key];\r\n        return finalObj;\r\n    }\r\n    \r\n    function pluckKeys (keys, baseObj){\r\n        var sanitizedObject = j.either({}, baseObj, 'object');\r\n        return j.reduce(j.partial(plucker, sanitizedObject), keys, {});\r\n    }\r\n    \r\n    function pluck (key, baseObj) {\r\n        return pluckKeys([key], baseObj);\r\n    }\r\n\r\n\tj.deref = deref;\r\n    j.pluck = pluck;\r\n    j.pluckKeys = pluckKeys;\r\n\r\n})(jfp);\r\n\r\n(function(j){\r\n    'use strict';\r\n\r\n//This is a recursive add fn\r\n    function adder(recur, current, valueSet){\r\n        return (valueSet.length === 0) ?\r\n                current :\r\n                recur(current + j.first(valueSet), j.rest(valueSet));\r\n    }\r\n    \r\n    function add(a, b){\r\n        return j.recur(adder, 0, j.slice(0, arguments));\r\n    }\r\n    \r\n    //This is a recursive divide fn\r\n    function divider(recur, current, valueSet){\r\n        return (valueSet.length === 0) ?\r\n                current :\r\n                recur(current / j.first(valueSet), j.rest(valueSet));\r\n    }\r\n    \r\n    function divide(){\r\n        var args = j.slice(0, arguments),\r\n            first = args.length ? j.first(args) : 1;\r\n        return j.recur(divider, first, j.rest(args));\r\n    }\r\n    \r\n    //This is a recursive multiply fn\r\n    function multiplier(recur, current, valueSet){\r\n        return (valueSet.length === 0) ?\r\n                current :\r\n                recur(current * j.first(valueSet), j.rest(valueSet));\r\n    }\r\n    \r\n    function multiply(){\r\n        return j.recur(multiplier, 1, j.slice(0, arguments));\r\n    }\r\n    \r\n    //This is a recursive subtraction fn\r\n    function subtractor(recur, current, valueSet){\r\n        return (valueSet.length === 0) ?\r\n                current :\r\n                recur(current - j.first(valueSet), j.rest(valueSet));\r\n    }\r\n    \r\n    function subtract(){\r\n        var args = j.slice(0, arguments),\r\n            first = args.length ? j.first(args) : 0;\r\n        return j.recur(subtractor, first, j.rest(args));\r\n    }\r\n\r\n    //This is a recursive constructor function for ranges\r\n    function rangeRecurCheck(m, n, inc){\r\n        return inc > 0 ? (m + inc) < n : (m + inc) > n;\r\n    }\r\n\r\n    function rangeBuilder(recur, currentRange, m, n, inc){\r\n        var finalRange = rangeRecurCheck(m - inc, n, inc) ?\r\n                            j.conj(m, currentRange) :\r\n                            currentRange;\r\n        \r\n        return rangeRecurCheck(m, n, inc) ?\r\n                recur(finalRange, m + inc, n, inc) :\r\n                finalRange;\r\n    }\r\n    \r\n    function range(a, b, inc){\r\n        var start = j.isUndefined(b) ? 0 : a,\r\n            end = j.isUndefined(b) ? j.either(0, a) : b,\r\n            increment = (!inc) ? 1 : inc;\r\n            \r\n        return j.recur(rangeBuilder,\r\n                       [],\r\n                       j.either(0, start),\r\n                       j.either(0, end),\r\n                       increment);\r\n    }\r\n\r\n    function mod(a, b){\r\n        return j.isUndefined(b) ? j.either(0, a) : a%b;\r\n    }\r\n\r\n    function modulo(a, b){\r\n        var _a = j.either(0, a),\r\n            _b = j.either(0, b);\r\n\r\n        return (_a > 0) ? mod(_a, _b) : _b * (Math.floor(Math.abs(_a)/_b) + 1) + _a;\r\n    }\r\n\r\n    function truncate(value){\r\n        return (value > 0) ? Math.floor(value) : Math.floor(value) + 1;\r\n    }\r\n    \r\n    function max(a, b){\r\n        var maxValue = -Number.MAX_VALUE,\r\n            _a = j.isUndefined(a) ? maxValue : a,\r\n            _b = j.isUndefined(b) ? maxValue : b;\r\n            \r\n        maxValue = (_a > maxValue) ? _a : maxValue;\r\n        maxValue = (_b > maxValue) ? _b : maxValue;\r\n        \r\n        return maxValue;\r\n    }\r\n    \r\n    function min(a, b){\r\n        var minValue = Number.MAX_VALUE,\r\n            _a = j.isUndefined(a) ? minValue : a,\r\n            _b = j.isUndefined(b) ? minValue : b;\r\n        \r\n        minValue = (_a < minValue) ? _a : minValue;\r\n        minValue = (_b < minValue) ? _b : minValue;\r\n        \r\n        return minValue;\r\n    }\r\n\r\n    function fac(value){\r\n        var factorial = j.compose(j.partial(j.reduce, multiply),\r\n                                  j.partial(range, 1),\r\n                                  j.partial(add, 1));\r\n\r\n        return j.either(1, j.when(j.greater(value, 0), factorial, value));\r\n    }\r\n\r\n    j.add = add;\r\n    j.divide = divide;\r\n    j.fac = fac;\r\n    j.inc = j.partial(j.add, 1);\r\n    j.max = max;\r\n    j.min = min;\r\n    j.mod = mod;\r\n    j.modulo = modulo;\r\n    j.multiply = multiply;\r\n    j.range = range;\r\n    j.subtract = subtract;\r\n    j.truncate = truncate;\r\n\r\n})(jfp);\r\n\r\n\r\n(function(j){\r\n\r\n    function throwWhenNotComparable(a, b){\r\n        j.when(j.isUndefined(a) || j.isUndefined(b), function(){\r\n            throw new TypeError('Inequality comparisons require two values');\r\n        });\r\n    }\r\n\r\n    function equal(a, b){\r\n        var isNotUndefined = j.compose(j.not, j.isUndefined);\r\n        return (isNotUndefined(a) && isNotUndefined(b)) ? a === b : false;\r\n    }\r\n\r\n    function greater(a, b){\r\n        throwWhenNotComparable(a, b);\r\n        return a > b;\r\n    }\r\n\r\n    function less(a, b){\r\n        throwWhenNotComparable(a, b);\r\n        return a < b;\r\n    }\r\n\r\n    function isEven(value){\r\n        return equal(0, j.mod(value, 2));\r\n    }\r\n\r\n    function isPositive(value){\r\n        return greater(value, 0);\r\n    }\r\n\r\n    function isZero(value){\r\n        return value === 0;\r\n    }\r\n\r\n    function isNegative(value){\r\n        return j.compose(j.not, j.or)(isPositive(value), isZero(value));\r\n    }\r\n\r\n    function isInt(value){\r\n        return equal(j.truncate(value), value);\r\n    }\r\n\r\n    j.isEven = isEven;\r\n    j.isInt = isInt;\r\n    j.isNegative = isNegative;\r\n    j.isNonNegative = j.compose(j.not, isNegative);\r\n    j.isNonPositive = j.compose(j.not, isPositive);\r\n    j.isNonZero = j.compose(j.not, isZero);\r\n    j.isOdd = j.compose(j.not, isEven);\r\n    j.isPositive = isPositive;\r\n    j.isZero = isZero;\r\n\r\n    //Special case predicate naming is intended for these functions\r\n    //There is a general expectation that these not be named with 'is'\r\n    j.equal = equal;\r\n    j.geq = j.compose(j.not, less);\r\n    j.greater = greater;\r\n    j.leq = j.compose(j.not, greater);\r\n    j.less = less;\r\n\r\n})(jfp);\r\n\r\nvar j = jfp;\r\n\r\nif(typeof module !== 'undefined' && !!module.exports){\r\n    module.exports = j;\r\n}\r\n\r\n\r\n"]}