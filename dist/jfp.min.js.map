{"version":3,"file":"jfp.min.js","sources":["jfp.js"],"names":["jfp","resolveFunction","functionValue","curryAlias","args","slice","arguments","apply","curry","pickAlias","key","value","cleanKey","Boolean","pick","partial","chooseResolver","resolveToPick","charAt","resolver","j","isBoolean","isFunction","testFn","isObject","isArray","Object","prototype","toString","call","isString","isEmptyString","isNull","isNumber","isNumeric","pattern","match","isTruthy","isUndefined","undefined","not","identity","begin","valueSet","end","values","Array","shortCircuit","defaultValue","userFn","testValue","maybe","type","typeOkay","either","when","checkValue","eitherIf","predicateValue","safePredicate","eitherWhen","sanitizedFn","concat","original","extension","result","sanitizedExtension","i","length","push","basePartial","direction","appliedFunction","applicationArgs","reverseArgs","reverse","countArguments","execute","rpartial","toValues","valueMap","finalArray","hasOwnProperty","conj","toDec","parseInt","copyArray","makeValueArray","dest","cons","source","each","userArray","sanitizedArray","find","predicate","finalValue","findFn","first","lastIndex","last","drop","index","finalIndex","sanitizedIndex","firstArray","secondArray","dropLast","nth","rest","take","count","some","satisfied","someFn","contains","equal","every","everyFn","naturalComparator","a","b","comparison","sort","optionValue","comparator","finalSet","dropFirst","init","pickResult","pluckKeys","keys","finalOutput","sanitizedKeys","sanitizedValueMap","captureValue","pluck","merge","defaultObj","mergeData","finalObj","map","filter","argumentCount","appliedFn","recursor","recurFn","recursorFn","localRecursor","verifyRecurValue","recurValue","recur","recursingFn","reducer","reduction","collection","finished","newReduction","reduce","initialState","appliedReducer","initialValue","remainder","arrayReduceAdapter","reducerFn","valueList","mapper","filterer","userPredicate","predicateAccumulator","total","sanitizedTotal","console","log","numberOf","accumulator","ander","orer","reduceConditions","conditionArgs","operator","initialCondition","and","or","xor","equivalent","compositor","f","g","compose","pipeline","captureUnique","finalList","unique","partialReverse","dereferencer","dataObject","token","trim","deref","baseData","sanitizedDefault","keyTokens","split","union","set1","set2","addToHash","finalObject","buildValueHash","captureIntersection","valueHash","intersect","setHash","captureDifference","difference","symmetricDifference","setUnion","setIntersection","compact","adder","current","add","divider","divide","multiplier","multiply","subtractor","subtract","rangeRecurCheck","m","n","inc","rangeBuilder","currentRange","finalRange","range","start","increment","mod","modulo","_a","_b","Math","floor","abs","truncate","max","maxValue","Number","MAX_VALUE","min","minValue","fac","factorial","greater","throwWhenNotComparable","TypeError","isNotUndefined","less","isEven","isPositive","isZero","isNegative","isInt","isNonNegative","isNonPositive","isNonZero","isOdd","geq","leq","module","exports"],"mappings":"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","sourcesContent":["var jfp = (function(){\n    'use strict';\n    \n    function resolveFunction(functionValue){\n        return typeof functionValue === 'string' ? jfp[functionValue] : functionValue;\n    }\n    \n    function curryAlias(){\n        var args = jfp.slice(0, arguments);\n\n        args[0] = resolveFunction(args[0]);\n        \n        return jfp.apply(jfp.curry, args);\n    }\n    \n    function pickAlias(key, value){\n        var cleanKey = key.slice(1);\n        \n        return Boolean(value) ? jfp.pick(cleanKey, value) : jfp.partial(jfp.pick, cleanKey);\n    }\n    \n    function chooseResolver(value){\n        var resolveToPick = typeof value === 'string' && value.charAt(0) === ':';\n        \n        return resolveToPick ? pickAlias : curryAlias;\n    }\n    \n    return function(){\n        var args = jfp.slice(0, arguments),\n            resolver = chooseResolver(args[0]);\n        \n        return jfp.apply(resolver, args);\n    };\n    \n})();\n\n(function(j){\n    'use strict';\n    \n    function isBoolean(value){\n        return typeof value === 'boolean';\n    }\n\n    function isFunction(testFn){\n        return typeof testFn === 'function';\n    }\n    \n    function isObject(value){\n        return (typeof value == 'object');\n    }\n    \n    function isArray(value){\n        return (isObject(value) && Object.prototype.toString.call(value) === '[object Array]');\n    }\n    \n    function isString(value){\n        return typeof value === 'string';\n    }\n\n    function isEmptyString(value){\n        return isString(value) && value === '';\n    }\n    \n    function isNull(value){\n        return value === null;\n    }\n    \n    function isNumber(value){\n        return typeof value === 'number';\n    }\n    \n    function isNumeric(value){\n        var pattern = /^(0x)?[0-9]+((\\.[0-9]+)|(e\\-?[0-9]+))?$/;\n        return isNumber(value) || (isString(value) && !!value.match(pattern));\n    }\n    \n    function isTruthy(value){\n        return !!value;\n    }\n    \n    function isUndefined(value){\n        return value === undefined;\n    }\n\n    function not(value){\n        return !value;\n    }\n\n    j.isArray = isArray;\n    j.isBoolean = isBoolean;\n    j.isEmptyString = isEmptyString;\n    j.isFunction = isFunction;\n    j.isNull = isNull;\n    j.isNumber = isNumber;\n    j.isNumeric = isNumeric;\n    j.isObject = isObject;\n    j.isString = isString;\n    j.isTruthy = isTruthy;\n    j.isUndefined = isUndefined;\n    j.not = not;\n\n})(jfp);\n\n\n(function(j){\n    'use strict';\n\n    function identity(value){\n        return value;\n    }\n\n    function slice(begin, valueSet, end){\n        var values = j.not(j.isTruthy(valueSet)) ? [] : valueSet;\n\n        return j.not(j.isTruthy(end)) ?\n                    Array.prototype.slice.call(values, begin) :\n                    Array.prototype.slice.call(values, begin, end);\n    }\n\n    function shortCircuit(defaultValue, userFn, testValue){\n        return (j.isTruthy(testValue) || testValue === 0) ?\n            userFn(testValue) :\n            defaultValue;\n    }\n\n    function maybe(value){\n        var type = arguments[1],\n            typeOkay = typeof value === type;\n\n        return typeOkay || (!type && !!value) ? value : null;\n    }\n\n    function either(defaultValue, testValue){\n        var type = arguments[2];\n        return maybe(testValue, type) === null ? defaultValue : testValue;\n    }\n\n    function apply(userFn, args){\n        return userFn.apply(null, args);\n    }\n\n    function when(checkValue, userFn){\n        var args = slice(2, arguments);\n        return j.isTruthy(checkValue) ? apply(userFn, args) : null;\n    }\n\n    function eitherIf(defaultValue, testValue, predicateValue){\n        var safePredicate = j.isUndefined(predicateValue) ? true : predicateValue;\n\n        return j.either(defaultValue, j.when(safePredicate, j.partial(j.identity, testValue)));\n    }\n\n    function eitherWhen(defaultValue, predicateValue, userFn){\n        var sanitizedFn = eitherIf(j.identity, userFn, j.isFunction(userFn));\n\n        return j.either(defaultValue, j.when(predicateValue, sanitizedFn));\n    }\n\n    function concat(original, extension){\n        var result = slice(0, either([], original)),\n            sanitizedExtension = either([], extension),\n            i;\n\n        //This is the most performant way to handle concatenation. Trust me.\n        for(i = 0; i < sanitizedExtension.length; i++){\n            result.push(sanitizedExtension[i]);\n        }\n\n        return result;\n    }\n\n    function basePartial(direction, userFn){\n        var args = slice(2, arguments);\n\n        return function appliedFunction(){\n            var applicationArgs = (direction === 'left') ?\n                                    concat(args, slice(0, arguments)) :\n                                    concat(slice(0, arguments), args);\n\n            return apply(userFn, applicationArgs);\n        };\n    }\n\n    function reverseArgs(userFn){\n        return function(){\n            var args = j.slice(0, arguments).reverse();\n            return j.apply(userFn, args);\n        };\n    }\n\n    function countArguments(userFn){\n        return either(function(){}, userFn).length;\n    }\n\n    function execute(userFn){\n        return j.apply(userFn, j.slice(1, arguments));\n    }\n\n    j.apply = apply;\n    j.concat = concat;\n    j.countArguments = countArguments;\n    j.either = either;\n    j.eitherIf = eitherIf;\n    j.eitherWhen = eitherWhen;\n    j.execute = execute;\n    j.identity = identity;\n    j.maybe = maybe;\n    j.partial = basePartial('left', basePartial, 'left');\n    j.reverseArgs = reverseArgs;\n    j.rpartial = basePartial('left', basePartial, 'right');\n    j.shortCircuit = shortCircuit;\n    j.slice = slice;\n    j.when = when;\n\n})(jfp);\n\n\n(function(j){\n    'use strict';\n\n    function toValues(valueMap){\n        var finalArray = [],\n            key;\n\n        j.when(j.isObject(valueMap), function(){\n            for(key in valueMap){\n                if(valueMap.hasOwnProperty(key) && j.isTruthy(valueMap[key])){\n                    finalArray = j.conj(valueMap[key], finalArray);\n                }\n            }\n        });\n\n        return j.either(null, j.when(j.isObject(valueMap), function(){ return finalArray; }));\n    }\n\n    function toDec(value){\n        return (j.isNumeric(value)) ? parseInt(value, 10) : null;\n    }\n\n    j.toDec = toDec;\n    j.toValues = toValues;\n\n})(jfp);\n\n(function(j){\n    'use strict';\n\n    function copyArray(valueSet){\n        return j.slice(0, valueSet);\n    }\n\n    function makeValueArray(value){\n        return j.not(j.isUndefined(value)) ? [value] : [];\n    }\n\n    function conj(value, dest){\n        return j.concat(copyArray(dest), makeValueArray(value));\n    }\n\n    function cons(value, source){\n        return j.concat(makeValueArray(value), source);\n    }\n\n    function each(userFn, userArray){\n        var sanitizedArray = j.either([], userArray),\n            sanitizedFn = j.either(j.identity, userFn),\n            i;\n\n        for(i = 0; i < sanitizedArray.length; i++){\n            if(sanitizedFn(sanitizedArray[i], i) === false){\n                break;\n            }\n        }\n\n        return sanitizedArray;\n    }\n\n    function find(predicate, valueSet){\n        var finalValue = null;\n\n        function findFn(value){\n            return j.not(j.when(predicate(value), function(){\n                            finalValue = value;\n                            return true;\n                         }));\n        }\n\n        each(findFn, j.either([], valueSet));\n\n        return finalValue;\n    }\n\n    function first(values){\n        return j.isArray(values) ? j.either(null, values[0]) : null;\n    }\n\n    function lastIndex(values){\n        return j.isArray(values) ? values.length - 1 : null;\n    }\n\n    function last(values){\n        return j.isArray(values) ? values[lastIndex(values)] : null;\n    }\n\n    function drop(index, valueSet){\n        var finalIndex = lastIndex(valueSet),\n\n            sanitizedIndex = (index === 0 || index === finalIndex) ?\n                index : j.either(1, index) - 1,\n\n            firstArray = (sanitizedIndex === 0) ?\n                [] : j.slice(0, valueSet, sanitizedIndex),\n\n            secondArray = (sanitizedIndex === finalIndex)?\n                [] : j.slice(sanitizedIndex + 1, valueSet);\n\n        return j.concat(firstArray, secondArray);\n    }\n\n    function dropLast(valueSet){\n        return drop(lastIndex(valueSet), valueSet);\n    }\n\n    function nth(index, valueSet){\n        return j.either(null, j.either([], valueSet)[index]);\n    }\n\n    function rest(values){\n        return j.slice(1, values);\n    }\n\n    function take(count, values){\n        return j.isArray(values) ? j.slice(0, values, count) : null;\n    }\n\n    function some(predicate, valueSet){\n        var satisfied = false;\n\n        function someFn(value, index){\n            satisfied = predicate(value, index);\n            return !satisfied;\n        }\n\n        each(someFn, valueSet);\n\n        return satisfied;\n    }\n\n    function contains(value, valueSet){\n        return some(j.partial(j.equal, value), valueSet);\n    }\n\n    function every(predicate, valueSet){\n        var satisfied = false;\n\n        function everyFn(value, index){\n            satisfied = predicate(value, index);\n            return satisfied;\n        }\n\n        each(everyFn, valueSet);\n\n        return satisfied;\n    }\n\n    function naturalComparator(a, b){\n        var comparison = a < b ? -1 : 1;\n        return a === b ? 0 : comparison;\n    }\n\n    function sort(optionValue, valueSet){\n        var comparator = j.isFunction(optionValue) ? optionValue : naturalComparator,\n            finalSet = j.isArray(optionValue) ? j.slice(0, optionValue) : j.slice(0, valueSet);\n\n        return finalSet.sort(comparator);\n    }\n\n    j.conj = conj;\n    j.cons = cons;\n    j.contains = contains;\n    j.copyArray = copyArray;\n    j.drop = drop;\n    j.dropFirst = j.partial(drop, 0);\n    j.dropLast = dropLast;\n    j.each = each;\n    j.every = every;\n    j.find = find;\n    j.first = first;\n    j.init = j.dropLast;\n    j.last = last;\n    j.lastIndex = lastIndex;\n    j.nth = nth;\n    j.rest = rest;\n    j.sort = sort;\n    j.some = some;\n    j.take = take;\n\n})(jfp);\n\n\n(function(j){\n    'use strict';\n\n    function pick(key, valueMap){\n        var pickResult = j.either({}, valueMap)[key];\n        return j.isUndefined(pickResult) ? null : pickResult;\n    }\n\n    function pluckKeys(keys, valueMap){\n        var finalOutput = {},\n            sanitizedKeys = j.either([], keys),\n            sanitizedValueMap = j.either({}, valueMap);\n\n        function captureValue(key){\n            finalOutput[key] = sanitizedValueMap[key];\n        }\n\n        j.each(captureValue, sanitizedKeys);\n\n        return finalOutput;\n    }\n\n    function pluck(key, valueMap){\n        return pluckKeys([key], valueMap);\n    }\n\n    function merge(defaultObj, mergeData){\n        var finalObj = {},\n            key;\n\n        for(key in j.either({}, defaultObj)){\n            finalObj[key] = defaultObj[key];\n        }\n\n        for(key in j.either({}, mergeData)){\n            finalObj[key] = mergeData[key];\n        }\n\n        return j.eitherIf(null, finalObj, j.isTruthy(defaultObj));\n    }\n\n    j.merge = merge;\n    j.pick = pick;\n    j.pluck = pluck;\n    j.pluckKeys = pluckKeys;\n\n})(jfp);\n\n\n(function(j){\n    'use strict';\n\n    var map, filter;\n\n    //This is complicated and I don't expect people to grok it on first read.\n    function curry(userFn){\n        var args = j.slice(1, arguments),\n            argumentCount = j.countArguments(userFn),\n            appliedFn = (args.length < argumentCount) ? j.apply(j.partial, j.concat([curry, userFn], args)) : null,\n            result = (!!userFn && args.length >= argumentCount) ? j.apply(userFn, args) : null;\n\n        return j.either(appliedFn, result);\n    }\n\n    //zOMG! TAIL RECURSION\n    function recursor(recurFn){\n        var args = j.slice(1, arguments);\n\n        //This is to make the returned function distinct and identifiable.\n        return function recursorFn(localRecursor){\n            return j.apply(recurFn, j.concat([localRecursor], args));\n        };\n    }\n\n    function verifyRecurValue(recurValue){\n        return typeof recurValue === 'function' &&\n            recurValue.toString().match('recursorFn');\n    }\n\n    //Tail optimization with managed recursion is really complicated.\n    //Please don't muck with this unless you TRULY understand what is happening.\n    function recur(userFn){\n        var recursingFn = j.either(j.identity, userFn),\n            localRecursor = j.partial(recursor, recursingFn),\n            recurValue = j.apply(localRecursor, j.slice(1, arguments));\n\n        while(verifyRecurValue(recurValue = recurValue(localRecursor)) && recursingFn !== j.identity);\n\n        return recurValue;\n    }\n\n\n    /*\n     * Reduce uses tail-optimized (while-trampolined, fully returning) recursion to resolve reductions.\n     * Reducer is a pure function for handling a single reduction step.\n     * Reduce manages the setup and recursion execution.\n     */\n    function reducer(userFn, recur, reduction, collection){\n        var finished = collection.length === 0,\n            newReduction = finished ? reduction : userFn(reduction, j.first(collection));\n            \n        return finished ? reduction : recur(newReduction, j.rest(collection));\n    }\n\n    function reduce(userFn, values, initialState){\n        var appliedReducer = j.partial(reducer, userFn),\n            initialValue = j.isUndefined(initialState) ? j.first(values) : initialState,\n            remainder = j.isUndefined(initialState) ? j.rest(values) : values;\n            \n        return (!!values && values.length > 0) ? recur(appliedReducer, initialValue, remainder) : initialValue;\n    }\n\n\n    // Adapter function for reduce to allow for simplification of\n    // array construction behaviors like map and filter\n    function arrayReduceAdapter(reducerFn, userFn, valueList){\n        var appliedReducer = j.partial(reducerFn, userFn),\n            result = reduce(appliedReducer, valueList, []);\n        \n        return j.either([], result);\n    }\n\n    /*\n     * Map uses reduce to produce a new, completely reference-decoupled list of values\n     * Mapper handles a single update step for the final output array\n     */\n    function mapper(userFn, finalArray, value){\n        finalArray.push(userFn(value));\n        return finalArray;\n    }\n\n    map = j.partial(arrayReduceAdapter, mapper);\n\n    /*\n     * Filter uses reduce to produce a new, completely reference-decoupled list of values\n     * Filterer handles a single update step for the final output array\n     */\n    function filterer(userPredicate, finalArray, value){\n        return userPredicate(value) ? j.conj(value, finalArray) : finalArray;\n    }\n\n    filter = j.partial(arrayReduceAdapter, filterer);\n\n    function predicateAccumulator(predicate, total, value){\n        var sanitizedTotal = j.either(0, total, 'number');\n        console.log(total, value, predicate(value));\n        return predicate(value) ? sanitizedTotal + 1 : sanitizedTotal;\n    }\n\n    function numberOf(predicate, valueSet){\n        var accumulator = j.partial(predicateAccumulator, predicate);\n        return reduce(accumulator, j.either([], valueSet), 0);\n    }\n\n    //Performs 'and' operation on valueSet\n    function ander(a, b){\n        return a && b;\n    }\n\n    function orer(a, b){\n        return a || b;\n    }\n\n    function reduceConditions(conditionArgs, operator, initialCondition){\n        var args = j.map(Boolean, j.slice(0, conditionArgs));\n        return Boolean(reduce(operator, args, initialCondition));\n    }\n\n    function and(a, b){\n        return reduceConditions(arguments, ander, true);\n    }\n\n    function or(a, b){\n        return reduceConditions(arguments, orer, false);\n    }\n\n    function xor(a, b){\n        var equivalent = Boolean(a) === Boolean(b);\n        return or(a, b) && j.not(equivalent);\n    }\n\n    //Produces a function that returns f(g(x))\n    function compositor(f, g){\n        return function(){\n            return f(j.apply(g, j.slice(0, arguments)));\n        };\n    }\n\n    function compose(){\n        return reduce(compositor, j.slice(0, arguments), j.identity);\n    }\n\n    function pipeline(value){\n        return j.apply(compose, j.slice(1, arguments).reverse())(value);\n    }\n\n    function captureUnique(finalList, value){\n        return j.last(finalList) === value ? finalList : j.conj(value, finalList);\n    }\n    \n    function unique(valueSet){\n        return reduce(captureUnique, j.sort(j.slice(0, valueSet)), []);\n    }\n\n    function partialReverse(){\n        return j.apply(j.compose(j.reverseArgs, j.partial),\n                       j.slice(0, arguments));\n    }\n\n    function dereferencer(dataObject, token){\n        var key = j.either('', token).trim();\n        return key === '' ? dataObject : j.pick(token, dataObject);\n    }\n\n    function deref(baseData, key, defaultValue){\n        var sanitizedDefault = defaultValue === undefined ? null : defaultValue,\n            keyTokens = j.either('', key, 'string').split('.'),\n            result = reduce(dereferencer, keyTokens, j.either(null, baseData, 'object'));\n        \n        return j.either(sanitizedDefault, result);\n    }\n\n    function union(set1, set2){\n        return j.compose(j.unique, j.concat)(set1, set2);\n    }\n\n    function addToHash(finalObject, value){\n        finalObject[value] = true;\n        return finalObject;\n    }\n\n    function buildValueHash(valueList){\n        return j.either({}, reduce(addToHash, valueList, {}));\n    }\n\n    function captureIntersection(valueHash, finalList, value){\n        return valueHash[value] ? j.conj(value, finalList) : finalList;\n    }\n    \n    function intersect(set1, set2){\n        var setHash = buildValueHash(j.either([], set2));\n        return reduce(j.partial(captureIntersection, setHash), set1, []); \n    }\n\n    function captureDifference(valueHash, finalList, value){\n        return !valueHash[value] ? j.conj(value, finalList) : finalList;\n    }\n    \n    function difference(set1, set2){\n        var setHash = buildValueHash(j.either([], set2));\n        return reduce(j.partial(captureDifference, setHash), set1, []);\n    }\n\n    function symmetricDifference(set1, set2){\n        var setUnion = union(set1, set2),\n            setIntersection = intersect(set1, set2);\n\n        return difference(setUnion, setIntersection);\n    }\n\n    j.and = and;\n    j.compact = j.partial(filter, j.isTruthy);\n    j.compose = compose;\n    j.curry = curry;\n    j.deref = deref;\n    j.difference = difference;\n    j.filter = filter;\n    j.intersect = intersect;\n    j.map = map;\n    j.numberOf = numberOf;\n    j.or = or;\n    j.partialReverse = partialReverse;\n    j.pipeline = pipeline;\n    j.recur = recur;\n    j.reduce = reduce;\n    j.symmetricDifference = symmetricDifference;\n    j.union = union;\n    j.unique = unique;\n    j.xor = xor;\n\n})(jfp);\n\n\n(function(j){\n    'use strict';\n\n//This is a recursive add fn\n    function adder(recur, current, valueSet){\n        return (valueSet.length === 0) ?\n                current :\n                recur(current + j.first(valueSet), j.rest(valueSet));\n    }\n    \n    function add(a, b){\n        return j.recur(adder, 0, j.slice(0, arguments));\n    }\n    \n    //This is a recursive divide fn\n    function divider(recur, current, valueSet){\n        return (valueSet.length === 0) ?\n                current :\n                recur(current / j.first(valueSet), j.rest(valueSet));\n    }\n    \n    function divide(){\n        var args = j.slice(0, arguments),\n            first = args.length ? j.first(args) : 1;\n        return j.recur(divider, first, j.rest(args));\n    }\n    \n    //This is a recursive multiply fn\n    function multiplier(recur, current, valueSet){\n        return (valueSet.length === 0) ?\n                current :\n                recur(current * j.first(valueSet), j.rest(valueSet));\n    }\n    \n    function multiply(){\n        return j.recur(multiplier, 1, j.slice(0, arguments));\n    }\n    \n    //This is a recursive subtraction fn\n    function subtractor(recur, current, valueSet){\n        return (valueSet.length === 0) ?\n                current :\n                recur(current - j.first(valueSet), j.rest(valueSet));\n    }\n    \n    function subtract(){\n        var args = j.slice(0, arguments),\n            first = args.length ? j.first(args) : 0;\n        return j.recur(subtractor, first, j.rest(args));\n    }\n\n    //This is a recursive constructor function for ranges\n    function rangeRecurCheck(m, n, inc){\n        return inc > 0 ? (m + inc) < n : (m + inc) > n;\n    }\n\n    function rangeBuilder(recur, currentRange, m, n, inc){\n        var finalRange = rangeRecurCheck(m - inc, n, inc) ?\n                            j.conj(m, currentRange) :\n                            currentRange;\n        \n        return rangeRecurCheck(m, n, inc) ?\n                recur(finalRange, m + inc, n, inc) :\n                finalRange;\n    }\n    \n    function range(a, b, inc){\n        var start = j.isUndefined(b) ? 0 : a,\n            end = j.isUndefined(b) ? j.either(0, a) : b,\n            increment = (!inc) ? 1 : inc;\n            \n        return j.recur(rangeBuilder,\n                       [],\n                       j.either(0, start),\n                       j.either(0, end),\n                       increment);\n    }\n\n    function mod(a, b){\n        return j.isUndefined(b) ? j.either(0, a) : a%b;\n    }\n\n    function modulo(a, b){\n        var _a = j.either(0, a),\n            _b = j.either(0, b);\n\n        return (_a > 0) ? mod(_a, _b) : _b * (Math.floor(Math.abs(_a)/_b) + 1) + _a;\n    }\n\n    function truncate(value){\n        return (value > 0) ? Math.floor(value) : Math.floor(value) + 1;\n    }\n    \n    function max(a, b){\n        var maxValue = -Number.MAX_VALUE,\n            _a = j.isUndefined(a) ? maxValue : a,\n            _b = j.isUndefined(b) ? maxValue : b;\n            \n        maxValue = (_a > maxValue) ? _a : maxValue;\n        maxValue = (_b > maxValue) ? _b : maxValue;\n        \n        return maxValue;\n    }\n    \n    function min(a, b){\n        var minValue = Number.MAX_VALUE,\n            _a = j.isUndefined(a) ? minValue : a,\n            _b = j.isUndefined(b) ? minValue : b;\n        \n        minValue = (_a < minValue) ? _a : minValue;\n        minValue = (_b < minValue) ? _b : minValue;\n        \n        return minValue;\n    }\n\n    function fac(value){\n        var factorial = j.compose(j.partial(j.reduce, multiply),\n                                  j.partial(range, 1),\n                                  j.partial(add, 1));\n\n        return j.either(1, j.when(j.greater(value, 0), factorial, value));\n    }\n\n    j.add = add;\n    j.divide = divide;\n    j.fac = fac;\n    j.inc = j.partial(j.add, 1);\n    j.max = max;\n    j.min = min;\n    j.mod = mod;\n    j.modulo = modulo;\n    j.multiply = multiply;\n    j.range = range;\n    j.subtract = subtract;\n    j.truncate = truncate;\n\n})(jfp);\n\n\n(function(j){\n\n    function throwWhenNotComparable(a, b){\n        j.when(j.isUndefined(a) || j.isUndefined(b), function(){\n            throw new TypeError('Inequality comparisons require two values');\n        });\n    }\n\n    function equal(a, b){\n        var isNotUndefined = j.compose(j.not, j.isUndefined);\n        return (isNotUndefined(a) && isNotUndefined(b)) ? a === b : false;\n    }\n\n    function greater(a, b){\n        throwWhenNotComparable(a, b);\n        return a > b;\n    }\n\n    function less(a, b){\n        throwWhenNotComparable(a, b);\n        return a < b;\n    }\n\n    function isEven(value){\n        return equal(0, j.mod(value, 2));\n    }\n\n    function isPositive(value){\n        return greater(value, 0);\n    }\n\n    function isZero(value){\n        return value === 0;\n    }\n\n    function isNegative(value){\n        return j.compose(j.not, j.or)(isPositive(value), isZero(value));\n    }\n\n    function isInt(value){\n        return equal(j.truncate(value), value);\n    }\n\n    j.isEven = isEven;\n    j.isInt = isInt;\n    j.isNegative = isNegative;\n    j.isNonNegative = j.compose(j.not, isNegative);\n    j.isNonPositive = j.compose(j.not, isPositive);\n    j.isNonZero = j.compose(j.not, isZero);\n    j.isOdd = j.compose(j.not, isEven);\n    j.isPositive = isPositive;\n    j.isZero = isZero;\n\n    //Special case predicate naming is intended for these functions\n    //There is a general expectation that these not be named with 'is'\n    j.equal = equal;\n    j.geq = j.compose(j.not, less);\n    j.greater = greater;\n    j.leq = j.compose(j.not, greater);\n    j.less = less;\n\n})(jfp);\n\nvar j = jfp;\n\nif(typeof module !== 'undefined' && !!module.exports){\n    module.exports = j;\n}\n\n\n"]}