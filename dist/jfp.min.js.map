{"version":3,"file":"jfp.min.js","sources":["jfp.js"],"names":["jfp","resolveFunction","functionValue","curryAlias","args","slice","arguments","apply","curry","pickAlias","key","value","cleanKey","Boolean","pick","partial","chooseResolver","resolveToPick","charAt","resolver","j","isUndefined","undefined","not","equal","a","b","missingValues","isType","typeString","getType","isArray","Object","prototype","toString","call","isNumeric","pattern","number","numericString","match","isTruthy","typeCheckReduction","result","isPrimitive","primitiveNames","reduce","bind","isBoolean","isEmptyString","isFunction","isNull","isNumber","isObject","isString","identity","begin","valueSet","end","values","Array","shortCircuit","defaultValue","userFn","testValue","maybe","type","typeOkay","either","when","checkValue","eitherIf","predicateValue","safePredicate","eitherWhen","sanitizedFn","concat","original","extension","sanitizedExtension","i","length","push","basePartial","direction","appliedFunction","applicationArgs","reverseArgs","reverse","countArguments","execute","rpartial","toDec","parseInt","copyArray","makeValueArray","conj","dest","cons","source","first","lastIndex","last","drop","index","finalIndex","sanitizedIndex","firstArray","secondArray","dropLast","nth","rest","take","count","naturalComparator","comparison","sort","optionValue","comparator","finalSet","each","userArray","sanitizedArray","dropFirst","init","valueMap","pickResult","merge","defaultObj","mergeData","finalObj","argumentCount","appliedFn","recursor","recurFn","recursorFn","localRecursor","verifyRecurValue","recurValue","recur","recursingFn","valueReducer","baseObj","finalList","keyList","toValues","baseIsValid","keys","reducer","reduction","collection","initialState","appliedReducer","hasInitialState","initialValue","remainder","compositor","f","g","$f","$g","compositeFn","compose","pipeline","partialReverse","clone","originalValue","depth","depthOkay","geq","copyOkay","copy","container","newDepth","err","RangeError","mapper","finalArray","map","mapperFn","filterer","userPredicate","filter","predicate","filterFn","compact","valueList","predicateAccumulator","total","sanitizedTotal","numberOf","accumulator","captureUnique","unique","union","set1","set2","addToHash","finalObject","buildValueHash","captureIntersection","valueHash","intersect","setHash","captureDifference","difference","symmetricDifference","setUnion","setIntersection","everyReducer","every","finder","done","find","someRecur","some","contains","partitioner","partitions","partition","list","sanitizedPredicate","multiPartitioner","partitionPredicate","computedPartitions","multiPartition","predicateArgs","sanitizedArgs","sanitizedList","ander","orer","reduceConditions","conditionArgs","operator","initialCondition","and","or","xor","equivalent","dereferencer","dataObject","token","trim","internalDeref","baseData","sanitizedDefault","keyTokens","split","deref","sanitizedKey","sanitizedData","plucker","pluckKeys","sanitizedObject","pluck","adder","current","add","divider","divide","multiplier","multiply","subtractor","subtract","rangeRecurCheck","m","n","inc","rangeBuilder","currentRange","finalRange","range","start","increment","mod","modulo","_a","_b","Math","floor","abs","truncate","max","maxValue","Number","MAX_VALUE","min","minValue","fac","factorial","greater","throwWhenNotComparable","TypeError","less","isInt","isNegative","isPositive","isZero","isEven","isNonNegative","isNonPositive","isNonZero","isOdd","leq","module","exports"],"mappings":"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","sourcesContent":["var jfp = (function(){\n    'use strict';\n    \n    function resolveFunction(functionValue){\n        return typeof functionValue === 'string' ? jfp[functionValue] : functionValue;\n    }\n    \n    function curryAlias(){\n        var args = jfp.slice(0, arguments);\n\n        args[0] = resolveFunction(args[0]);\n        \n        return jfp.apply(jfp.curry, args);\n    }\n    \n    function pickAlias(key, value){\n        var cleanKey = key.slice(1);\n        \n        return Boolean(value) ? jfp.pick(cleanKey, value) : jfp.partial(jfp.pick, cleanKey);\n    }\n    \n    function chooseResolver(value){\n        var resolveToPick = typeof value === 'string' && value.charAt(0) === ':';\n        \n        return resolveToPick ? pickAlias : curryAlias;\n    }\n    \n    return function(){\n        var args = jfp.slice(0, arguments),\n            resolver = chooseResolver(args[0]);\n        \n        return jfp.apply(resolver, args);\n    };\n    \n})();\n\n(function(j){\n    'use strict';\n\n    function isUndefined(value){\n        return value === undefined;\n    }\n    \n    function not(value){\n        return !Boolean(value);\n    }\n    \n    function equal (a, b) {\n        var missingValues = isUndefined(a) || isUndefined(b);\n        return not(missingValues) && a === b;\n    }\n\n    function isType (typeString, value) {\n        return j.equal(j.getType(value), typeString);\n    }\n    \n    function isArray(value){\n        return isType('object', value) && Object.prototype.toString.call(value) === '[object Array]';\n    }\n    \n    function isNumeric(value){\n        var pattern = /^(0x)?[0-9]+((\\.[0-9]+)|(e\\-?[0-9]+))?$/,\n            number = isType('number', value),\n            numericString = isType('string', value) && Boolean(value.match(pattern));\n            \n        return number || numericString;\n    }\n    \n    function isTruthy(value){\n        return Boolean(value);\n    }\n    \n    function typeCheckReduction (value, result, typeString){\n        return result || isType(typeString, value);\n    }\n    \n    function isPrimitive (value) {\n        var primitiveNames = ['number',\n                              'string',\n                              'boolean',\n                              'undefined'];\n\n        return primitiveNames.reduce(typeCheckReduction.bind(null, value), equal(null, value));\n    }\n\n    j.equal = equal;\n    j.isArray = isArray;\n    j.isBoolean = isType.bind(null, 'boolean');\n    j.isEmptyString = equal.bind(null, '');\n    j.isFunction = isType.bind(null, 'function');\n    j.isNull = equal.bind(null, null);\n    j.isNumber = isType.bind(null, 'number');\n    j.isNumeric = isNumeric;\n    j.isObject = isType.bind(null, 'object');\n    j.isPrimitive = isPrimitive;\n    j.isString = isType.bind(null, 'string');\n    j.isType = isType;\n    j.isTruthy = isTruthy;\n    j.isUndefined = isType.bind(null, 'undefined');\n    j.not = not;\n\n})(jfp);\n\n\n(function(j){\n    'use strict';\n\n    function identity(value){\n        return value;\n    }\n\n    function slice(begin, valueSet, end){\n        var values = j.not(j.isTruthy(valueSet)) ? [] : valueSet;\n\n        return j.not(j.isTruthy(end)) ?\n                    Array.prototype.slice.call(values, begin) :\n                    Array.prototype.slice.call(values, begin, end);\n    }\n\n    function shortCircuit(defaultValue, userFn, testValue){\n        return (j.isTruthy(testValue) || testValue === 0) ?\n            userFn(testValue) :\n            defaultValue;\n    }\n\n    function maybe(value){\n        var type = arguments[1],\n            typeOkay = typeof value === type;\n\n        return typeOkay || (!type && !!value) ? value : null;\n    }\n\n    function either(defaultValue, testValue){\n        var type = arguments[2];\n        return maybe(testValue, type) === null ? defaultValue : testValue;\n    }\n\n    function apply(userFn, args){\n        return userFn.apply(null, args);\n    }\n\n    function when(checkValue, userFn){\n        var args = slice(2, arguments);\n        return j.isTruthy(checkValue) ? apply(userFn, args) : null;\n    }\n\n    function eitherIf(defaultValue, testValue, predicateValue){\n        var safePredicate = j.isUndefined(predicateValue) ? true : predicateValue;\n\n        return j.either(defaultValue, j.when(safePredicate, j.partial(j.identity, testValue)));\n    }\n\n    function eitherWhen(defaultValue, predicateValue, userFn){\n        var sanitizedFn = eitherIf(j.identity, userFn, j.isFunction(userFn));\n\n        return j.either(defaultValue, j.when(predicateValue, sanitizedFn));\n    }\n\n    function concat(original, extension){\n        var result = slice(0, either([], original)),\n            sanitizedExtension = either([], extension),\n            i;\n\n        //This is the most performant way to handle concatenation. Trust me.\n        for(i = 0; i < sanitizedExtension.length; i++){\n            result.push(sanitizedExtension[i]);\n        }\n\n        return result;\n    }\n\n    function basePartial(direction, userFn){\n        var args = slice(2, arguments);\n\n        return function appliedFunction(){\n            var applicationArgs = (direction === 'left') ?\n                                    concat(args, slice(0, arguments)) :\n                                    concat(slice(0, arguments), args);\n\n            return apply(userFn, applicationArgs);\n        };\n    }\n\n    function reverseArgs(userFn){\n        return function(){\n            var args = j.slice(0, arguments).reverse();\n            return j.apply(userFn, args);\n        };\n    }\n\n    function countArguments(userFn){\n        return either(function(){}, userFn).length;\n    }\n\n    function execute(userFn){\n        return j.apply(userFn, j.slice(1, arguments));\n    }\n    \n    function getType (value) {\n        return typeof value;\n    }\n\n    j.apply = apply;\n    j.concat = concat;\n    j.countArguments = countArguments;\n    j.either = either;\n    j.eitherIf = eitherIf;\n    j.eitherWhen = eitherWhen;\n    j.execute = execute;\n    j.getType = getType;\n    j.identity = identity;\n    j.maybe = maybe;\n    j.partial = basePartial('left', basePartial, 'left');\n    j.reverseArgs = reverseArgs;\n    j.rpartial = basePartial('left', basePartial, 'right');\n    j.shortCircuit = shortCircuit;\n    j.slice = slice;\n    j.when = when;\n\n})(jfp);\n\n\n(function(j){\n    'use strict';\n\n    function toDec(value){\n        return (j.isNumeric(value)) ? parseInt(value, 10) : null;\n    }\n\n    j.toDec = toDec;\n\n})(jfp);\n\n(function(j){\n    'use strict';\n\n    function copyArray(valueSet){\n        return j.slice(0, valueSet);\n    }\n\n    function makeValueArray(value){\n        return j.not(j.isUndefined(value)) ? [value] : [];\n    }\n\n    function conj(value, dest){\n        return j.concat(copyArray(dest), makeValueArray(value));\n    }\n\n    function cons(value, source){\n        return j.concat(makeValueArray(value), source);\n    }\n\n    function first(values){\n        return j.isArray(values) ? j.either(null, values[0]) : null;\n    }\n\n    function lastIndex(values){\n        return j.isArray(values) ? values.length - 1 : null;\n    }\n\n    function last(values){\n        return j.isArray(values) ? values[lastIndex(values)] : null;\n    }\n\n    function drop(index, valueSet){\n        var finalIndex = lastIndex(valueSet),\n\n            sanitizedIndex = (index === 0 || index === finalIndex) ?\n                index : j.either(1, index) - 1,\n\n            firstArray = (sanitizedIndex === 0) ?\n                [] : j.slice(0, valueSet, sanitizedIndex),\n\n            secondArray = (sanitizedIndex === finalIndex)?\n                [] : j.slice(sanitizedIndex + 1, valueSet);\n\n        return j.concat(firstArray, secondArray);\n    }\n\n    function dropLast(valueSet){\n        return drop(lastIndex(valueSet), valueSet);\n    }\n\n    function nth(index, valueSet){\n        return j.either(null, j.either([], valueSet)[index]);\n    }\n\n    function rest(values){\n        return j.slice(1, values);\n    }\n\n    function take(count, values){\n        return j.isArray(values) ? j.slice(0, values, count) : null;\n    }\n\n    function naturalComparator(a, b){\n        var comparison = a < b ? -1 : 1;\n        return a === b ? 0 : comparison;\n    }\n\n    function sort(optionValue, valueSet){\n        var comparator = j.isFunction(optionValue) ? optionValue : naturalComparator,\n            finalSet = j.isArray(optionValue) ? j.slice(0, optionValue) : j.slice(0, valueSet);\n\n        return finalSet.sort(comparator);\n    }\n\n    function each(userFn, userArray){\n        var sanitizedArray = j.either([], userArray),\n            sanitizedFn = j.either(j.identity, userFn),\n            i;\n\n        for(i = 0; i < sanitizedArray.length; i++){\n            if(sanitizedFn(sanitizedArray[i], i) === false){\n                break;\n            }\n        }\n\n        return sanitizedArray;\n    }\n\n    j.conj = conj;\n    j.cons = cons;\n    j.copyArray = copyArray;\n    j.drop = drop;\n    j.dropFirst = j.partial(drop, 0);\n    j.dropLast = dropLast;\n    j.each = each;\n    j.first = first;\n    j.init = j.dropLast;\n    j.last = last;\n    j.lastIndex = lastIndex;\n    j.nth = nth;\n    j.rest = rest;\n    j.sort = sort;\n    j.take = take;\n\n})(jfp);\n\n\n(function(j){\n    'use strict';\n\n    function pick(key, valueMap){\n        var pickResult = j.either({}, valueMap)[key];\n        return j.isUndefined(pickResult) ? null : pickResult;\n    }\n\n    function merge(defaultObj, mergeData){\n        var finalObj = {},\n            key;\n\n        for(key in j.either({}, defaultObj)){\n            finalObj[key] = defaultObj[key];\n        }\n\n        for(key in j.either({}, mergeData)){\n            finalObj[key] = mergeData[key];\n        }\n\n        return j.eitherIf(null, finalObj, j.isTruthy(defaultObj));\n    }\n\n    j.merge = merge;\n    j.pick = pick;\n\n})(jfp);\n\n\n(function(j){\n    'use strict';\n\n    //This is complicated and I don't expect people to grok it on first read.\n    function curry(userFn){\n        var args = j.slice(1, arguments),\n            argumentCount = j.countArguments(userFn),\n            appliedFn = (args.length < argumentCount) ? j.apply(j.partial, j.concat([curry, userFn], args)) : null,\n            result = (!!userFn && args.length >= argumentCount) ? j.apply(userFn, args) : null;\n\n        return j.either(appliedFn, result);\n    }\n\n    //zOMG! TAIL OPTIMIZED RECURSION\n    function recursor(recurFn){\n        var args = j.slice(1, arguments);\n\n        //This is to make the returned function distinct and identifiable.\n        return function recursorFn(localRecursor){\n            return j.apply(recurFn, j.concat([localRecursor], args));\n        };\n    }\n\n    function verifyRecurValue(recurValue){\n        return typeof recurValue === 'function' &&\n            recurValue.toString().match('recursorFn');\n    }\n\n    //Tail optimization with managed recursion is really complicated.\n    //Please don't muck with this unless you TRULY understand what is happening.\n    function recur(userFn){\n        var recursingFn = j.either(j.identity, userFn, 'function'),\n            localRecursor = j.partial(recursor, recursingFn),\n            recurValue = j.apply(localRecursor, j.slice(1, arguments));\n\n        while(verifyRecurValue(recurValue = recurValue(localRecursor)) && recursingFn !== j.identity);\n\n        return recurValue;\n    }\n\n    /*\n     * toValues converts an object to an array of values\n     * This is necessary for reduce to convert objects into\n     * processible arrays in an upcoming version.\n     */\n    function valueReducer (recur, baseObj, finalList, keyList) {\n        finalList.push(baseObj[j.first(keyList)]);\n        return keyList.length === 1 ? finalList : recur(baseObj, finalList, j.rest(keyList));\n    }\n    \n    function toValues (baseObj) {\n        var baseIsValid = typeof baseObj === 'object';\n        return !baseIsValid ? null : j.recur(valueReducer, baseObj, [], Object.keys(baseObj));\n    }\n    \n\t/*\n     * Reduce uses tail-optimized (while-trampolined, fully returning) recursion to resolve reductions.\n     * Reducer is a pure function for handling a single reduction step.\n     * Reduce manages the setup and recursion execution.\n     */\n    function reducer(userFn, recur, reduction, collection){\n        return collection.length === 0 ?\n                    reduction :\n                    recur(userFn(reduction, j.first(collection)),\n                          j.rest(collection));\n    }\n\n    function reduce(userFn, values, initialState){\n        var appliedReducer = j.partial(reducer, userFn),\n            hasInitialState = typeof initialState !== 'undefined',\n            \n            initialValue = !hasInitialState ? j.first(values) : initialState,\n            remainder = !hasInitialState ? j.rest(values) : values;\n\n        return (!!values && values.length > 0) ? j.recur(appliedReducer, initialValue, remainder) : initialValue;\n    }\n\n    //Produces a function that returns f(g(x))\n    function compositor(f, g){\n        var $f = typeof f !== 'function' ? j.identity : f,\n            $g = typeof g !== 'function' ? j.identity : g;\n            \n        function compositeFn () {\n            return $f(j.apply($g, j.slice(0, arguments)));\n        }\n        \n        return compositeFn;\n    }\n\n    function compose(){\n        return reduce(compositor, j.slice(0, arguments), j.identity);\n    }\n\n    function pipeline(value){\n        return j.apply(compose, j.slice(1, arguments).reverse())(value);\n    }\n\n    function partialReverse(){\n        return j.apply(j.compose(j.reverseArgs, j.partial),\n                       j.slice(0, arguments));\n    }\n\n    function clone (originalValue, depth) {\n        var depthOkay = j.isUndefined(depth) || j.geq(depth, 0),\n            copyOkay = j.isType('object', originalValue);\n        \n        function copy () {\n            var keys = Object.keys(originalValue),\n                container = j.isArray(originalValue) ? [] : {};\n            \n            j.each(function (key) {\n                var newDepth = j.isNumber(depth) ? depth - 1 : undefined;\n                \n                try {\n                    container[key] = clone(originalValue[key], newDepth);\n                } catch (err) {\n                    throw new RangeError('Object contains circular reference or is too deep to clone.');\n                }\n                \n            }, keys);\n            \n            return container;\n        }\n        \n        return copyOkay && depthOkay ? copy() : originalValue;\n    }\n\n    j.clone = clone;\n    j.compose = compose;\n    j.curry = curry;\n    j.partialReverse = partialReverse;\n    j.pipeline = pipeline;\n    j.recur = recur;\n    j.reduce = reduce;\n    j.toValues = toValues;\n\n})(jfp);\n\n\n(function(j){\n\t\n    /*\n     * Map uses reduce to produce a new, completely reference-decoupled list of values\n     * Mapper handles a single update step for the final output array\n     */\n    function mapper(userFn, finalArray, value){\n        finalArray.push(userFn(value));\n        return finalArray;\n    }\n\n    function map (userFn, values) {\n        var mapperFn = j.partial(mapper, userFn);\n        return j.reduce(mapperFn, values, []);\n    }\n    \n    /*\n     * Filter uses reduce to produce a new, completely reference-decoupled list of values\n     * Filterer handles a single update step for the final output array\n     */\n    function filterer(userPredicate, finalArray, value){\n        return userPredicate(value) ? j.conj(value, finalArray) : finalArray;\n    }\n\n    function filter (predicate, values) {\n        var filterFn = j.partial(filterer, predicate);\n        return j.reduce(filterFn, values, []);\n    }\n    \n    function compact(valueList){\n        return filter(j.isTruthy, valueList);\n    }\n\n    function predicateAccumulator(predicate, total, value){\n        var sanitizedTotal = j.either(0, total, 'number');\n        return predicate(value) ? sanitizedTotal + 1 : sanitizedTotal;\n    }\n\n    function numberOf(predicate, valueSet){\n        var accumulator = j.partial(predicateAccumulator, predicate);\n        return j.reduce(accumulator, j.either([], valueSet), 0);\n    }\n\n    function captureUnique(finalList, value){\n        return j.last(finalList) === value ? finalList : j.conj(value, finalList);\n    }\n    \n    function unique(valueSet){\n        return j.reduce(captureUnique, j.sort(j.slice(0, valueSet)), []);\n    }\n\n    function union(set1, set2){\n        return j.compose(j.unique, j.concat)(set1, set2);\n    }\n\n    function addToHash(finalObject, value){\n        finalObject[value] = true;\n        return finalObject;\n    }\n\n    function buildValueHash(valueList){\n        return j.either({}, j.reduce(addToHash, valueList, {}));\n    }\n\n    function captureIntersection(valueHash, finalList, value){\n        return valueHash[value] ? j.conj(value, finalList) : finalList;\n    }\n    \n    function intersect(set1, set2){\n        var setHash = buildValueHash(j.either([], set2));\n        return j.reduce(j.partial(captureIntersection, setHash), set1, []); \n    }\n\n    function captureDifference(valueHash, finalList, value){\n        return !valueHash[value] ? j.conj(value, finalList) : finalList;\n    }\n    \n    function difference(set1, set2){\n        var setHash = buildValueHash(j.either([], set2));\n        return j.reduce(j.partial(captureDifference, setHash), set1, []);\n    }\n\n    function symmetricDifference(set1, set2){\n        var setUnion = union(set1, set2),\n            setIntersection = intersect(set1, set2);\n\n        return difference(setUnion, setIntersection);\n    }\n\n    function everyReducer (predicate, result, valueList){\n        return result && predicate(valueList);\n    }\n\n    function every (predicate, valueList){\n        var reducer = j.partial(everyReducer, predicate);\n        return Boolean(j.reduce(reducer, valueList, true));\n    }\n\n    function finder (recur, predicate, valueList) {\n        var done = !Boolean(valueList) || valueList.length === 0,\n            result = done ? null : j.first(valueList);\n        \n        return done || predicate(result) ? result : recur(predicate, j.rest(valueList));\n    }\n\n    function find (predicate, valueList){\n        return j.recur(finder, predicate, valueList);\n    }\n\n    function someRecur(recur, predicate, valueList){\n        var done = valueList.length === 0,\n            result = done ? false : predicate(j.first(valueList));\n            \n        return result || done ? result : recur(predicate, j.rest(valueList));\n    }\n\n    function some(predicate, valueList){\n        return Boolean(j.recur(someRecur, predicate, valueList));\n    }\n    \n    function contains(value, valueList){\n        return some(j.partial(j.equal, value), valueList);\n    }\n\n    function partitioner(predicate, partitions, value){\n        var index = predicate(value) ? 0 : 1;\n\n        partitions[index].push(value);\n\n        return partitions;\n    }\n\n    function partition(predicate, list){\n        var sanitizedPredicate = j.either(j.identity, predicate, 'function');\n        \n        return j.reduce(j.partial(partitioner, sanitizedPredicate),\n                        j.either([], list),\n                        [[], []]);\n    }\n\n    function multiPartitioner(predicate, partitions, value){\n        var partitionPredicate = j.rpartial(predicate, value),\n            computedPartitions = j.dropLast(partitions);\n        \n        return j.concat(computedPartitions, partition(partitionPredicate, j.last(partitions)));\n    }\n    \n    function multiPartition(predicate, predicateArgs, list){\n        var sanitizedArgs = j.either([], predicateArgs),\n            sanitizedPredicate = j.either(j.identity, predicate),\n            sanitizedList = j.either([], list);\n            \n        return !Boolean(list) ?\n                [[], []] :\n                j.reduce(j.partial(multiPartitioner, sanitizedPredicate),\n                         sanitizedArgs,\n                         [sanitizedList]);\n    }\n\n    j.contains = contains;\n    j.compact = compact;\n    j.difference = difference;\n    j.every = every;\n\tj.filter = filter;\n    j.find = find;\n    j.intersect = intersect;\n\tj.map = map;\n\tj.multiPartition = multiPartition;\n\tj.numberOf = numberOf;\n    j.partition = partition;\n    j.some = some;\n    j.symmetricDifference = symmetricDifference;\n    j.union = union;\n    j.unique = unique;\n\n})(jfp);\n\n(function (j) {\n\t'use strict';\n\t\n\t//Performs 'and' operation on valueSet\n    function ander(a, b){\n        return a && b;\n    }\n\n    function orer(a, b){\n        return a || b;\n    }\n\n    function reduceConditions(conditionArgs, operator, initialCondition){\n        var args = j.map(Boolean, j.slice(0, conditionArgs));\n        return Boolean(j.reduce(operator, args, initialCondition));\n    }\n\n    function and(a, b){\n        return reduceConditions(arguments, ander, true);\n    }\n\n    function or(a, b){\n        return reduceConditions(arguments, orer, false);\n    }\n\n    function xor(a, b){\n        var equivalent = Boolean(a) === Boolean(b);\n        return or(a, b) && j.not(equivalent);\n    }\n\n\tj.and = and;\n\tj.or = or;\n\tj.xor = xor;\n\n})(jfp);\n\n(function (j) {\n\t'use strict';\n\t\n\tfunction dereferencer(dataObject, token){\n        var key = j.either('', token).trim();\n        return key === '' ? dataObject : j.pick(token, dataObject);\n    }\n\n    function internalDeref(key, baseData, defaultValue){\n        var sanitizedDefault = defaultValue === undefined ? null : defaultValue,\n            keyTokens = key.split('.'),\n            result = j.reduce(dereferencer, keyTokens, baseData);\n        \n        return j.either(sanitizedDefault, result);\n    }\n    \n    function deref(key, baseData, defaultValue){\n        // Satisifes backwards-compatibility case where key an data are reversed\n        var sanitizedKey = typeof key === 'string' ? key : baseData,\n            sanitizedData = typeof baseData === 'object' ? baseData : key;\n        \n        // Fully sanitize data before executing the dereference function\n        sanitizedKey = j.either('', sanitizedKey, 'string');\n        sanitizedData = j.either(null, sanitizedData, 'object');\n        \n        return internalDeref(j.either('', sanitizedKey), sanitizedData, defaultValue);\n    }\n    \n    function plucker (baseObj, finalObj, key){\n        finalObj[key] = baseObj[key];\n        return finalObj;\n    }\n    \n    function pluckKeys (keys, baseObj){\n        var sanitizedObject = j.either({}, baseObj, 'object');\n        return j.reduce(j.partial(plucker, sanitizedObject), keys, {});\n    }\n    \n    function pluck (key, baseObj) {\n        return pluckKeys([key], baseObj);\n    }\n\n\tj.deref = deref;\n    j.pluck = pluck;\n    j.pluckKeys = pluckKeys;\n\n})(jfp);\n\n(function(j){\n    'use strict';\n\n//This is a recursive add fn\n    function adder(recur, current, valueSet){\n        return (valueSet.length === 0) ?\n                current :\n                recur(current + j.first(valueSet), j.rest(valueSet));\n    }\n    \n    function add(a, b){\n        return j.recur(adder, 0, j.slice(0, arguments));\n    }\n    \n    //This is a recursive divide fn\n    function divider(recur, current, valueSet){\n        return (valueSet.length === 0) ?\n                current :\n                recur(current / j.first(valueSet), j.rest(valueSet));\n    }\n    \n    function divide(){\n        var args = j.slice(0, arguments),\n            first = args.length ? j.first(args) : 1;\n        return j.recur(divider, first, j.rest(args));\n    }\n    \n    //This is a recursive multiply fn\n    function multiplier(recur, current, valueSet){\n        return (valueSet.length === 0) ?\n                current :\n                recur(current * j.first(valueSet), j.rest(valueSet));\n    }\n    \n    function multiply(){\n        return j.recur(multiplier, 1, j.slice(0, arguments));\n    }\n    \n    //This is a recursive subtraction fn\n    function subtractor(recur, current, valueSet){\n        return (valueSet.length === 0) ?\n                current :\n                recur(current - j.first(valueSet), j.rest(valueSet));\n    }\n    \n    function subtract(){\n        var args = j.slice(0, arguments),\n            first = args.length ? j.first(args) : 0;\n        return j.recur(subtractor, first, j.rest(args));\n    }\n\n    //This is a recursive constructor function for ranges\n    function rangeRecurCheck(m, n, inc){\n        return inc > 0 ? (m + inc) < n : (m + inc) > n;\n    }\n\n    function rangeBuilder(recur, currentRange, m, n, inc){\n        var finalRange = rangeRecurCheck(m - inc, n, inc) ?\n                            j.conj(m, currentRange) :\n                            currentRange;\n        \n        return rangeRecurCheck(m, n, inc) ?\n                recur(finalRange, m + inc, n, inc) :\n                finalRange;\n    }\n    \n    function range(a, b, inc){\n        var start = j.isUndefined(b) ? 0 : a,\n            end = j.isUndefined(b) ? j.either(0, a) : b,\n            increment = (!inc) ? 1 : inc;\n            \n        return j.recur(rangeBuilder,\n                       [],\n                       j.either(0, start),\n                       j.either(0, end),\n                       increment);\n    }\n\n    function mod(a, b){\n        return j.isUndefined(b) ? j.either(0, a) : a%b;\n    }\n\n    function modulo(a, b){\n        var _a = j.either(0, a),\n            _b = j.either(0, b);\n\n        return (_a > 0) ? mod(_a, _b) : _b * (Math.floor(Math.abs(_a)/_b) + 1) + _a;\n    }\n\n    function truncate(value){\n        return (value > 0) ? Math.floor(value) : Math.floor(value) + 1;\n    }\n    \n    function max(a, b){\n        var maxValue = -Number.MAX_VALUE,\n            _a = j.isUndefined(a) ? maxValue : a,\n            _b = j.isUndefined(b) ? maxValue : b;\n            \n        maxValue = (_a > maxValue) ? _a : maxValue;\n        maxValue = (_b > maxValue) ? _b : maxValue;\n        \n        return maxValue;\n    }\n    \n    function min(a, b){\n        var minValue = Number.MAX_VALUE,\n            _a = j.isUndefined(a) ? minValue : a,\n            _b = j.isUndefined(b) ? minValue : b;\n        \n        minValue = (_a < minValue) ? _a : minValue;\n        minValue = (_b < minValue) ? _b : minValue;\n        \n        return minValue;\n    }\n\n    function fac(value){\n        var factorial = j.compose(j.partial(j.reduce, multiply),\n                                  j.partial(range, 1),\n                                  j.partial(add, 1));\n\n        return j.either(1, j.when(j.greater(value, 0), factorial, value));\n    }\n\n    j.add = add;\n    j.divide = divide;\n    j.fac = fac;\n    j.inc = j.partial(j.add, 1);\n    j.max = max;\n    j.min = min;\n    j.mod = mod;\n    j.modulo = modulo;\n    j.multiply = multiply;\n    j.range = range;\n    j.subtract = subtract;\n    j.truncate = truncate;\n\n})(jfp);\n\n\n(function(j){\n\n    function throwWhenNotComparable(a, b){\n        j.when(j.isUndefined(a) || j.isUndefined(b), function(){\n            throw new TypeError('Inequality comparisons require two values');\n        });\n    }\n\n    function greater(a, b){\n        throwWhenNotComparable(a, b);\n        return a > b;\n    }\n\n    function less(a, b){\n        throwWhenNotComparable(a, b);\n        return a < b;\n    }\n\n    function isInt(value){\n        return j.equal(j.truncate(value), value);\n    }\n\n    var isNegative = j.partial(greater, 0),\n        isPositive = j.partial(less, 0),\n        isZero = j.partial(j.equal, 0),\n        isEven = j.compose(isZero, j.rpartial(j.mod, 2));\n\n    j.isEven = isEven;\n    j.isInt = isInt;\n    j.isNegative = isNegative;\n    j.isNonNegative = j.compose(j.not, isNegative);\n    j.isNonPositive = j.compose(j.not, isPositive);\n    j.isNonZero = j.compose(j.not, isZero);\n    j.isOdd = j.compose(j.not, isEven);\n    j.isPositive = isPositive;\n    j.isZero = isZero;\n\n    //Special case predicate naming is intended for these functions\n    //There is a general expectation that these not be named with 'is'\n    j.geq = j.compose(j.not, less);\n    j.greater = greater;\n    j.leq = j.compose(j.not, greater);\n    j.less = less;\n\n})(jfp);\n\nvar j = jfp;\n\nif(typeof module !== 'undefined' && !!module.exports){\n    module.exports = j;\n}\n\n\n"]}