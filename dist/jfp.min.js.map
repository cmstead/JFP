{"version":3,"file":"jfp.min.js","sources":["jfp.js"],"names":["jfp","resolveFunction","functionValue","args","slice","arguments","apply","curry","j","isBoolean","value","isFunction","testFn","isObject","isArray","Object","prototype","toString","call","isString","isEmptyString","isNull","isNumber","isNumeric","pattern","match","isTruthy","isUndefined","undefined","not","identity","begin","valueSet","end","values","Array","shortCircuit","defaultValue","userFn","testValue","maybe","type","typeOkay","either","when","checkValue","eitherIf","predicateValue","safePredicate","partial","eitherWhen","sanitizedFn","concat","original","extension","result","sanitizedExtension","i","length","push","basePartial","direction","appliedFunction","applicationArgs","reverseArgs","reverse","captureArguments","replace","split","countArguments","params","execute","rpartial","toValues","valueMap","finalArray","key","hasOwnProperty","conj","toDec","parseInt","copyArray","makeValueArray","dest","cons","source","each","userArray","sanitizedArray","filter","predicate","filterFn","find","finalValue","findFn","first","lastIndex","last","drop","index","finalIndex","sanitizedIndex","firstArray","secondArray","dropLast","map","mapFn","nth","rest","take","count","some","satisfied","someFn","contains","equal","every","everyFn","numberOf","accumulator","accumulate","naturalComparator","a","b","comparison","sort","optionValue","comparator","finalSet","union","set1","set2","compose","unique","buildValueHash","finalHash","intersect","seta","setbHash","difference","symmetricDifference","setUnion","setIntersection","dropFirst","init","pick","pickResult","pluckKeys","keys","finalOutput","sanitizedKeys","sanitizedValueMap","captureValue","pluck","merge","defaultObj","mergeData","finalObj","argumentCount","appliedFn","recursor","recurFn","recursorFn","localRecursor","verifyRecurValue","recurValue","recur","recursingFn","reduce","initialState","initialValue","remainder","reducer","reduction","collection","ander","current","and","orer","or","xor","compositor","f","g","pipeline","finalValues","operator","partialReverse","partialAndReverse","keyDeref","baseObj","deref","baseData","keyTokens","safeData","outputData","compact","adder","add","divider","divide","multiplier","multiply","subtractor","subtract","rangeRecurCheck","m","n","inc","rangeBuilder","currentRange","finalRange","range","start","increment","mod","modulo","_a","_b","Math","floor","abs","truncate","max","maxValue","Number","MAX_VALUE","min","minValue","fac","factorial","greater","throwWhenNotComparable","TypeError","isNotUndefined","less","isEven","isPositive","isZero","isNegative","isInt","isNonNegative","isNonPositive","isNonZero","isOdd","geq","leq","module","exports"],"mappings":"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","sourcesContent":["var jfp = (function(){\r\n    'use strict';\r\n    \r\n    function resolveFunction(functionValue){\r\n        return typeof functionValue === 'string' ? jfp[functionValue] : functionValue;\r\n    }\r\n    \r\n    return function(){\r\n        var args = jfp.slice(0, arguments);\r\n        \r\n        args[0] = resolveFunction(args[0]);\r\n        \r\n        return jfp.apply(jfp.curry, args);\r\n    };\r\n    \r\n})();\r\n\r\n(function(j){\r\n    'use strict';\r\n    \r\n    function isBoolean(value){\r\n        return typeof value === 'boolean';\r\n    }\r\n\r\n    function isFunction(testFn){\r\n        return typeof testFn === 'function';\r\n    }\r\n    \r\n    function isObject(value){\r\n        return (typeof value == 'object');\r\n    }\r\n    \r\n    function isArray(value){\r\n        return (isObject(value) && Object.prototype.toString.call(value) === '[object Array]');\r\n    }\r\n    \r\n    function isString(value){\r\n        return typeof value === 'string';\r\n    }\r\n\r\n    function isEmptyString(value){\r\n        return isString(value) && value === '';\r\n    }\r\n    \r\n    function isNull(value){\r\n        return value === null;\r\n    }\r\n    \r\n    function isNumber(value){\r\n        return typeof value === 'number';\r\n    }\r\n    \r\n    function isNumeric(value){\r\n        var pattern = /^(0x)?[0-9]+((\\.[0-9]+)|(e\\-?[0-9]+))?$/;\r\n        return isNumber(value) || (isString(value) && !!value.match(pattern));\r\n    }\r\n    \r\n    function isTruthy(value){\r\n        return !!value;\r\n    }\r\n    \r\n    function isUndefined(value){\r\n        return value === undefined;\r\n    }\r\n\r\n    function not(value){\r\n        return !value;\r\n    }\r\n\r\n    j.isArray = isArray;\r\n    j.isBoolean = isBoolean;\r\n    j.isEmptyString = isEmptyString;\r\n    j.isFunction = isFunction;\r\n    j.isNull = isNull;\r\n    j.isNumber = isNumber;\r\n    j.isNumeric = isNumeric;\r\n    j.isObject = isObject;\r\n    j.isString = isString;\r\n    j.isTruthy = isTruthy;\r\n    j.isUndefined = isUndefined;\r\n    j.not = not;\r\n\r\n})(jfp);\r\n\r\n\r\n(function(j){\r\n    'use strict';\r\n\r\n    function identity(value){\r\n        return value;\r\n    }\r\n\r\n    function slice(begin, valueSet, end){\r\n        var values = j.not(j.isTruthy(valueSet)) ? [] : valueSet;\r\n\r\n        return j.not(j.isTruthy(end)) ?\r\n                    Array.prototype.slice.call(values, begin) :\r\n                    Array.prototype.slice.call(values, begin, end);\r\n    }\r\n\r\n    function shortCircuit(defaultValue, userFn, testValue){\r\n        return (j.isTruthy(testValue) || testValue === 0) ?\r\n            userFn(testValue) :\r\n            defaultValue;\r\n    }\r\n\r\n    function maybe(value){\r\n        var type = arguments[1],\r\n            typeOkay = typeof value === type;\r\n\r\n        return typeOkay || (!type && !!value) ? value : null;\r\n    }\r\n\r\n    function either(defaultValue, testValue){\r\n        var type = arguments[2];\r\n        return maybe(testValue, type) === null ? defaultValue : testValue;\r\n    }\r\n\r\n    function apply(userFn, args){\r\n        return userFn.apply(null, args);\r\n    }\r\n\r\n    function when(checkValue, userFn){\r\n        var args = slice(2, arguments);\r\n        return j.isTruthy(checkValue) ? apply(userFn, args) : null;\r\n    }\r\n\r\n    function eitherIf(defaultValue, testValue, predicateValue){\r\n        var safePredicate = j.isUndefined(predicateValue) ? true : predicateValue;\r\n\r\n        return j.either(defaultValue, j.when(safePredicate, j.partial(j.identity, testValue)));\r\n    }\r\n\r\n    function eitherWhen(defaultValue, predicateValue, userFn){\r\n        var sanitizedFn = eitherIf(j.identity, userFn, j.isFunction(userFn));\r\n\r\n        return j.either(defaultValue, j.when(predicateValue, sanitizedFn));\r\n    }\r\n\r\n    function concat(original, extension){\r\n        var result = slice(0, either([], original)),\r\n            sanitizedExtension = either([], extension),\r\n            i;\r\n\r\n        //This is the most performant way to handle concatenation. Trust me.\r\n        for(i = 0; i < sanitizedExtension.length; i++){\r\n            result.push(sanitizedExtension[i]);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    function basePartial(direction, userFn){\r\n        var args = slice(2, arguments);\r\n\r\n        return function appliedFunction(){\r\n            var applicationArgs = (direction === 'left') ?\r\n                                    concat(args, slice(0, arguments)) :\r\n                                    concat(slice(0, arguments), args);\r\n\r\n            return apply(userFn, applicationArgs);\r\n        };\r\n    }\r\n\r\n    function reverseArgs(userFn){\r\n        return function(){\r\n            var args = j.slice(0, arguments).reverse();\r\n            j.apply(userFn, args);\r\n        };\r\n    }\r\n\r\n    function captureArguments(userFn){\r\n        return userFn.toString()\r\n            .replace(/((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/)|(\\s))/mg,'')\r\n            .match(/^function\\s*[^\\(]*\\(\\s*([^\\)]*)\\)/m)[1]\r\n            .split(/,/);\r\n    }\r\n\r\n    function countArguments(userFn){\r\n        var params = shortCircuit([], captureArguments, userFn);\r\n\r\n        params = (params.length === 1 && params[0] === '') ? [] : params;\r\n\r\n        return params.length;\r\n    }\r\n\r\n    function execute(userFn){\r\n        return j.apply(userFn, j.slice(1, arguments));\r\n    }\r\n\r\n    j.apply = apply;\r\n    j.concat = concat;\r\n    j.countArguments = countArguments;\r\n    j.either = either;\r\n    j.eitherIf = eitherIf;\r\n    j.eitherWhen = eitherWhen;\r\n    j.execute = execute;\r\n    j.identity = identity;\r\n    j.maybe = maybe;\r\n    j.partial = basePartial('left', basePartial, 'left');\r\n    j.reverseArgs = reverseArgs;\r\n    j.rpartial = basePartial('left', basePartial, 'right');\r\n    j.shortCircuit = shortCircuit;\r\n    j.slice = slice;\r\n    j.when = when;\r\n\r\n})(jfp);\r\n\r\n\r\n(function(j){\r\n    'use strict';\r\n\r\n    function toValues(valueMap){\r\n        var finalArray = [],\r\n            key;\r\n\r\n        j.when(j.isObject(valueMap), function(){\r\n            for(key in valueMap){\r\n                if(valueMap.hasOwnProperty(key) && j.isTruthy(valueMap[key])){\r\n                    finalArray = j.conj(valueMap[key], finalArray);\r\n                }\r\n            }\r\n        });\r\n\r\n        return j.either(null, j.when(j.isObject(valueMap), function(){ return finalArray; }));\r\n    }\r\n\r\n    function toDec(value){\r\n        return (j.isNumeric(value)) ? parseInt(value, 10) : null;\r\n    }\r\n\r\n    j.toDec = toDec;\r\n    j.toValues = toValues;\r\n\r\n})(jfp);\r\n\r\n(function(j){\r\n    'use strict';\r\n\r\n    function copyArray(valueSet){\r\n        return j.slice(0, valueSet);\r\n    }\r\n\r\n    function makeValueArray(value){\r\n        return j.not(j.isUndefined(value)) ? [value] : [];\r\n    }\r\n\r\n    function conj(value, dest){\r\n        return j.concat(copyArray(dest), makeValueArray(value));\r\n    }\r\n\r\n    function cons(value, source){\r\n        return j.concat(makeValueArray(value), source);\r\n    }\r\n\r\n    function each(userFn, userArray){\r\n        var sanitizedArray = j.either([], userArray),\r\n            sanitizedFn = j.either(j.identity, userFn),\r\n            i;\r\n\r\n        for(i = 0; i < sanitizedArray.length; i++){\r\n            if(sanitizedFn(sanitizedArray[i], i) === false){\r\n                break;\r\n            }\r\n        }\r\n\r\n        return sanitizedArray;\r\n    }\r\n\r\n    function filter(predicate, userArray){\r\n        var result = [];\r\n\r\n        function filterFn(value){\r\n            j.when(predicate(value), function(){\r\n                result = conj(value, result);\r\n            });\r\n        }\r\n\r\n        each(filterFn, userArray);\r\n\r\n        return result;\r\n    }\r\n\r\n    function find(predicate, valueSet){\r\n        var finalValue = null;\r\n\r\n        function findFn(value){\r\n            return j.not(j.when(predicate(value), function(){\r\n                            finalValue = value;\r\n                            return true;\r\n                         }));\r\n        }\r\n\r\n        each(findFn, j.either([], valueSet));\r\n\r\n        return finalValue;\r\n    }\r\n\r\n    function first(values){\r\n        return j.isArray(values) ? j.either(null, values[0]) : null;\r\n    }\r\n\r\n    function lastIndex(values){\r\n        return j.isArray(values) ? values.length - 1 : null;\r\n    }\r\n\r\n    function last(values){\r\n        return j.isArray(values) ? values[lastIndex(values)] : null;\r\n    }\r\n\r\n    function drop(index, valueSet){\r\n        var finalIndex = lastIndex(valueSet),\r\n\r\n            sanitizedIndex = (index === 0 || index === finalIndex) ?\r\n                index : j.either(1, index) - 1,\r\n\r\n            firstArray = (sanitizedIndex === 0) ?\r\n                [] : j.slice(0, valueSet, sanitizedIndex),\r\n\r\n            secondArray = (sanitizedIndex === finalIndex)?\r\n                [] : j.slice(sanitizedIndex + 1, valueSet);\r\n\r\n        return j.concat(firstArray, secondArray);\r\n    }\r\n\r\n    function dropLast(valueSet){\r\n        return drop(lastIndex(valueSet), valueSet);\r\n    }\r\n\r\n    function map(userFn, userArray){\r\n        var finalArray = [];\r\n\r\n        function mapFn(value){\r\n            finalArray = conj(userFn(value), finalArray);\r\n        }\r\n\r\n        each(mapFn, userArray);\r\n\r\n        return finalArray;\r\n    }\r\n\r\n    function nth(index, valueSet){\r\n        return j.either(null, j.either([], valueSet)[index]);\r\n    }\r\n\r\n    function rest(values){\r\n        return j.slice(1, values);\r\n    }\r\n\r\n    function take(count, values){\r\n        return j.isArray(values) ? j.slice(0, values, count) : null;\r\n    }\r\n\r\n    function some(predicate, valueSet){\r\n        var satisfied = false;\r\n\r\n        function someFn(value, index){\r\n            satisfied = predicate(value, index);\r\n            return !satisfied;\r\n        }\r\n\r\n        each(someFn, valueSet);\r\n\r\n        return satisfied;\r\n    }\r\n\r\n    function contains(value, valueSet){\r\n        return some(j.partial(j.equal, value), valueSet);\r\n    }\r\n\r\n    function every(predicate, valueSet){\r\n        var satisfied = false;\r\n\r\n        function everyFn(value, index){\r\n            satisfied = predicate(value, index);\r\n            return satisfied;\r\n        }\r\n\r\n        each(everyFn, valueSet);\r\n\r\n        return satisfied;\r\n    }\r\n\r\n    function numberOf(predicate, valueSet){\r\n        var accumulator = 0;\r\n\r\n        function accumulate(value){\r\n            accumulator += predicate(value) ? 1 : 0;\r\n        }\r\n\r\n        each(accumulate, valueSet);\r\n\r\n        return accumulator;\r\n    }\r\n\r\n    function naturalComparator(a, b){\r\n        var comparison = a < b ? -1 : 1;\r\n        return a === b ? 0 : comparison;\r\n    }\r\n\r\n    function sort(optionValue, valueSet){\r\n        var comparator = j.isFunction(optionValue) ? optionValue : naturalComparator,\r\n            finalSet = j.isArray(optionValue) ? j.slice(0, optionValue) : j.slice(0, valueSet);\r\n\r\n        return finalSet.sort(comparator);\r\n    }\r\n\r\n    function union(set1, set2){\r\n        return j.compose(j.unique, j.concat)(set1, set2);\r\n    }\r\n\r\n    function buildValueHash(valueSet){\r\n        var finalHash = {};\r\n\r\n        j.each(function(value){\r\n            finalHash[value] = true;\r\n        }, valueSet);\r\n\r\n        return finalHash;\r\n    }\r\n\r\n    function intersect(set1, set2){\r\n        var finalSet = [],\r\n            seta = j.unique(j.either([], set1)),\r\n            setbHash = buildValueHash(j.either([], set2)),\r\n            i = 0;\r\n\r\n        for(; i < seta.length; i++){\r\n            if(setbHash[seta[i]]){\r\n                finalSet.push(seta[i]);\r\n            }\r\n        }\r\n\r\n        return finalSet;\r\n    }\r\n\r\n    function difference(set1, set2){\r\n        var finalSet = [],\r\n            seta = j.unique(j.either([], set1)),\r\n            setbHash = buildValueHash(j.either([], set2)),\r\n            i = 0;\r\n\r\n        for(; i < seta.length; i++){\r\n            if(!setbHash[seta[i]]){\r\n                finalSet.push(seta[i]);\r\n            }\r\n        }\r\n\r\n        return finalSet;\r\n    }\r\n\r\n    function symmetricDifference(set1, set2){\r\n        var setUnion = union(set1, set2),\r\n            setIntersection = intersect(set1, set2);\r\n\r\n        return difference(setUnion, setIntersection);\r\n    }\r\n\r\n    j.conj = conj;\r\n    j.cons = cons;\r\n    j.contains = contains;\r\n    j.copyArray = copyArray;\r\n    j.difference = difference;\r\n    j.drop = drop;\r\n    j.dropFirst = j.partial(drop, 0);\r\n    j.dropLast = dropLast;\r\n    j.each = each;\r\n    j.every = every;\r\n    j.filter = filter;\r\n    j.find = find;\r\n    j.first = first;\r\n    j.init = j.dropLast;\r\n    j.intersect = intersect;\r\n    j.last = last;\r\n    j.lastIndex = lastIndex;\r\n    j.map = map;\r\n    j.nth = nth;\r\n    j.numberOf = numberOf;\r\n    j.rest = rest;\r\n    j.sort = sort;\r\n    j.some = some;\r\n    j.symmetricDifference = symmetricDifference;\r\n    j.take = take;\r\n    j.union = union;\r\n\r\n})(jfp);\r\n\r\n\r\n(function(j){\r\n    'use strict';\r\n\r\n    function pick(key, valueMap){\r\n        var pickResult = j.either({}, valueMap)[key];\r\n        return j.isUndefined(pickResult) ? null : pickResult;\r\n    }\r\n\r\n    function pluckKeys(keys, valueMap){\r\n        var finalOutput = {},\r\n            sanitizedKeys = j.either([], keys),\r\n            sanitizedValueMap = j.either({}, valueMap);\r\n\r\n        function captureValue(key){\r\n            finalOutput[key] = sanitizedValueMap[key];\r\n        }\r\n\r\n        j.each(captureValue, sanitizedKeys);\r\n\r\n        return finalOutput;\r\n    }\r\n\r\n    function pluck(key, valueMap){\r\n        return pluckKeys([key], valueMap);\r\n    }\r\n\r\n    function merge(defaultObj, mergeData){\r\n        var finalObj = {},\r\n            key;\r\n\r\n        for(key in j.either({}, defaultObj)){\r\n            finalObj[key] = defaultObj[key];\r\n        }\r\n\r\n        for(key in j.either({}, mergeData)){\r\n            finalObj[key] = mergeData[key];\r\n        }\r\n\r\n        return j.eitherIf(null, finalObj, j.isTruthy(defaultObj));\r\n    }\r\n\r\n    j.merge = merge;\r\n    j.pick = pick;\r\n    j.pluck = pluck;\r\n    j.pluckKeys = pluckKeys;\r\n\r\n})(jfp);\r\n\r\n\r\n(function(j){\r\n    'use strict';\r\n\r\n    //This is complicated and I don't expect people to grok it on first read.\r\n    function curry(userFn){\r\n        var args = j.slice(1, arguments),\r\n            argumentCount = j.shortCircuit(0, j.countArguments, userFn),\r\n            appliedFn = (args.length < argumentCount) ? j.apply(j.partial, j.concat([curry, userFn], args)) : null,\r\n            result = (!!userFn && args.length >= argumentCount) ? j.apply(userFn, args) : null;\r\n\r\n        return j.either(appliedFn, result);\r\n    }\r\n\r\n    //zOMG! TAIL RECURSION\r\n    function recursor(recurFn){\r\n        var args = j.slice(1, arguments);\r\n\r\n        //This is to make the returned function distinct and identifiable.\r\n        return function recursorFn(localRecursor){\r\n            return j.apply(recurFn, j.concat([localRecursor], args));\r\n        };\r\n    }\r\n\r\n    function verifyRecurValue(recurValue){\r\n        return typeof recurValue === 'function' &&\r\n            recurValue.toString().match('recursorFn');\r\n    }\r\n\r\n    //Tail optimization with managed recursion is really complicated.\r\n    //Please don't muck with this unless you TRULY understand what is happening.\r\n    function recur(userFn){\r\n        var recursingFn = j.either(j.identity, userFn),\r\n            localRecursor = j.partial(recursor, recursingFn),\r\n            recurValue = j.apply(localRecursor, j.slice(1, arguments));\r\n\r\n        while(verifyRecurValue(recurValue = recurValue(localRecursor)) && recursingFn !== j.identity);\r\n\r\n        return recurValue;\r\n    }\r\n\r\n    function reduce(userFn, values, initialState){\r\n        var initialValue = j.either(j.first(values), initialState),\r\n            remainder = initialValue === initialState ? values : j.rest(values);\r\n            \r\n        function reducer(recur, reduction, collection){\r\n            return (collection.length) ?\r\n                recur(userFn(reduction, j.first(collection)), j.rest(collection)) :\r\n                reduction;\r\n        }\r\n\r\n        return (!!values && values.length > 0) ? recur(reducer, initialValue, remainder) : null;\r\n    }\r\n\r\n    //Performs 'and' operation on valueSet\r\n    function ander(recur, current, valueSet){\r\n        return (valueSet.length === 0) ?\r\n            current :\r\n            recur(current && !!j.first(valueSet), j.rest(valueSet));\r\n    }\r\n\r\n    function and(){\r\n        return recur(ander, true, j.slice(0, arguments));\r\n    }\r\n\r\n    //Performs 'or' operation on valueSet\r\n    function orer(recur, current, valueSet){\r\n        return (valueSet.length === 0) ?\r\n            current :\r\n            recur(current || !!j.first(valueSet), j.rest(valueSet));\r\n    }\r\n\r\n    function or(){\r\n        return recur(orer, false, j.slice(0, arguments));\r\n    }\r\n\r\n    function xor(a, b){\r\n        return !!(or(a, b) && j.not(j.isTruthy(a) === j.isTruthy(b)));\r\n    }\r\n\r\n    //Produces a function that returns f(g(x))\r\n    function compositor(f, g){\r\n        return function(){\r\n            return f(j.apply(g, j.slice(0, arguments)));\r\n        };\r\n    }\r\n\r\n    function compose(){\r\n        var args = j.slice(0, arguments);\r\n        return (args.length >= 1) ? reduce(compositor, args) : j.identity;\r\n    }\r\n\r\n    function pipeline(value){\r\n        return j.apply(compose, j.slice(1, arguments).reverse())(value);\r\n    }\r\n\r\n    function unique(valueSet){\r\n        var values = j.slice(0, valueSet).sort(),\r\n            finalValues = [];\r\n\r\n        function operator(value){\r\n            finalValues = j.eitherIf(finalValues,\r\n                                     j.conj(value, finalValues),\r\n                                     j.compose(j.not,\r\n                                               j.partial(j.equal, value),\r\n                                               j.last)(finalValues));\r\n        }\r\n\r\n        j.each(operator, values);\r\n\r\n        return finalValues;\r\n    }\r\n\r\n    function partialReverse(){\r\n        var args = j.slice(0, arguments),\r\n            partialAndReverse = j.compose(j.reverseArgs, j.partial);\r\n            \r\n        return j.apply(partialAndReverse, args);\r\n    }\r\n\r\n    function keyDeref(baseObj, key){\r\n        return j.isNull(baseObj) || j.isUndefined(baseObj[key]) ? null : baseObj[key];\r\n    }\r\n\r\n    function deref(baseData, key, defaultValue){\r\n        var keyTokens = j.either('', key).split('.'),\r\n            safeData = j.isUndefined(baseData) ? null : baseData,\r\n            outputData = j.isTruthy(key) ? j.reduce(keyDeref, keyTokens, safeData) : safeData;\r\n        \r\n        return outputData === null && !j.isUndefined(defaultValue) ? defaultValue : outputData;\r\n    }\r\n\r\n    j.and = and;\r\n    j.compact = j.partial(j.filter, j.isTruthy);\r\n    j.compose = compose;\r\n    j.curry = curry;\r\n    j.deref = deref;\r\n    j.or = or;\r\n    j.partialReverse = partialReverse;\r\n    j.pipeline = pipeline;\r\n    j.recur = recur;\r\n    j.reduce = reduce;\r\n    j.unique = unique;\r\n    j.xor = xor;\r\n\r\n})(jfp);\r\n\r\n\r\n(function(j){\r\n    'use strict';\r\n\r\n//This is a recursive add fn\r\n    function adder(recur, current, valueSet){\r\n        return (valueSet.length === 0) ?\r\n                current :\r\n                recur(current + j.first(valueSet), j.rest(valueSet));\r\n    }\r\n    \r\n    function add(a, b){\r\n        return j.recur(adder, 0, j.slice(0, arguments));\r\n    }\r\n    \r\n    //This is a recursive divide fn\r\n    function divider(recur, current, valueSet){\r\n        return (valueSet.length === 0) ?\r\n                current :\r\n                recur(current / j.first(valueSet), j.rest(valueSet));\r\n    }\r\n    \r\n    function divide(){\r\n        var args = j.slice(0, arguments),\r\n            first = args.length ? j.first(args) : 1;\r\n        return j.recur(divider, first, j.rest(args));\r\n    }\r\n    \r\n    //This is a recursive multiply fn\r\n    function multiplier(recur, current, valueSet){\r\n        return (valueSet.length === 0) ?\r\n                current :\r\n                recur(current * j.first(valueSet), j.rest(valueSet));\r\n    }\r\n    \r\n    function multiply(){\r\n        return j.recur(multiplier, 1, j.slice(0, arguments));\r\n    }\r\n    \r\n    //This is a recursive subtraction fn\r\n    function subtractor(recur, current, valueSet){\r\n        return (valueSet.length === 0) ?\r\n                current :\r\n                recur(current - j.first(valueSet), j.rest(valueSet));\r\n    }\r\n    \r\n    function subtract(){\r\n        var args = j.slice(0, arguments),\r\n            first = args.length ? j.first(args) : 0;\r\n        return j.recur(subtractor, first, j.rest(args));\r\n    }\r\n\r\n    //This is a recursive constructor function for ranges\r\n    function rangeRecurCheck(m, n, inc){\r\n        return inc > 0 ? (m + inc) < n : (m + inc) > n;\r\n    }\r\n\r\n    function rangeBuilder(recur, currentRange, m, n, inc){\r\n        var finalRange = rangeRecurCheck(m - inc, n, inc) ?\r\n                            j.conj(m, currentRange) :\r\n                            currentRange;\r\n        \r\n        return rangeRecurCheck(m, n, inc) ?\r\n                recur(finalRange, m + inc, n, inc) :\r\n                finalRange;\r\n    }\r\n    \r\n    function range(a, b, inc){\r\n        var start = j.isUndefined(b) ? 0 : a,\r\n            end = j.isUndefined(b) ? j.either(0, a) : b,\r\n            increment = (!inc) ? 1 : inc;\r\n            \r\n        return j.recur(rangeBuilder,\r\n                       [],\r\n                       j.either(0, start),\r\n                       j.either(0, end),\r\n                       increment);\r\n    }\r\n\r\n    function mod(a, b){\r\n        return j.isUndefined(b) ? j.either(0, a) : a%b;\r\n    }\r\n\r\n    function modulo(a, b){\r\n        var _a = j.either(0, a),\r\n            _b = j.either(0, b);\r\n\r\n        return (_a > 0) ? mod(_a, _b) : _b * (Math.floor(Math.abs(_a)/_b) + 1) + _a;\r\n    }\r\n\r\n    function truncate(value){\r\n        return (value > 0) ? Math.floor(value) : Math.floor(value) + 1;\r\n    }\r\n    \r\n    function max(a, b){\r\n        var maxValue = -Number.MAX_VALUE,\r\n            _a = j.isUndefined(a) ? maxValue : a,\r\n            _b = j.isUndefined(b) ? maxValue : b;\r\n            \r\n        maxValue = (_a > maxValue) ? _a : maxValue;\r\n        maxValue = (_b > maxValue) ? _b : maxValue;\r\n        \r\n        return maxValue;\r\n    }\r\n    \r\n    function min(a, b){\r\n        var minValue = Number.MAX_VALUE,\r\n            _a = j.isUndefined(a) ? minValue : a,\r\n            _b = j.isUndefined(b) ? minValue : b;\r\n        \r\n        minValue = (_a < minValue) ? _a : minValue;\r\n        minValue = (_b < minValue) ? _b : minValue;\r\n        \r\n        return minValue;\r\n    }\r\n\r\n    function fac(value){\r\n        var factorial = j.compose(j.partial(j.reduce, multiply),\r\n                                  j.partial(range, 1),\r\n                                  j.partial(add, 1));\r\n\r\n        return j.either(1, j.when(j.greater(value, 0), factorial, value));\r\n    }\r\n\r\n    j.add = add;\r\n    j.divide = divide;\r\n    j.fac = fac;\r\n    j.inc = j.partial(j.add, 1);\r\n    j.max = max;\r\n    j.min = min;\r\n    j.mod = mod;\r\n    j.modulo = modulo;\r\n    j.multiply = multiply;\r\n    j.range = range;\r\n    j.subtract = subtract;\r\n    j.truncate = truncate;\r\n\r\n})(jfp);\r\n\r\n\r\n(function(j){\r\n\r\n    function throwWhenNotComparable(a, b){\r\n        j.when(j.isUndefined(a) || j.isUndefined(b), function(){\r\n            throw new TypeError('Inequality comparisons require two values');\r\n        });\r\n    }\r\n\r\n    function equal(a, b){\r\n        var isNotUndefined = j.compose(j.not, j.isUndefined);\r\n        return (isNotUndefined(a) && isNotUndefined(b)) ? a === b : false;\r\n    }\r\n\r\n    function greater(a, b){\r\n        throwWhenNotComparable(a, b);\r\n        return a > b;\r\n    }\r\n\r\n    function less(a, b){\r\n        throwWhenNotComparable(a, b);\r\n        return a < b;\r\n    }\r\n\r\n    function isEven(value){\r\n        return equal(0, j.mod(value, 2));\r\n    }\r\n\r\n    function isPositive(value){\r\n        return greater(value, 0);\r\n    }\r\n\r\n    function isZero(value){\r\n        return value === 0;\r\n    }\r\n\r\n    function isNegative(value){\r\n        return j.compose(j.not, j.or)(isPositive(value), isZero(value));\r\n    }\r\n\r\n    function isInt(value){\r\n        return equal(j.truncate(value), value);\r\n    }\r\n\r\n    j.isEven = isEven;\r\n    j.isInt = isInt;\r\n    j.isNegative = isNegative;\r\n    j.isNonNegative = j.compose(j.not, isNegative);\r\n    j.isNonPositive = j.compose(j.not, isPositive);\r\n    j.isNonZero = j.compose(j.not, isZero);\r\n    j.isOdd = j.compose(j.not, isEven);\r\n    j.isPositive = isPositive;\r\n    j.isZero = isZero;\r\n\r\n    //Special case predicate naming is intended for these functions\r\n    //There is a general expectation that these not be named with 'is'\r\n    j.equal = equal;\r\n    j.geq = j.compose(j.not, less);\r\n    j.greater = greater;\r\n    j.leq = j.compose(j.not, greater);\r\n    j.less = less;\r\n\r\n})(jfp);\r\n\r\nvar j = jfp;\r\n\r\nif(typeof module !== 'undefined' && !!module.exports){\r\n    module.exports = j;\r\n}\r\n\r\n\r\n"]}