{"version":3,"file":"jfp.min.js","sources":["jfp.js"],"names":["jfp","resolveFunction","functionValue","curryAlias","args","slice","arguments","apply","curry","pickAlias","key","value","cleanKey","Boolean","pick","partial","chooseResolver","resolveToPick","charAt","resolver","j","isBoolean","isFunction","testFn","isObject","isArray","Object","prototype","toString","call","isString","isEmptyString","isNull","isNumber","isNumeric","pattern","match","isTruthy","isUndefined","undefined","not","identity","begin","valueSet","end","values","Array","shortCircuit","defaultValue","userFn","testValue","maybe","type","typeOkay","either","when","checkValue","eitherIf","predicateValue","safePredicate","eitherWhen","sanitizedFn","concat","original","extension","result","sanitizedExtension","i","length","push","basePartial","direction","appliedFunction","applicationArgs","reverseArgs","reverse","countArguments","execute","rpartial","toValues","valueMap","finalArray","hasOwnProperty","conj","toDec","parseInt","copyArray","makeValueArray","dest","cons","source","each","userArray","sanitizedArray","find","predicate","finalValue","findFn","first","lastIndex","last","drop","index","finalIndex","sanitizedIndex","firstArray","secondArray","dropLast","nth","rest","take","count","some","satisfied","someFn","contains","equal","every","everyFn","numberOf","accumulator","accumulate","naturalComparator","a","b","comparison","sort","optionValue","comparator","finalSet","dropFirst","init","pickResult","pluckKeys","keys","finalOutput","sanitizedKeys","sanitizedValueMap","captureValue","pluck","merge","defaultObj","mergeData","finalObj","map","filter","argumentCount","appliedFn","recursor","recurFn","recursorFn","localRecursor","verifyRecurValue","recurValue","recur","recursingFn","reducer","reduction","collection","finished","newReduction","reduce","initialState","appliedReducer","initialValue","remainder","arrayReduceAdapter","reducerFn","valueList","mapper","filterer","userPredicate","ander","current","and","orer","or","xor","compositor","f","g","compose","pipeline","captureUnique","finalList","unique","partialReverse","partialAndReverse","deref","baseData","sanitizedDefault","keyTokens","split","derefValue","returnValue","union","set1","set2","addToHash","finalObject","buildValueHash","captureIntersection","valueHash","intersect","setHash","captureDifference","difference","symmetricDifference","setUnion","setIntersection","compact","adder","add","divider","divide","multiplier","multiply","subtractor","subtract","rangeRecurCheck","m","n","inc","rangeBuilder","currentRange","finalRange","range","start","increment","mod","modulo","_a","_b","Math","floor","abs","truncate","max","maxValue","Number","MAX_VALUE","min","minValue","fac","factorial","greater","throwWhenNotComparable","TypeError","isNotUndefined","less","isEven","isPositive","isZero","isNegative","isInt","isNonNegative","isNonPositive","isNonZero","isOdd","geq","leq","module","exports"],"mappings":"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","sourcesContent":["var jfp = (function(){\r\n    'use strict';\r\n    \r\n    function resolveFunction(functionValue){\r\n        return typeof functionValue === 'string' ? jfp[functionValue] : functionValue;\r\n    }\r\n    \r\n    function curryAlias(){\r\n        var args = jfp.slice(0, arguments);\r\n\r\n        args[0] = resolveFunction(args[0]);\r\n        \r\n        return jfp.apply(jfp.curry, args);\r\n    }\r\n    \r\n    function pickAlias(key, value){\r\n        var cleanKey = key.slice(1);\r\n        \r\n        return Boolean(value) ? jfp.pick(cleanKey, value) : jfp.partial(jfp.pick, cleanKey);\r\n    }\r\n    \r\n    function chooseResolver(value){\r\n        var resolveToPick = typeof value === 'string' && value.charAt(0) === ':';\r\n        \r\n        return resolveToPick ? pickAlias : curryAlias;\r\n    }\r\n    \r\n    return function(){\r\n        var args = jfp.slice(0, arguments),\r\n            resolver = chooseResolver(args[0]);\r\n        \r\n        return jfp.apply(resolver, args);\r\n    };\r\n    \r\n})();\r\n\r\n(function(j){\r\n    'use strict';\r\n    \r\n    function isBoolean(value){\r\n        return typeof value === 'boolean';\r\n    }\r\n\r\n    function isFunction(testFn){\r\n        return typeof testFn === 'function';\r\n    }\r\n    \r\n    function isObject(value){\r\n        return (typeof value == 'object');\r\n    }\r\n    \r\n    function isArray(value){\r\n        return (isObject(value) && Object.prototype.toString.call(value) === '[object Array]');\r\n    }\r\n    \r\n    function isString(value){\r\n        return typeof value === 'string';\r\n    }\r\n\r\n    function isEmptyString(value){\r\n        return isString(value) && value === '';\r\n    }\r\n    \r\n    function isNull(value){\r\n        return value === null;\r\n    }\r\n    \r\n    function isNumber(value){\r\n        return typeof value === 'number';\r\n    }\r\n    \r\n    function isNumeric(value){\r\n        var pattern = /^(0x)?[0-9]+((\\.[0-9]+)|(e\\-?[0-9]+))?$/;\r\n        return isNumber(value) || (isString(value) && !!value.match(pattern));\r\n    }\r\n    \r\n    function isTruthy(value){\r\n        return !!value;\r\n    }\r\n    \r\n    function isUndefined(value){\r\n        return value === undefined;\r\n    }\r\n\r\n    function not(value){\r\n        return !value;\r\n    }\r\n\r\n    j.isArray = isArray;\r\n    j.isBoolean = isBoolean;\r\n    j.isEmptyString = isEmptyString;\r\n    j.isFunction = isFunction;\r\n    j.isNull = isNull;\r\n    j.isNumber = isNumber;\r\n    j.isNumeric = isNumeric;\r\n    j.isObject = isObject;\r\n    j.isString = isString;\r\n    j.isTruthy = isTruthy;\r\n    j.isUndefined = isUndefined;\r\n    j.not = not;\r\n\r\n})(jfp);\r\n\r\n\r\n(function(j){\r\n    'use strict';\r\n\r\n    function identity(value){\r\n        return value;\r\n    }\r\n\r\n    function slice(begin, valueSet, end){\r\n        var values = j.not(j.isTruthy(valueSet)) ? [] : valueSet;\r\n\r\n        return j.not(j.isTruthy(end)) ?\r\n                    Array.prototype.slice.call(values, begin) :\r\n                    Array.prototype.slice.call(values, begin, end);\r\n    }\r\n\r\n    function shortCircuit(defaultValue, userFn, testValue){\r\n        return (j.isTruthy(testValue) || testValue === 0) ?\r\n            userFn(testValue) :\r\n            defaultValue;\r\n    }\r\n\r\n    function maybe(value){\r\n        var type = arguments[1],\r\n            typeOkay = typeof value === type;\r\n\r\n        return typeOkay || (!type && !!value) ? value : null;\r\n    }\r\n\r\n    function either(defaultValue, testValue){\r\n        var type = arguments[2];\r\n        return maybe(testValue, type) === null ? defaultValue : testValue;\r\n    }\r\n\r\n    function apply(userFn, args){\r\n        return userFn.apply(null, args);\r\n    }\r\n\r\n    function when(checkValue, userFn){\r\n        var args = slice(2, arguments);\r\n        return j.isTruthy(checkValue) ? apply(userFn, args) : null;\r\n    }\r\n\r\n    function eitherIf(defaultValue, testValue, predicateValue){\r\n        var safePredicate = j.isUndefined(predicateValue) ? true : predicateValue;\r\n\r\n        return j.either(defaultValue, j.when(safePredicate, j.partial(j.identity, testValue)));\r\n    }\r\n\r\n    function eitherWhen(defaultValue, predicateValue, userFn){\r\n        var sanitizedFn = eitherIf(j.identity, userFn, j.isFunction(userFn));\r\n\r\n        return j.either(defaultValue, j.when(predicateValue, sanitizedFn));\r\n    }\r\n\r\n    function concat(original, extension){\r\n        var result = slice(0, either([], original)),\r\n            sanitizedExtension = either([], extension),\r\n            i;\r\n\r\n        //This is the most performant way to handle concatenation. Trust me.\r\n        for(i = 0; i < sanitizedExtension.length; i++){\r\n            result.push(sanitizedExtension[i]);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    function basePartial(direction, userFn){\r\n        var args = slice(2, arguments);\r\n\r\n        return function appliedFunction(){\r\n            var applicationArgs = (direction === 'left') ?\r\n                                    concat(args, slice(0, arguments)) :\r\n                                    concat(slice(0, arguments), args);\r\n\r\n            return apply(userFn, applicationArgs);\r\n        };\r\n    }\r\n\r\n    function reverseArgs(userFn){\r\n        return function(){\r\n            var args = j.slice(0, arguments).reverse();\r\n            return j.apply(userFn, args);\r\n        };\r\n    }\r\n\r\n    function countArguments(userFn){\r\n        return either(function(){}, userFn).length;\r\n    }\r\n\r\n    function execute(userFn){\r\n        return j.apply(userFn, j.slice(1, arguments));\r\n    }\r\n\r\n    j.apply = apply;\r\n    j.concat = concat;\r\n    j.countArguments = countArguments;\r\n    j.either = either;\r\n    j.eitherIf = eitherIf;\r\n    j.eitherWhen = eitherWhen;\r\n    j.execute = execute;\r\n    j.identity = identity;\r\n    j.maybe = maybe;\r\n    j.partial = basePartial('left', basePartial, 'left');\r\n    j.reverseArgs = reverseArgs;\r\n    j.rpartial = basePartial('left', basePartial, 'right');\r\n    j.shortCircuit = shortCircuit;\r\n    j.slice = slice;\r\n    j.when = when;\r\n\r\n})(jfp);\r\n\r\n\r\n(function(j){\r\n    'use strict';\r\n\r\n    function toValues(valueMap){\r\n        var finalArray = [],\r\n            key;\r\n\r\n        j.when(j.isObject(valueMap), function(){\r\n            for(key in valueMap){\r\n                if(valueMap.hasOwnProperty(key) && j.isTruthy(valueMap[key])){\r\n                    finalArray = j.conj(valueMap[key], finalArray);\r\n                }\r\n            }\r\n        });\r\n\r\n        return j.either(null, j.when(j.isObject(valueMap), function(){ return finalArray; }));\r\n    }\r\n\r\n    function toDec(value){\r\n        return (j.isNumeric(value)) ? parseInt(value, 10) : null;\r\n    }\r\n\r\n    j.toDec = toDec;\r\n    j.toValues = toValues;\r\n\r\n})(jfp);\r\n\r\n(function(j){\r\n    'use strict';\r\n\r\n    function copyArray(valueSet){\r\n        return j.slice(0, valueSet);\r\n    }\r\n\r\n    function makeValueArray(value){\r\n        return j.not(j.isUndefined(value)) ? [value] : [];\r\n    }\r\n\r\n    function conj(value, dest){\r\n        return j.concat(copyArray(dest), makeValueArray(value));\r\n    }\r\n\r\n    function cons(value, source){\r\n        return j.concat(makeValueArray(value), source);\r\n    }\r\n\r\n    function each(userFn, userArray){\r\n        var sanitizedArray = j.either([], userArray),\r\n            sanitizedFn = j.either(j.identity, userFn),\r\n            i;\r\n\r\n        for(i = 0; i < sanitizedArray.length; i++){\r\n            if(sanitizedFn(sanitizedArray[i], i) === false){\r\n                break;\r\n            }\r\n        }\r\n\r\n        return sanitizedArray;\r\n    }\r\n\r\n    function find(predicate, valueSet){\r\n        var finalValue = null;\r\n\r\n        function findFn(value){\r\n            return j.not(j.when(predicate(value), function(){\r\n                            finalValue = value;\r\n                            return true;\r\n                         }));\r\n        }\r\n\r\n        each(findFn, j.either([], valueSet));\r\n\r\n        return finalValue;\r\n    }\r\n\r\n    function first(values){\r\n        return j.isArray(values) ? j.either(null, values[0]) : null;\r\n    }\r\n\r\n    function lastIndex(values){\r\n        return j.isArray(values) ? values.length - 1 : null;\r\n    }\r\n\r\n    function last(values){\r\n        return j.isArray(values) ? values[lastIndex(values)] : null;\r\n    }\r\n\r\n    function drop(index, valueSet){\r\n        var finalIndex = lastIndex(valueSet),\r\n\r\n            sanitizedIndex = (index === 0 || index === finalIndex) ?\r\n                index : j.either(1, index) - 1,\r\n\r\n            firstArray = (sanitizedIndex === 0) ?\r\n                [] : j.slice(0, valueSet, sanitizedIndex),\r\n\r\n            secondArray = (sanitizedIndex === finalIndex)?\r\n                [] : j.slice(sanitizedIndex + 1, valueSet);\r\n\r\n        return j.concat(firstArray, secondArray);\r\n    }\r\n\r\n    function dropLast(valueSet){\r\n        return drop(lastIndex(valueSet), valueSet);\r\n    }\r\n\r\n    function nth(index, valueSet){\r\n        return j.either(null, j.either([], valueSet)[index]);\r\n    }\r\n\r\n    function rest(values){\r\n        return j.slice(1, values);\r\n    }\r\n\r\n    function take(count, values){\r\n        return j.isArray(values) ? j.slice(0, values, count) : null;\r\n    }\r\n\r\n    function some(predicate, valueSet){\r\n        var satisfied = false;\r\n\r\n        function someFn(value, index){\r\n            satisfied = predicate(value, index);\r\n            return !satisfied;\r\n        }\r\n\r\n        each(someFn, valueSet);\r\n\r\n        return satisfied;\r\n    }\r\n\r\n    function contains(value, valueSet){\r\n        return some(j.partial(j.equal, value), valueSet);\r\n    }\r\n\r\n    function every(predicate, valueSet){\r\n        var satisfied = false;\r\n\r\n        function everyFn(value, index){\r\n            satisfied = predicate(value, index);\r\n            return satisfied;\r\n        }\r\n\r\n        each(everyFn, valueSet);\r\n\r\n        return satisfied;\r\n    }\r\n\r\n    function numberOf(predicate, valueSet){\r\n        var accumulator = 0;\r\n\r\n        function accumulate(value){\r\n            accumulator += predicate(value) ? 1 : 0;\r\n        }\r\n\r\n        each(accumulate, valueSet);\r\n\r\n        return accumulator;\r\n    }\r\n\r\n    function naturalComparator(a, b){\r\n        var comparison = a < b ? -1 : 1;\r\n        return a === b ? 0 : comparison;\r\n    }\r\n\r\n    function sort(optionValue, valueSet){\r\n        var comparator = j.isFunction(optionValue) ? optionValue : naturalComparator,\r\n            finalSet = j.isArray(optionValue) ? j.slice(0, optionValue) : j.slice(0, valueSet);\r\n\r\n        return finalSet.sort(comparator);\r\n    }\r\n\r\n    j.conj = conj;\r\n    j.cons = cons;\r\n    j.contains = contains;\r\n    j.copyArray = copyArray;\r\n    j.drop = drop;\r\n    j.dropFirst = j.partial(drop, 0);\r\n    j.dropLast = dropLast;\r\n    j.each = each;\r\n    j.every = every;\r\n    j.find = find;\r\n    j.first = first;\r\n    j.init = j.dropLast;\r\n    j.last = last;\r\n    j.lastIndex = lastIndex;\r\n    j.nth = nth;\r\n    j.numberOf = numberOf;\r\n    j.rest = rest;\r\n    j.sort = sort;\r\n    j.some = some;\r\n    j.take = take;\r\n\r\n})(jfp);\r\n\r\n\r\n(function(j){\r\n    'use strict';\r\n\r\n    function pick(key, valueMap){\r\n        var pickResult = j.either({}, valueMap)[key];\r\n        return j.isUndefined(pickResult) ? null : pickResult;\r\n    }\r\n\r\n    function pluckKeys(keys, valueMap){\r\n        var finalOutput = {},\r\n            sanitizedKeys = j.either([], keys),\r\n            sanitizedValueMap = j.either({}, valueMap);\r\n\r\n        function captureValue(key){\r\n            finalOutput[key] = sanitizedValueMap[key];\r\n        }\r\n\r\n        j.each(captureValue, sanitizedKeys);\r\n\r\n        return finalOutput;\r\n    }\r\n\r\n    function pluck(key, valueMap){\r\n        return pluckKeys([key], valueMap);\r\n    }\r\n\r\n    function merge(defaultObj, mergeData){\r\n        var finalObj = {},\r\n            key;\r\n\r\n        for(key in j.either({}, defaultObj)){\r\n            finalObj[key] = defaultObj[key];\r\n        }\r\n\r\n        for(key in j.either({}, mergeData)){\r\n            finalObj[key] = mergeData[key];\r\n        }\r\n\r\n        return j.eitherIf(null, finalObj, j.isTruthy(defaultObj));\r\n    }\r\n\r\n    j.merge = merge;\r\n    j.pick = pick;\r\n    j.pluck = pluck;\r\n    j.pluckKeys = pluckKeys;\r\n\r\n})(jfp);\r\n\r\n\r\n(function(j){\r\n    'use strict';\r\n\r\n    var map, filter;\r\n\r\n    //This is complicated and I don't expect people to grok it on first read.\r\n    function curry(userFn){\r\n        var args = j.slice(1, arguments),\r\n            argumentCount = j.countArguments(userFn),\r\n            appliedFn = (args.length < argumentCount) ? j.apply(j.partial, j.concat([curry, userFn], args)) : null,\r\n            result = (!!userFn && args.length >= argumentCount) ? j.apply(userFn, args) : null;\r\n\r\n        return j.either(appliedFn, result);\r\n    }\r\n\r\n    //zOMG! TAIL RECURSION\r\n    function recursor(recurFn){\r\n        var args = j.slice(1, arguments);\r\n\r\n        //This is to make the returned function distinct and identifiable.\r\n        return function recursorFn(localRecursor){\r\n            return j.apply(recurFn, j.concat([localRecursor], args));\r\n        };\r\n    }\r\n\r\n    function verifyRecurValue(recurValue){\r\n        return typeof recurValue === 'function' &&\r\n            recurValue.toString().match('recursorFn');\r\n    }\r\n\r\n    //Tail optimization with managed recursion is really complicated.\r\n    //Please don't muck with this unless you TRULY understand what is happening.\r\n    function recur(userFn){\r\n        var recursingFn = j.either(j.identity, userFn),\r\n            localRecursor = j.partial(recursor, recursingFn),\r\n            recurValue = j.apply(localRecursor, j.slice(1, arguments));\r\n\r\n        while(verifyRecurValue(recurValue = recurValue(localRecursor)) && recursingFn !== j.identity);\r\n\r\n        return recurValue;\r\n    }\r\n\r\n\r\n    /*\r\n     * Reduce uses tail-optimized (while-trampolined, fully returning) recursion to resolve reductions.\r\n     * Reducer is a pure function for handling a single reduction step.\r\n     * Reduce manages the setup and recursion execution.\r\n     */\r\n    function reducer(userFn, recur, reduction, collection){\r\n        var finished = collection.length === 0,\r\n            newReduction = finished ? reduction : userFn(reduction, j.first(collection));\r\n            \r\n        return finished ? reduction : recur(newReduction, j.rest(collection));\r\n    }\r\n\r\n    function reduce(userFn, values, initialState){\r\n        var appliedReducer = j.partial(reducer, userFn),\r\n            initialValue = j.eitherIf(j.first(values), initialState, !j.isUndefined(initialState)),\r\n            remainder = j.eitherIf(j.rest(values), values, !j.isUndefined(initialState));\r\n            \r\n        return (!!values && values.length > 0) ? recur(appliedReducer, initialValue, remainder) : null;\r\n    }\r\n\r\n\r\n    // Adapter function for reduce to allow for simplification of\r\n    // array construction behaviors like map and filter\r\n    function arrayReduceAdapter(reducerFn, userFn, valueList){\r\n        var appliedReducer = j.partial(reducerFn, userFn),\r\n            result = reduce(appliedReducer, valueList, []);\r\n        \r\n        return j.either([], result);\r\n    }\r\n\r\n    /*\r\n     * Map uses reduce to produce a new, completely reference-decoupled list of values\r\n     * Mapper handles a single update step for the final output array\r\n     */\r\n    function mapper(userFn, finalArray, value){\r\n        finalArray.push(userFn(value));\r\n        return finalArray;\r\n    }\r\n\r\n    map = j.partial(arrayReduceAdapter, mapper);\r\n\r\n    /*\r\n     * Filter uses reduce to produce a new, completely reference-decoupled list of values\r\n     * Filterer handles a single update step for the final output array\r\n     */\r\n    function filterer(userPredicate, finalArray, value){\r\n        if(userPredicate(value)){\r\n            finalArray.push(value);\r\n        }\r\n        \r\n        return finalArray;\r\n    }\r\n\r\n    filter = j.partial(arrayReduceAdapter, filterer);\r\n\r\n    //Performs 'and' operation on valueSet\r\n    function ander(recur, current, valueSet){\r\n        return (valueSet.length === 0) ?\r\n            current :\r\n            recur(current && Boolean(j.first(valueSet)), j.rest(valueSet));\r\n    }\r\n\r\n    function and(){\r\n        return recur(ander, true, j.slice(0, arguments));\r\n    }\r\n\r\n    //Performs 'or' operation on valueSet\r\n    function orer(recur, current, valueSet){\r\n        return (valueSet.length === 0) ?\r\n            current :\r\n            recur(current || Boolean(j.first(valueSet)), j.rest(valueSet));\r\n    }\r\n\r\n    function or(){\r\n        return recur(orer, false, j.slice(0, arguments));\r\n    }\r\n\r\n    function xor(a, b){\r\n        return Boolean(or(a, b) && j.not(j.isTruthy(a) === j.isTruthy(b)));\r\n    }\r\n\r\n    //Produces a function that returns f(g(x))\r\n    function compositor(f, g){\r\n        return function(){\r\n            return f(j.apply(g, j.slice(0, arguments)));\r\n        };\r\n    }\r\n\r\n    function compose(){\r\n        var args = j.slice(0, arguments);\r\n        return (args.length >= 1) ? reduce(compositor, args) : j.identity;\r\n    }\r\n\r\n    function pipeline(value){\r\n        return j.apply(compose, j.slice(1, arguments).reverse())(value);\r\n    }\r\n\r\n    function captureUnique(finalList, value){\r\n        if(j.last(finalList) !== value){\r\n            finalList.push(value);\r\n        }\r\n        \r\n        return finalList;\r\n    }\r\n    \r\n    function unique(valueSet){\r\n        var values = j.sort(j.slice(0, valueSet));\r\n        return reduce(captureUnique, values, []);\r\n    }\r\n\r\n    function partialReverse(){\r\n        var args = j.slice(0, arguments),\r\n            partialAndReverse = j.compose(j.reverseArgs, j.partial);\r\n            \r\n        return j.apply(partialAndReverse, args);\r\n    }\r\n\r\n    function deref(baseData, key, defaultValue){\r\n        var sanitizedDefault = j.either(null, defaultValue),\r\n            keyTokens = j.either('', key).split('.'),\r\n            derefValue = j.reduce(j.reverseArgs(j.pick), keyTokens, baseData),\r\n            returnValue = Boolean(key) ? derefValue : baseData;\r\n        \r\n        returnValue = !Boolean(baseData) ? null : returnValue;\r\n        \r\n        return returnValue === null ? sanitizedDefault : returnValue;\r\n    }\r\n\r\n    function union(set1, set2){\r\n        return j.compose(j.unique, j.concat)(set1, set2);\r\n    }\r\n\r\n    function addToHash(finalObject, value){\r\n        finalObject[value] = true;\r\n        return finalObject;\r\n    }\r\n\r\n    function buildValueHash(valueList){\r\n        return j.either({}, reduce(addToHash, valueList, {}));\r\n    }\r\n\r\n    function captureIntersection(valueHash, finalList, value){\r\n        if(valueHash[value]){\r\n            finalList.push(value);\r\n        }\r\n\r\n        return finalList;\r\n    }\r\n    \r\n    function intersect(set1, set2){\r\n        var setHash = buildValueHash(j.either([], set2));\r\n        return reduce(j.partial(captureIntersection, setHash), set1, []); \r\n    }\r\n\r\n    function captureDifference(valueHash, finalList, value){\r\n        if(!valueHash[value]){\r\n            finalList.push(value);\r\n        }\r\n        \r\n        return finalList;\r\n    }\r\n    \r\n    function difference(set1, set2){\r\n        var setHash = buildValueHash(j.either([], set2));\r\n        return reduce(j.partial(captureDifference, setHash), set1, []);\r\n    }\r\n\r\n    function symmetricDifference(set1, set2){\r\n        var setUnion = union(set1, set2),\r\n            setIntersection = intersect(set1, set2);\r\n\r\n        return difference(setUnion, setIntersection);\r\n    }\r\n\r\n    j.and = and;\r\n    j.compact = j.partial(filter, j.isTruthy);\r\n    j.compose = compose;\r\n    j.curry = curry;\r\n    j.deref = deref;\r\n    j.difference = difference;\r\n    j.filter = filter;\r\n    j.intersect = intersect;\r\n    j.map = map;\r\n    j.or = or;\r\n    j.partialReverse = partialReverse;\r\n    j.pipeline = pipeline;\r\n    j.recur = recur;\r\n    j.reduce = reduce;\r\n    j.symmetricDifference = symmetricDifference;\r\n    j.union = union;\r\n    j.unique = unique;\r\n    j.xor = xor;\r\n\r\n})(jfp);\r\n\r\n\r\n(function(j){\r\n    'use strict';\r\n\r\n//This is a recursive add fn\r\n    function adder(recur, current, valueSet){\r\n        return (valueSet.length === 0) ?\r\n                current :\r\n                recur(current + j.first(valueSet), j.rest(valueSet));\r\n    }\r\n    \r\n    function add(a, b){\r\n        return j.recur(adder, 0, j.slice(0, arguments));\r\n    }\r\n    \r\n    //This is a recursive divide fn\r\n    function divider(recur, current, valueSet){\r\n        return (valueSet.length === 0) ?\r\n                current :\r\n                recur(current / j.first(valueSet), j.rest(valueSet));\r\n    }\r\n    \r\n    function divide(){\r\n        var args = j.slice(0, arguments),\r\n            first = args.length ? j.first(args) : 1;\r\n        return j.recur(divider, first, j.rest(args));\r\n    }\r\n    \r\n    //This is a recursive multiply fn\r\n    function multiplier(recur, current, valueSet){\r\n        return (valueSet.length === 0) ?\r\n                current :\r\n                recur(current * j.first(valueSet), j.rest(valueSet));\r\n    }\r\n    \r\n    function multiply(){\r\n        return j.recur(multiplier, 1, j.slice(0, arguments));\r\n    }\r\n    \r\n    //This is a recursive subtraction fn\r\n    function subtractor(recur, current, valueSet){\r\n        return (valueSet.length === 0) ?\r\n                current :\r\n                recur(current - j.first(valueSet), j.rest(valueSet));\r\n    }\r\n    \r\n    function subtract(){\r\n        var args = j.slice(0, arguments),\r\n            first = args.length ? j.first(args) : 0;\r\n        return j.recur(subtractor, first, j.rest(args));\r\n    }\r\n\r\n    //This is a recursive constructor function for ranges\r\n    function rangeRecurCheck(m, n, inc){\r\n        return inc > 0 ? (m + inc) < n : (m + inc) > n;\r\n    }\r\n\r\n    function rangeBuilder(recur, currentRange, m, n, inc){\r\n        var finalRange = rangeRecurCheck(m - inc, n, inc) ?\r\n                            j.conj(m, currentRange) :\r\n                            currentRange;\r\n        \r\n        return rangeRecurCheck(m, n, inc) ?\r\n                recur(finalRange, m + inc, n, inc) :\r\n                finalRange;\r\n    }\r\n    \r\n    function range(a, b, inc){\r\n        var start = j.isUndefined(b) ? 0 : a,\r\n            end = j.isUndefined(b) ? j.either(0, a) : b,\r\n            increment = (!inc) ? 1 : inc;\r\n            \r\n        return j.recur(rangeBuilder,\r\n                       [],\r\n                       j.either(0, start),\r\n                       j.either(0, end),\r\n                       increment);\r\n    }\r\n\r\n    function mod(a, b){\r\n        return j.isUndefined(b) ? j.either(0, a) : a%b;\r\n    }\r\n\r\n    function modulo(a, b){\r\n        var _a = j.either(0, a),\r\n            _b = j.either(0, b);\r\n\r\n        return (_a > 0) ? mod(_a, _b) : _b * (Math.floor(Math.abs(_a)/_b) + 1) + _a;\r\n    }\r\n\r\n    function truncate(value){\r\n        return (value > 0) ? Math.floor(value) : Math.floor(value) + 1;\r\n    }\r\n    \r\n    function max(a, b){\r\n        var maxValue = -Number.MAX_VALUE,\r\n            _a = j.isUndefined(a) ? maxValue : a,\r\n            _b = j.isUndefined(b) ? maxValue : b;\r\n            \r\n        maxValue = (_a > maxValue) ? _a : maxValue;\r\n        maxValue = (_b > maxValue) ? _b : maxValue;\r\n        \r\n        return maxValue;\r\n    }\r\n    \r\n    function min(a, b){\r\n        var minValue = Number.MAX_VALUE,\r\n            _a = j.isUndefined(a) ? minValue : a,\r\n            _b = j.isUndefined(b) ? minValue : b;\r\n        \r\n        minValue = (_a < minValue) ? _a : minValue;\r\n        minValue = (_b < minValue) ? _b : minValue;\r\n        \r\n        return minValue;\r\n    }\r\n\r\n    function fac(value){\r\n        var factorial = j.compose(j.partial(j.reduce, multiply),\r\n                                  j.partial(range, 1),\r\n                                  j.partial(add, 1));\r\n\r\n        return j.either(1, j.when(j.greater(value, 0), factorial, value));\r\n    }\r\n\r\n    j.add = add;\r\n    j.divide = divide;\r\n    j.fac = fac;\r\n    j.inc = j.partial(j.add, 1);\r\n    j.max = max;\r\n    j.min = min;\r\n    j.mod = mod;\r\n    j.modulo = modulo;\r\n    j.multiply = multiply;\r\n    j.range = range;\r\n    j.subtract = subtract;\r\n    j.truncate = truncate;\r\n\r\n})(jfp);\r\n\r\n\r\n(function(j){\r\n\r\n    function throwWhenNotComparable(a, b){\r\n        j.when(j.isUndefined(a) || j.isUndefined(b), function(){\r\n            throw new TypeError('Inequality comparisons require two values');\r\n        });\r\n    }\r\n\r\n    function equal(a, b){\r\n        var isNotUndefined = j.compose(j.not, j.isUndefined);\r\n        return (isNotUndefined(a) && isNotUndefined(b)) ? a === b : false;\r\n    }\r\n\r\n    function greater(a, b){\r\n        throwWhenNotComparable(a, b);\r\n        return a > b;\r\n    }\r\n\r\n    function less(a, b){\r\n        throwWhenNotComparable(a, b);\r\n        return a < b;\r\n    }\r\n\r\n    function isEven(value){\r\n        return equal(0, j.mod(value, 2));\r\n    }\r\n\r\n    function isPositive(value){\r\n        return greater(value, 0);\r\n    }\r\n\r\n    function isZero(value){\r\n        return value === 0;\r\n    }\r\n\r\n    function isNegative(value){\r\n        return j.compose(j.not, j.or)(isPositive(value), isZero(value));\r\n    }\r\n\r\n    function isInt(value){\r\n        return equal(j.truncate(value), value);\r\n    }\r\n\r\n    j.isEven = isEven;\r\n    j.isInt = isInt;\r\n    j.isNegative = isNegative;\r\n    j.isNonNegative = j.compose(j.not, isNegative);\r\n    j.isNonPositive = j.compose(j.not, isPositive);\r\n    j.isNonZero = j.compose(j.not, isZero);\r\n    j.isOdd = j.compose(j.not, isEven);\r\n    j.isPositive = isPositive;\r\n    j.isZero = isZero;\r\n\r\n    //Special case predicate naming is intended for these functions\r\n    //There is a general expectation that these not be named with 'is'\r\n    j.equal = equal;\r\n    j.geq = j.compose(j.not, less);\r\n    j.greater = greater;\r\n    j.leq = j.compose(j.not, greater);\r\n    j.less = less;\r\n\r\n})(jfp);\r\n\r\nvar j = jfp;\r\n\r\nif(typeof module !== 'undefined' && !!module.exports){\r\n    module.exports = j;\r\n}\r\n\r\n\r\n"]}