{"version":3,"file":"jfp.min.js","sources":["jfp.js"],"names":["jfp","resolveFunction","functionValue","curryAlias","args","slice","arguments","apply","curry","pickAlias","key","value","cleanKey","Boolean","pick","partial","chooseResolver","resolveToPick","charAt","resolver","j","isBoolean","isFunction","testFn","isObject","isArray","Object","prototype","toString","call","isString","isEmptyString","isNull","isNumber","isNumeric","pattern","match","isTruthy","isUndefined","undefined","not","identity","begin","valueSet","end","values","Array","shortCircuit","defaultValue","userFn","testValue","maybe","type","typeOkay","either","when","checkValue","eitherIf","predicateValue","safePredicate","eitherWhen","sanitizedFn","concat","original","extension","result","sanitizedExtension","i","length","push","basePartial","direction","appliedFunction","applicationArgs","reverseArgs","reverse","captureArguments","replace","split","countArguments","params","execute","rpartial","toValues","valueMap","finalArray","hasOwnProperty","conj","toDec","parseInt","copyArray","makeValueArray","dest","cons","source","each","userArray","sanitizedArray","filter","predicate","filterFn","find","finalValue","findFn","first","lastIndex","last","drop","index","finalIndex","sanitizedIndex","firstArray","secondArray","dropLast","map","mapFn","nth","rest","take","count","some","satisfied","someFn","contains","equal","every","everyFn","numberOf","accumulator","accumulate","naturalComparator","a","b","comparison","sort","optionValue","comparator","finalSet","union","set1","set2","compose","unique","buildValueHash","finalHash","intersect","seta","setbHash","difference","symmetricDifference","setUnion","setIntersection","dropFirst","init","pickResult","pluckKeys","keys","finalOutput","sanitizedKeys","sanitizedValueMap","captureValue","pluck","merge","defaultObj","mergeData","finalObj","argumentCount","appliedFn","recursor","recurFn","recursorFn","localRecursor","verifyRecurValue","recurValue","recur","recursingFn","reduce","initialState","initialValue","remainder","reducer","reduction","collection","ander","current","and","orer","or","xor","compositor","f","g","pipeline","finalValues","operator","partialReverse","partialAndReverse","deref","baseData","sanitizedDefault","keyTokens","derefValue","returnValue","compact","adder","add","divider","divide","multiplier","multiply","subtractor","subtract","rangeRecurCheck","m","n","inc","rangeBuilder","currentRange","finalRange","range","start","increment","mod","modulo","_a","_b","Math","floor","abs","truncate","max","maxValue","Number","MAX_VALUE","min","minValue","fac","factorial","greater","throwWhenNotComparable","TypeError","isNotUndefined","less","isEven","isPositive","isZero","isNegative","isInt","isNonNegative","isNonPositive","isNonZero","isOdd","geq","leq","module","exports"],"mappings":"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","sourcesContent":["var jfp = (function(){\n    'use strict';\n    \n    function resolveFunction(functionValue){\n        return typeof functionValue === 'string' ? jfp[functionValue] : functionValue;\n    }\n    \n    function curryAlias(){\n        var args = jfp.slice(0, arguments);\n\n        args[0] = resolveFunction(args[0]);\n        \n        return jfp.apply(jfp.curry, args);\n    }\n    \n    function pickAlias(key, value){\n        var cleanKey = key.slice(1);\n        \n        return Boolean(value) ? jfp.pick(cleanKey, value) : jfp.partial(jfp.pick, cleanKey);\n    }\n    \n    function chooseResolver(value){\n        var resolveToPick = typeof value === 'string' && value.charAt(0) === ':';\n        \n        return resolveToPick ? pickAlias : curryAlias;\n    }\n    \n    return function(){\n        var args = jfp.slice(0, arguments),\n            resolver = chooseResolver(args[0]);\n        \n        return jfp.apply(resolver, args);\n    };\n    \n})();\n\n(function(j){\n    'use strict';\n    \n    function isBoolean(value){\n        return typeof value === 'boolean';\n    }\n\n    function isFunction(testFn){\n        return typeof testFn === 'function';\n    }\n    \n    function isObject(value){\n        return (typeof value == 'object');\n    }\n    \n    function isArray(value){\n        return (isObject(value) && Object.prototype.toString.call(value) === '[object Array]');\n    }\n    \n    function isString(value){\n        return typeof value === 'string';\n    }\n\n    function isEmptyString(value){\n        return isString(value) && value === '';\n    }\n    \n    function isNull(value){\n        return value === null;\n    }\n    \n    function isNumber(value){\n        return typeof value === 'number';\n    }\n    \n    function isNumeric(value){\n        var pattern = /^(0x)?[0-9]+((\\.[0-9]+)|(e\\-?[0-9]+))?$/;\n        return isNumber(value) || (isString(value) && !!value.match(pattern));\n    }\n    \n    function isTruthy(value){\n        return !!value;\n    }\n    \n    function isUndefined(value){\n        return value === undefined;\n    }\n\n    function not(value){\n        return !value;\n    }\n\n    j.isArray = isArray;\n    j.isBoolean = isBoolean;\n    j.isEmptyString = isEmptyString;\n    j.isFunction = isFunction;\n    j.isNull = isNull;\n    j.isNumber = isNumber;\n    j.isNumeric = isNumeric;\n    j.isObject = isObject;\n    j.isString = isString;\n    j.isTruthy = isTruthy;\n    j.isUndefined = isUndefined;\n    j.not = not;\n\n})(jfp);\n\n\n(function(j){\n    'use strict';\n\n    function identity(value){\n        return value;\n    }\n\n    function slice(begin, valueSet, end){\n        var values = j.not(j.isTruthy(valueSet)) ? [] : valueSet;\n\n        return j.not(j.isTruthy(end)) ?\n                    Array.prototype.slice.call(values, begin) :\n                    Array.prototype.slice.call(values, begin, end);\n    }\n\n    function shortCircuit(defaultValue, userFn, testValue){\n        return (j.isTruthy(testValue) || testValue === 0) ?\n            userFn(testValue) :\n            defaultValue;\n    }\n\n    function maybe(value){\n        var type = arguments[1],\n            typeOkay = typeof value === type;\n\n        return typeOkay || (!type && !!value) ? value : null;\n    }\n\n    function either(defaultValue, testValue){\n        var type = arguments[2];\n        return maybe(testValue, type) === null ? defaultValue : testValue;\n    }\n\n    function apply(userFn, args){\n        return userFn.apply(null, args);\n    }\n\n    function when(checkValue, userFn){\n        var args = slice(2, arguments);\n        return j.isTruthy(checkValue) ? apply(userFn, args) : null;\n    }\n\n    function eitherIf(defaultValue, testValue, predicateValue){\n        var safePredicate = j.isUndefined(predicateValue) ? true : predicateValue;\n\n        return j.either(defaultValue, j.when(safePredicate, j.partial(j.identity, testValue)));\n    }\n\n    function eitherWhen(defaultValue, predicateValue, userFn){\n        var sanitizedFn = eitherIf(j.identity, userFn, j.isFunction(userFn));\n\n        return j.either(defaultValue, j.when(predicateValue, sanitizedFn));\n    }\n\n    function concat(original, extension){\n        var result = slice(0, either([], original)),\n            sanitizedExtension = either([], extension),\n            i;\n\n        //This is the most performant way to handle concatenation. Trust me.\n        for(i = 0; i < sanitizedExtension.length; i++){\n            result.push(sanitizedExtension[i]);\n        }\n\n        return result;\n    }\n\n    function basePartial(direction, userFn){\n        var args = slice(2, arguments);\n\n        return function appliedFunction(){\n            var applicationArgs = (direction === 'left') ?\n                                    concat(args, slice(0, arguments)) :\n                                    concat(slice(0, arguments), args);\n\n            return apply(userFn, applicationArgs);\n        };\n    }\n\n    function reverseArgs(userFn){\n        return function(){\n            var args = j.slice(0, arguments).reverse();\n            return j.apply(userFn, args);\n        };\n    }\n\n    function captureArguments(userFn){\n        return userFn.toString()\n            .replace(/((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/)|(\\s))/mg,'')\n            .match(/^function\\s*[^\\(]*\\(\\s*([^\\)]*)\\)/m)[1]\n            .split(/,/);\n    }\n\n    function countArguments(userFn){\n        var params = shortCircuit([], captureArguments, userFn);\n\n        params = (params.length === 1 && params[0] === '') ? [] : params;\n\n        return params.length;\n    }\n\n    function execute(userFn){\n        return j.apply(userFn, j.slice(1, arguments));\n    }\n\n    j.apply = apply;\n    j.concat = concat;\n    j.countArguments = countArguments;\n    j.either = either;\n    j.eitherIf = eitherIf;\n    j.eitherWhen = eitherWhen;\n    j.execute = execute;\n    j.identity = identity;\n    j.maybe = maybe;\n    j.partial = basePartial('left', basePartial, 'left');\n    j.reverseArgs = reverseArgs;\n    j.rpartial = basePartial('left', basePartial, 'right');\n    j.shortCircuit = shortCircuit;\n    j.slice = slice;\n    j.when = when;\n\n})(jfp);\n\n\n(function(j){\n    'use strict';\n\n    function toValues(valueMap){\n        var finalArray = [],\n            key;\n\n        j.when(j.isObject(valueMap), function(){\n            for(key in valueMap){\n                if(valueMap.hasOwnProperty(key) && j.isTruthy(valueMap[key])){\n                    finalArray = j.conj(valueMap[key], finalArray);\n                }\n            }\n        });\n\n        return j.either(null, j.when(j.isObject(valueMap), function(){ return finalArray; }));\n    }\n\n    function toDec(value){\n        return (j.isNumeric(value)) ? parseInt(value, 10) : null;\n    }\n\n    j.toDec = toDec;\n    j.toValues = toValues;\n\n})(jfp);\n\n(function(j){\n    'use strict';\n\n    function copyArray(valueSet){\n        return j.slice(0, valueSet);\n    }\n\n    function makeValueArray(value){\n        return j.not(j.isUndefined(value)) ? [value] : [];\n    }\n\n    function conj(value, dest){\n        return j.concat(copyArray(dest), makeValueArray(value));\n    }\n\n    function cons(value, source){\n        return j.concat(makeValueArray(value), source);\n    }\n\n    function each(userFn, userArray){\n        var sanitizedArray = j.either([], userArray),\n            sanitizedFn = j.either(j.identity, userFn),\n            i;\n\n        for(i = 0; i < sanitizedArray.length; i++){\n            if(sanitizedFn(sanitizedArray[i], i) === false){\n                break;\n            }\n        }\n\n        return sanitizedArray;\n    }\n\n    function filter(predicate, userArray){\n        var result = [];\n\n        function filterFn(value){\n            j.when(predicate(value), function(){\n                result = conj(value, result);\n            });\n        }\n\n        each(filterFn, userArray);\n\n        return result;\n    }\n\n    function find(predicate, valueSet){\n        var finalValue = null;\n\n        function findFn(value){\n            return j.not(j.when(predicate(value), function(){\n                            finalValue = value;\n                            return true;\n                         }));\n        }\n\n        each(findFn, j.either([], valueSet));\n\n        return finalValue;\n    }\n\n    function first(values){\n        return j.isArray(values) ? j.either(null, values[0]) : null;\n    }\n\n    function lastIndex(values){\n        return j.isArray(values) ? values.length - 1 : null;\n    }\n\n    function last(values){\n        return j.isArray(values) ? values[lastIndex(values)] : null;\n    }\n\n    function drop(index, valueSet){\n        var finalIndex = lastIndex(valueSet),\n\n            sanitizedIndex = (index === 0 || index === finalIndex) ?\n                index : j.either(1, index) - 1,\n\n            firstArray = (sanitizedIndex === 0) ?\n                [] : j.slice(0, valueSet, sanitizedIndex),\n\n            secondArray = (sanitizedIndex === finalIndex)?\n                [] : j.slice(sanitizedIndex + 1, valueSet);\n\n        return j.concat(firstArray, secondArray);\n    }\n\n    function dropLast(valueSet){\n        return drop(lastIndex(valueSet), valueSet);\n    }\n\n    function map(userFn, userArray){\n        var finalArray = [];\n\n        function mapFn(value){\n            finalArray = conj(userFn(value), finalArray);\n        }\n\n        each(mapFn, userArray);\n\n        return finalArray;\n    }\n\n    function nth(index, valueSet){\n        return j.either(null, j.either([], valueSet)[index]);\n    }\n\n    function rest(values){\n        return j.slice(1, values);\n    }\n\n    function take(count, values){\n        return j.isArray(values) ? j.slice(0, values, count) : null;\n    }\n\n    function some(predicate, valueSet){\n        var satisfied = false;\n\n        function someFn(value, index){\n            satisfied = predicate(value, index);\n            return !satisfied;\n        }\n\n        each(someFn, valueSet);\n\n        return satisfied;\n    }\n\n    function contains(value, valueSet){\n        return some(j.partial(j.equal, value), valueSet);\n    }\n\n    function every(predicate, valueSet){\n        var satisfied = false;\n\n        function everyFn(value, index){\n            satisfied = predicate(value, index);\n            return satisfied;\n        }\n\n        each(everyFn, valueSet);\n\n        return satisfied;\n    }\n\n    function numberOf(predicate, valueSet){\n        var accumulator = 0;\n\n        function accumulate(value){\n            accumulator += predicate(value) ? 1 : 0;\n        }\n\n        each(accumulate, valueSet);\n\n        return accumulator;\n    }\n\n    function naturalComparator(a, b){\n        var comparison = a < b ? -1 : 1;\n        return a === b ? 0 : comparison;\n    }\n\n    function sort(optionValue, valueSet){\n        var comparator = j.isFunction(optionValue) ? optionValue : naturalComparator,\n            finalSet = j.isArray(optionValue) ? j.slice(0, optionValue) : j.slice(0, valueSet);\n\n        return finalSet.sort(comparator);\n    }\n\n    function union(set1, set2){\n        return j.compose(j.unique, j.concat)(set1, set2);\n    }\n\n    function buildValueHash(valueSet){\n        var finalHash = {};\n\n        j.each(function(value){\n            finalHash[value] = true;\n        }, valueSet);\n\n        return finalHash;\n    }\n\n    function intersect(set1, set2){\n        var finalSet = [],\n            seta = j.unique(j.either([], set1)),\n            setbHash = buildValueHash(j.either([], set2)),\n            i = 0;\n\n        for(; i < seta.length; i++){\n            if(setbHash[seta[i]]){\n                finalSet.push(seta[i]);\n            }\n        }\n\n        return finalSet;\n    }\n\n    function difference(set1, set2){\n        var finalSet = [],\n            seta = j.unique(j.either([], set1)),\n            setbHash = buildValueHash(j.either([], set2)),\n            i = 0;\n\n        for(; i < seta.length; i++){\n            if(!setbHash[seta[i]]){\n                finalSet.push(seta[i]);\n            }\n        }\n\n        return finalSet;\n    }\n\n    function symmetricDifference(set1, set2){\n        var setUnion = union(set1, set2),\n            setIntersection = intersect(set1, set2);\n\n        return difference(setUnion, setIntersection);\n    }\n\n    j.conj = conj;\n    j.cons = cons;\n    j.contains = contains;\n    j.copyArray = copyArray;\n    j.difference = difference;\n    j.drop = drop;\n    j.dropFirst = j.partial(drop, 0);\n    j.dropLast = dropLast;\n    j.each = each;\n    j.every = every;\n    j.filter = filter;\n    j.find = find;\n    j.first = first;\n    j.init = j.dropLast;\n    j.intersect = intersect;\n    j.last = last;\n    j.lastIndex = lastIndex;\n    j.map = map;\n    j.nth = nth;\n    j.numberOf = numberOf;\n    j.rest = rest;\n    j.sort = sort;\n    j.some = some;\n    j.symmetricDifference = symmetricDifference;\n    j.take = take;\n    j.union = union;\n\n})(jfp);\n\n\n(function(j){\n    'use strict';\n\n    function pick(key, valueMap){\n        var pickResult = j.either({}, valueMap)[key];\n        return j.isUndefined(pickResult) ? null : pickResult;\n    }\n\n    function pluckKeys(keys, valueMap){\n        var finalOutput = {},\n            sanitizedKeys = j.either([], keys),\n            sanitizedValueMap = j.either({}, valueMap);\n\n        function captureValue(key){\n            finalOutput[key] = sanitizedValueMap[key];\n        }\n\n        j.each(captureValue, sanitizedKeys);\n\n        return finalOutput;\n    }\n\n    function pluck(key, valueMap){\n        return pluckKeys([key], valueMap);\n    }\n\n    function merge(defaultObj, mergeData){\n        var finalObj = {},\n            key;\n\n        for(key in j.either({}, defaultObj)){\n            finalObj[key] = defaultObj[key];\n        }\n\n        for(key in j.either({}, mergeData)){\n            finalObj[key] = mergeData[key];\n        }\n\n        return j.eitherIf(null, finalObj, j.isTruthy(defaultObj));\n    }\n\n    j.merge = merge;\n    j.pick = pick;\n    j.pluck = pluck;\n    j.pluckKeys = pluckKeys;\n\n})(jfp);\n\n\n(function(j){\n    'use strict';\n\n    //This is complicated and I don't expect people to grok it on first read.\n    function curry(userFn){\n        var args = j.slice(1, arguments),\n            argumentCount = j.shortCircuit(0, j.countArguments, userFn),\n            appliedFn = (args.length < argumentCount) ? j.apply(j.partial, j.concat([curry, userFn], args)) : null,\n            result = (!!userFn && args.length >= argumentCount) ? j.apply(userFn, args) : null;\n\n        return j.either(appliedFn, result);\n    }\n\n    //zOMG! TAIL RECURSION\n    function recursor(recurFn){\n        var args = j.slice(1, arguments);\n\n        //This is to make the returned function distinct and identifiable.\n        return function recursorFn(localRecursor){\n            return j.apply(recurFn, j.concat([localRecursor], args));\n        };\n    }\n\n    function verifyRecurValue(recurValue){\n        return typeof recurValue === 'function' &&\n            recurValue.toString().match('recursorFn');\n    }\n\n    //Tail optimization with managed recursion is really complicated.\n    //Please don't muck with this unless you TRULY understand what is happening.\n    function recur(userFn){\n        var recursingFn = j.either(j.identity, userFn),\n            localRecursor = j.partial(recursor, recursingFn),\n            recurValue = j.apply(localRecursor, j.slice(1, arguments));\n\n        while(verifyRecurValue(recurValue = recurValue(localRecursor)) && recursingFn !== j.identity);\n\n        return recurValue;\n    }\n\n    function reduce(userFn, values, initialState){\n        var initialValue = j.either(j.first(values), initialState),\n            remainder = initialValue === initialState ? values : j.rest(values);\n            \n        function reducer(recur, reduction, collection){\n            return (collection.length) ?\n                recur(userFn(reduction, j.first(collection)), j.rest(collection)) :\n                reduction;\n        }\n\n        return (!!values && values.length > 0) ? recur(reducer, initialValue, remainder) : null;\n    }\n\n    //Performs 'and' operation on valueSet\n    function ander(recur, current, valueSet){\n        return (valueSet.length === 0) ?\n            current :\n            recur(current && !!j.first(valueSet), j.rest(valueSet));\n    }\n\n    function and(){\n        return recur(ander, true, j.slice(0, arguments));\n    }\n\n    //Performs 'or' operation on valueSet\n    function orer(recur, current, valueSet){\n        return (valueSet.length === 0) ?\n            current :\n            recur(current || !!j.first(valueSet), j.rest(valueSet));\n    }\n\n    function or(){\n        return recur(orer, false, j.slice(0, arguments));\n    }\n\n    function xor(a, b){\n        return !!(or(a, b) && j.not(j.isTruthy(a) === j.isTruthy(b)));\n    }\n\n    //Produces a function that returns f(g(x))\n    function compositor(f, g){\n        return function(){\n            return f(j.apply(g, j.slice(0, arguments)));\n        };\n    }\n\n    function compose(){\n        var args = j.slice(0, arguments);\n        return (args.length >= 1) ? reduce(compositor, args) : j.identity;\n    }\n\n    function pipeline(value){\n        return j.apply(compose, j.slice(1, arguments).reverse())(value);\n    }\n\n    function unique(valueSet){\n        var values = j.slice(0, valueSet).sort(),\n            finalValues = [];\n\n        function operator(value){\n            finalValues = j.eitherIf(finalValues,\n                                     j.conj(value, finalValues),\n                                     j.compose(j.not,\n                                               j.partial(j.equal, value),\n                                               j.last)(finalValues));\n        }\n\n        j.each(operator, values);\n\n        return finalValues;\n    }\n\n    function partialReverse(){\n        var args = j.slice(0, arguments),\n            partialAndReverse = j.compose(j.reverseArgs, j.partial);\n            \n        return j.apply(partialAndReverse, args);\n    }\n\n    function deref(baseData, key, defaultValue){\n        var sanitizedDefault = j.either(null, defaultValue),\n            keyTokens = j.either('', key).split('.'),\n            derefValue = j.reduce(j.reverseArgs(j.pick), keyTokens, baseData),\n            returnValue = Boolean(key) ? derefValue : baseData;\n        \n        returnValue = !Boolean(baseData) ? null : returnValue;\n        \n        return returnValue === null ? sanitizedDefault : returnValue;\n    }\n\n    j.and = and;\n    j.compact = j.partial(j.filter, j.isTruthy);\n    j.compose = compose;\n    j.curry = curry;\n    j.deref = deref;\n    j.or = or;\n    j.partialReverse = partialReverse;\n    j.pipeline = pipeline;\n    j.recur = recur;\n    j.reduce = reduce;\n    j.unique = unique;\n    j.xor = xor;\n\n})(jfp);\n\n\n(function(j){\n    'use strict';\n\n//This is a recursive add fn\n    function adder(recur, current, valueSet){\n        return (valueSet.length === 0) ?\n                current :\n                recur(current + j.first(valueSet), j.rest(valueSet));\n    }\n    \n    function add(a, b){\n        return j.recur(adder, 0, j.slice(0, arguments));\n    }\n    \n    //This is a recursive divide fn\n    function divider(recur, current, valueSet){\n        return (valueSet.length === 0) ?\n                current :\n                recur(current / j.first(valueSet), j.rest(valueSet));\n    }\n    \n    function divide(){\n        var args = j.slice(0, arguments),\n            first = args.length ? j.first(args) : 1;\n        return j.recur(divider, first, j.rest(args));\n    }\n    \n    //This is a recursive multiply fn\n    function multiplier(recur, current, valueSet){\n        return (valueSet.length === 0) ?\n                current :\n                recur(current * j.first(valueSet), j.rest(valueSet));\n    }\n    \n    function multiply(){\n        return j.recur(multiplier, 1, j.slice(0, arguments));\n    }\n    \n    //This is a recursive subtraction fn\n    function subtractor(recur, current, valueSet){\n        return (valueSet.length === 0) ?\n                current :\n                recur(current - j.first(valueSet), j.rest(valueSet));\n    }\n    \n    function subtract(){\n        var args = j.slice(0, arguments),\n            first = args.length ? j.first(args) : 0;\n        return j.recur(subtractor, first, j.rest(args));\n    }\n\n    //This is a recursive constructor function for ranges\n    function rangeRecurCheck(m, n, inc){\n        return inc > 0 ? (m + inc) < n : (m + inc) > n;\n    }\n\n    function rangeBuilder(recur, currentRange, m, n, inc){\n        var finalRange = rangeRecurCheck(m - inc, n, inc) ?\n                            j.conj(m, currentRange) :\n                            currentRange;\n        \n        return rangeRecurCheck(m, n, inc) ?\n                recur(finalRange, m + inc, n, inc) :\n                finalRange;\n    }\n    \n    function range(a, b, inc){\n        var start = j.isUndefined(b) ? 0 : a,\n            end = j.isUndefined(b) ? j.either(0, a) : b,\n            increment = (!inc) ? 1 : inc;\n            \n        return j.recur(rangeBuilder,\n                       [],\n                       j.either(0, start),\n                       j.either(0, end),\n                       increment);\n    }\n\n    function mod(a, b){\n        return j.isUndefined(b) ? j.either(0, a) : a%b;\n    }\n\n    function modulo(a, b){\n        var _a = j.either(0, a),\n            _b = j.either(0, b);\n\n        return (_a > 0) ? mod(_a, _b) : _b * (Math.floor(Math.abs(_a)/_b) + 1) + _a;\n    }\n\n    function truncate(value){\n        return (value > 0) ? Math.floor(value) : Math.floor(value) + 1;\n    }\n    \n    function max(a, b){\n        var maxValue = -Number.MAX_VALUE,\n            _a = j.isUndefined(a) ? maxValue : a,\n            _b = j.isUndefined(b) ? maxValue : b;\n            \n        maxValue = (_a > maxValue) ? _a : maxValue;\n        maxValue = (_b > maxValue) ? _b : maxValue;\n        \n        return maxValue;\n    }\n    \n    function min(a, b){\n        var minValue = Number.MAX_VALUE,\n            _a = j.isUndefined(a) ? minValue : a,\n            _b = j.isUndefined(b) ? minValue : b;\n        \n        minValue = (_a < minValue) ? _a : minValue;\n        minValue = (_b < minValue) ? _b : minValue;\n        \n        return minValue;\n    }\n\n    function fac(value){\n        var factorial = j.compose(j.partial(j.reduce, multiply),\n                                  j.partial(range, 1),\n                                  j.partial(add, 1));\n\n        return j.either(1, j.when(j.greater(value, 0), factorial, value));\n    }\n\n    j.add = add;\n    j.divide = divide;\n    j.fac = fac;\n    j.inc = j.partial(j.add, 1);\n    j.max = max;\n    j.min = min;\n    j.mod = mod;\n    j.modulo = modulo;\n    j.multiply = multiply;\n    j.range = range;\n    j.subtract = subtract;\n    j.truncate = truncate;\n\n})(jfp);\n\n\n(function(j){\n\n    function throwWhenNotComparable(a, b){\n        j.when(j.isUndefined(a) || j.isUndefined(b), function(){\n            throw new TypeError('Inequality comparisons require two values');\n        });\n    }\n\n    function equal(a, b){\n        var isNotUndefined = j.compose(j.not, j.isUndefined);\n        return (isNotUndefined(a) && isNotUndefined(b)) ? a === b : false;\n    }\n\n    function greater(a, b){\n        throwWhenNotComparable(a, b);\n        return a > b;\n    }\n\n    function less(a, b){\n        throwWhenNotComparable(a, b);\n        return a < b;\n    }\n\n    function isEven(value){\n        return equal(0, j.mod(value, 2));\n    }\n\n    function isPositive(value){\n        return greater(value, 0);\n    }\n\n    function isZero(value){\n        return value === 0;\n    }\n\n    function isNegative(value){\n        return j.compose(j.not, j.or)(isPositive(value), isZero(value));\n    }\n\n    function isInt(value){\n        return equal(j.truncate(value), value);\n    }\n\n    j.isEven = isEven;\n    j.isInt = isInt;\n    j.isNegative = isNegative;\n    j.isNonNegative = j.compose(j.not, isNegative);\n    j.isNonPositive = j.compose(j.not, isPositive);\n    j.isNonZero = j.compose(j.not, isZero);\n    j.isOdd = j.compose(j.not, isEven);\n    j.isPositive = isPositive;\n    j.isZero = isZero;\n\n    //Special case predicate naming is intended for these functions\n    //There is a general expectation that these not be named with 'is'\n    j.equal = equal;\n    j.geq = j.compose(j.not, less);\n    j.greater = greater;\n    j.leq = j.compose(j.not, greater);\n    j.less = less;\n\n})(jfp);\n\nvar j = jfp;\n\nif(typeof module !== 'undefined' && !!module.exports){\n    module.exports = j;\n}\n\n\n"]}