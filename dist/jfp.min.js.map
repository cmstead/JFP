{"version":3,"file":"jfp.min.js","sources":["jfp.js"],"names":["jfp","resolveFunction","functionValue","curryAlias","args","slice","arguments","apply","curry","pickAlias","key","value","cleanKey","Boolean","pick","partial","chooseResolver","resolveToPick","charAt","resolver","j","isUndefined","undefined","not","equal","a","b","missingValues","isType","typeString","getType","isNumeric","pattern","number","numericString","match","isTruthy","typeCheckReduction","result","isPrimitive","primitiveNames","reduce","bind","isTuple","size","list","length","hasFirst","either","isEmptyString","isNull","isArray","isBoolean","isFunction","isNumber","isObject","isString","isPair","isSingle","isTriple","identity","valueType","Object","prototype","toString","call","empty","array","boolean","null","object","string","begin","valueSet","end","values","Array","maybe","type","typeOkay","defaultValue","testValue","always","output","shortCircuit","fn","optionValue","userFn","when","checkValue","eitherIf","predicateValue","safePredicate","eitherWhen","sanitizedFn","concat","original","extension","sanitizedExtension","i","push","basePartial","direction","appliedFunction","applicationArgs","splitPartial","baseFn","left","right","leftApplied","reverseArgs","reverse","countArguments","execute","rpartial","toDec","parseInt","copyArray","makeValueArray","conj","dest","cons","source","first","lastIndex","last","drop","index","finalIndex","sanitizedIndex","firstArray","secondArray","dropLast","nth","rest","take","count","naturalComparator","comparison","sort","comparator","finalSet","each","userArray","sanitizedArray","dropFirst","init","valueMap","pickResult","getKeys","obj","keys","mergeValue","dataObj","mergedObj","merge","baseObj","mergeData","finalObj","argumentCount","appliedFn","recursor","recurFn","recursorFn","localRecursor","verifyRecurValue","recurValue","recur","recursingFn","reducer","reduction","collection","appliedReducer","initialState","hasInitialState","initialValue","remainder","compositor","f","g","$f","$g","compositeFn","compose","pipeline","partialReverse","clone","originalValue","depth","depthOkay","geq","copyOkay","copy","container","newDepth","err","RangeError","maybeType","eitherType","mapper","finalArray","map","mapperFn","filterer","userPredicate","filter","predicate","filterFn","compact","valueList","predicateAccumulator","total","sanitizedTotal","numberOf","accumulator","captureUnique","finalList","unique","union","set1","set2","addToHash","finalObject","buildValueHash","captureIntersection","valueHash","intersect","setHash","captureDifference","difference","symmetricDifference","setUnion","setIntersection","everyReducer","every","finder","done","find","someRecur","some","contains","partitioner","partitions","partition","sanitizedPredicate","multiPartitioner","partitionPredicate","computedPartitions","multiPartition","predicateArgs","sanitizedArgs","sanitizedList","firstExists","ander","orer","reduceConditions","conditionArgs","operator","initialCondition","and","or","xor","equivalent","cond","conditionPair","truthy","behavior","cleanConditionPairs","conditionPairs","error","Error","notEmpty","matchToCond","condition","newPair","composePredicate","predicateFn","combinator","predicateList","executor","keyReduction","toValues","dereferencer","dataObject","token","trim","internalDeref","baseData","sanitizedDefault","keyTokens","split","deref","sanitizedKey","sanitizedData","plucker","pluckKeys","sanitizedObject","pluck","transformer","transformation","transform","adder","current","add","divider","divide","multiplier","multiply","subtractor","subtract","rangeRecurCheck","m","n","inc","rangeBuilder","currentRange","finalRange","range","start","increment","mod","modulo","_a","_b","Math","floor","abs","truncate","max","maxValue","Number","MAX_VALUE","min","minValue","fac","factorial","greater","throwWhenNotComparable","TypeError","less","isInt","isMultipleOf","base","test","isNegative","isPositive","isZero","isEven","isNonNegative","isNonPositive","isNonZero","isOdd","leq","attachFunction","module","addModule","provider","moduleKeys","exports","define","amd"],"mappings":"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","sourcesContent":["var jfp = (function(){\r\n    'use strict';\r\n    \r\n    function resolveFunction(functionValue){\r\n        return typeof functionValue === 'string' ? jfp[functionValue] : functionValue;\r\n    }\r\n    \r\n    function curryAlias(){\r\n        var args = jfp.slice(0, arguments);\r\n\r\n        args[0] = resolveFunction(args[0]);\r\n        \r\n        return jfp.apply(jfp.curry, args);\r\n    }\r\n    \r\n    function pickAlias(key, value){\r\n        var cleanKey = key.slice(1);\r\n        \r\n        return Boolean(value) ? jfp.pick(cleanKey, value) : jfp.partial(jfp.pick, cleanKey);\r\n    }\r\n    \r\n    function chooseResolver(value){\r\n        var resolveToPick = typeof value === 'string' && value.charAt(0) === ':';\r\n        \r\n        return resolveToPick ? pickAlias : curryAlias;\r\n    }\r\n    \r\n    return function(){\r\n        var args = jfp.slice(0, arguments),\r\n            resolver = chooseResolver(args[0]);\r\n        \r\n        return jfp.apply(resolver, args);\r\n    };\r\n    \r\n})();\r\n\r\n(function(j){\r\n    'use strict';\r\n\r\n    function isUndefined(value){\r\n        return value === undefined;\r\n    }\r\n    \r\n    function not(value){\r\n        return !Boolean(value);\r\n    }\r\n    \r\n    function equal (a, b) {\r\n        var missingValues = isUndefined(a) || isUndefined(b);\r\n        return not(missingValues) && a === b;\r\n    }\r\n\r\n    function isType (typeString, value) {\r\n        return j.equal(j.getType(value), typeString);\r\n    }\r\n    \r\n    function isNumeric(value){\r\n        var pattern = /^(0x)?[0-9]+((\\.[0-9]+)|(e\\-?[0-9]+))?$/,\r\n            number = isType('number', value),\r\n            numericString = isType('string', value) && Boolean(value.match(pattern));\r\n            \r\n        return number || numericString;\r\n    }\r\n    \r\n    function isTruthy(value){\r\n        return Boolean(value);\r\n    }\r\n    \r\n    function typeCheckReduction (value, result, typeString){\r\n        return result || isType(typeString, value);\r\n    }\r\n    \r\n    function isPrimitive (value) {\r\n        var primitiveNames = ['number',\r\n                              'string',\r\n                              'boolean',\r\n                              'undefined'];\r\n\r\n        return primitiveNames.reduce(typeCheckReduction.bind(null, value), equal(null, value));\r\n    }\r\n\r\n    function isTuple (size, list) {\r\n        return isType('array', list) && list.length === size;\r\n    }\r\n    \r\n    function hasFirst (list) {\r\n        return not(isUndefined(j.either([], list, 'array')[0]));\r\n    }\r\n\r\n    // Equality\r\n    j.equal = equal;\r\n    j.isEmptyString = equal.bind(null, '');\r\n    j.isNull = equal.bind(null, null);\r\n\r\n    // Types\r\n    j.isType = isType;\r\n    j.isArray = isType.bind(null, 'array');\r\n    j.isBoolean = isType.bind(null, 'boolean');\r\n    j.isFunction = isType.bind(null, 'function');\r\n    j.isNumber = isType.bind(null, 'number');\r\n    j.isObject = isType.bind(null, 'object');\r\n    j.isString = isType.bind(null, 'string');\r\n    j.isUndefined = isType.bind(null, 'undefined');\r\n\r\n    // Tuples\r\n    j.isTuple = isTuple;\r\n    j.isPair = isTuple.bind(null, 2);\r\n    j.isSingle = isTuple.bind(null, 1);\r\n    j.isTriple = isTuple.bind(null, 3);\r\n\r\n    //Other predicates\r\n    j.hasFirst = hasFirst;\r\n    j.isNumeric = isNumeric;\r\n    j.isPrimitive = isPrimitive;\r\n    j.isTruthy = isTruthy;\r\n    j.not = not;\r\n\r\n})(jfp);\r\n\r\n\r\n(function(j){\r\n    'use strict';\r\n\r\n    function identity(value){\r\n        return value;\r\n    }\r\n\r\n    function getType (value) {\r\n        var valueType = typeof value,\r\n            isArray = valueType === 'object' && Object.prototype.toString.call(value) === '[object Array]';\r\n            \r\n        return isArray ? 'array' : valueType;\r\n    }\r\n\r\n    function empty (typeString) {\r\n        return {\r\n                array: [],\r\n                boolean: false,\r\n                'null': null,\r\n                number: 0,\r\n                object: {},\r\n                string: ''\r\n            }[typeString];\r\n    }\r\n\r\n    function slice(begin, valueSet){\r\n        var end = arguments[2],\r\n            values = j.not(j.isTruthy(valueSet)) ? [] : valueSet;\r\n\r\n        return j.not(j.isTruthy(end)) ?\r\n                    Array.prototype.slice.call(values, begin) :\r\n                    Array.prototype.slice.call(values, begin, end);\r\n    }\r\n\r\n    function maybe(value){\r\n        var type = arguments[1],\r\n            valueType = getType(value),\r\n            typeOkay = valueType === type || valueType === 'array' && type === 'object';\r\n        \r\n        return typeOkay || (!type && Boolean(value)) ? value : null;\r\n    }\r\n\r\n    function either(defaultValue, testValue){\r\n        var type = arguments[2];\r\n        return maybe(testValue, type) === null ? defaultValue : testValue;\r\n    }\r\n    \r\n    function always (value) {\r\n        var output = getType(value) === 'undefined' ? null : value;\r\n        return identity.bind(null, output);\r\n    }\r\n\r\n    function shortCircuit(defaultValue, fn, optionValue){\r\n        var type = optionValue === 0 ? 'number' : arguments[3];\r\n        return maybe(optionValue, type) !== null ? fn(optionValue) : defaultValue;\r\n    }\r\n\r\n    function apply(userFn, args){\r\n        return userFn.apply(null, args);\r\n    }\r\n\r\n    function when(checkValue, userFn){\r\n        var args = slice(2, arguments);\r\n        return j.isTruthy(checkValue) ? apply(userFn, args) : null;\r\n    }\r\n\r\n    function eitherIf(defaultValue, testValue, predicateValue){\r\n        var safePredicate = j.isUndefined(predicateValue) ? true : predicateValue;\r\n\r\n        return j.either(defaultValue, j.when(safePredicate, j.partial(j.identity, testValue)));\r\n    }\r\n\r\n    function eitherWhen(defaultValue, predicateValue, userFn){\r\n        var sanitizedFn = eitherIf(j.identity, userFn, j.isFunction(userFn));\r\n\r\n        return j.either(defaultValue, j.when(predicateValue, sanitizedFn));\r\n    }\r\n\r\n    function concat(original, extension){\r\n        var result = slice(0, either([], original)),\r\n            sanitizedExtension = either([], extension),\r\n            i;\r\n\r\n        //This is the most performant way to handle concatenation. Trust me.\r\n        for(i = 0; i < sanitizedExtension.length; i++){\r\n            result.push(sanitizedExtension[i]);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    function basePartial(direction, userFn){\r\n        var args = slice(2, arguments);\r\n\r\n        return function appliedFunction(){\r\n            var applicationArgs = (direction === 'left') ?\r\n                                    concat(args, slice(0, arguments)) :\r\n                                    concat(slice(0, arguments), args);\r\n\r\n            return apply(userFn, applicationArgs);\r\n        };\r\n    }\r\n\r\n    function splitPartial (baseFn, left, right) {\r\n        var leftApplied = apply(basePartial, concat(['left', baseFn], left));\r\n        return apply(basePartial, concat(['right', leftApplied], right));\r\n    }\r\n\r\n    function reverseArgs(userFn){\r\n        return function(){\r\n            var args = j.slice(0, arguments).reverse();\r\n            return j.apply(userFn, args);\r\n        };\r\n    }\r\n\r\n    function countArguments(userFn){\r\n        return either(function(){}, userFn).length;\r\n    }\r\n\r\n    function execute(userFn){\r\n        return j.apply(userFn, j.slice(1, arguments));\r\n    }\r\n    \r\n    j.always = always;\r\n    j.apply = apply;\r\n    j.concat = concat;\r\n    j.countArguments = countArguments;\r\n    j.either = either;\r\n    j.eitherIf = eitherIf;\r\n    j.eitherWhen = eitherWhen;\r\n    j.empty = empty;\r\n    j.execute = execute;\r\n    j.getType = getType;\r\n    j.identity = identity;\r\n    j.maybe = maybe;\r\n    j.partial = basePartial('left', basePartial, 'left');\r\n    j.reverseArgs = reverseArgs;\r\n    j.rpartial = basePartial('left', basePartial, 'right');\r\n    j.shortCircuit = shortCircuit;\r\n    j.slice = slice;\r\n    j.splitPartial = splitPartial;\r\n    j.when = when;\r\n\r\n})(jfp);\r\n\r\n\r\n(function(j){\r\n    'use strict';\r\n\r\n    function toDec(value){\r\n        return (j.isNumeric(value)) ? parseInt(value, 10) : null;\r\n    }\r\n\r\n    j.toDec = toDec;\r\n\r\n})(jfp);\r\n\r\n(function(j){\r\n    'use strict';\r\n\r\n    function copyArray(valueSet){\r\n        return j.slice(0, valueSet);\r\n    }\r\n\r\n    function makeValueArray(value){\r\n        return j.not(j.isUndefined(value)) ? [value] : [];\r\n    }\r\n\r\n    function conj(value, dest){\r\n        return j.concat(copyArray(dest), makeValueArray(value));\r\n    }\r\n\r\n    function cons(value, source){\r\n        return j.concat(makeValueArray(value), source);\r\n    }\r\n\r\n    function first(values){\r\n        return j.isArray(values) ? j.either(null, values[0]) : null;\r\n    }\r\n\r\n    function lastIndex(values){\r\n        return j.isArray(values) ? values.length - 1 : null;\r\n    }\r\n\r\n    function last(values){\r\n        return j.isArray(values) ? values[lastIndex(values)] : null;\r\n    }\r\n\r\n    function drop(index, valueSet){\r\n        var finalIndex = lastIndex(valueSet),\r\n\r\n            sanitizedIndex = (index === 0 || index === finalIndex) ?\r\n                index : j.either(1, index) - 1,\r\n\r\n            firstArray = (sanitizedIndex === 0) ?\r\n                [] : j.slice(0, valueSet, sanitizedIndex),\r\n\r\n            secondArray = (sanitizedIndex === finalIndex)?\r\n                [] : j.slice(sanitizedIndex + 1, valueSet);\r\n\r\n        return j.concat(firstArray, secondArray);\r\n    }\r\n\r\n    function dropLast(valueSet){\r\n        return drop(lastIndex(valueSet), valueSet);\r\n    }\r\n\r\n    function nth(index, valueSet){\r\n        return j.either(null, j.either([], valueSet)[index]);\r\n    }\r\n\r\n    function rest(values){\r\n        return j.slice(1, values);\r\n    }\r\n\r\n    function take(count, values){\r\n        return j.isArray(values) ? j.slice(0, values, count) : null;\r\n    }\r\n\r\n    function naturalComparator(a, b){\r\n        var comparison = a < b ? -1 : 1;\r\n        return a === b ? 0 : comparison;\r\n    }\r\n\r\n    function sort(optionValue, valueSet){\r\n        var comparator = j.isFunction(optionValue) ? optionValue : naturalComparator,\r\n            finalSet = j.isArray(optionValue) ? j.slice(0, optionValue) : j.slice(0, valueSet);\r\n\r\n        return finalSet.sort(comparator);\r\n    }\r\n\r\n    function each(userFn, userArray){\r\n        var sanitizedArray = j.either([], userArray),\r\n            sanitizedFn = j.either(j.identity, userFn),\r\n            i;\r\n\r\n        for(i = 0; i < sanitizedArray.length; i++){\r\n            if(sanitizedFn(sanitizedArray[i], i) === false){\r\n                break;\r\n            }\r\n        }\r\n\r\n        return sanitizedArray;\r\n    }\r\n\r\n    j.conj = conj;\r\n    j.cons = cons;\r\n    j.copyArray = copyArray;\r\n    j.drop = drop;\r\n    j.dropFirst = j.partial(drop, 0);\r\n    j.dropLast = dropLast;\r\n    j.each = each;\r\n    j.first = first;\r\n    j.init = j.dropLast;\r\n    j.last = last;\r\n    j.lastIndex = lastIndex;\r\n    j.nth = nth;\r\n    j.rest = rest;\r\n    j.sort = sort;\r\n    j.take = take;\r\n\r\n})(jfp);\r\n\r\n\r\n(function(j){\r\n    'use strict';\r\n\r\n    function pick(key, valueMap){\r\n        var pickResult = j.either({}, valueMap)[key];\r\n        return j.isUndefined(pickResult) ? null : pickResult;\r\n    }\r\n\r\n    function getKeys (obj) {\r\n        return Object.keys(j.either({}, obj, 'object'));\r\n    }\r\n\r\n    function mergeValue (dataObj, mergedObj, key) {\r\n        mergedObj[key] = dataObj[key];\r\n        return mergedObj;\r\n    }\r\n\r\n    function merge(baseObj, mergeData){\r\n        var finalObj = null;\r\n        \r\n        if (j.maybe(baseObj) !== null) {\r\n            finalObj = getKeys(baseObj).reduce(j.partial(mergeValue, baseObj), {});\r\n            finalObj = getKeys(mergeData).reduce(j.partial(mergeValue, mergeData), finalObj);\r\n        }\r\n\r\n        return finalObj;\r\n    }\r\n\r\n    j.getKeys = getKeys;\r\n    j.merge = merge;\r\n    j.pick = pick;\r\n\r\n})(jfp);\r\n\r\n\r\n(function(j){\r\n    'use strict';\r\n\r\n    //This is complicated and I don't expect people to grok it on first read.\r\n    function curry(userFn){\r\n        var args = j.slice(1, arguments),\r\n            argumentCount = j.countArguments(userFn),\r\n            appliedFn = (args.length < argumentCount) ? j.apply(j.partial, j.concat([curry, userFn], args)) : null,\r\n            result = (Boolean(userFn) && args.length >= argumentCount) ? j.apply(userFn, args) : null;\r\n\r\n        return j.either(appliedFn, result);\r\n    }\r\n\r\n    //zOMG! TAIL OPTIMIZED RECURSION\r\n    function recursor(recurFn){\r\n        var args = j.slice(1, arguments);\r\n\r\n        //This is to make the returned function distinct and identifiable.\r\n        return function recursorFn(localRecursor){\r\n            return j.apply(recurFn, j.concat([localRecursor], args));\r\n        };\r\n    }\r\n\r\n    function verifyRecurValue(recurValue){\r\n        return typeof recurValue === 'function' &&\r\n            recurValue.toString().match('recursorFn');\r\n    }\r\n\r\n    //Tail optimization with managed recursion is really complicated.\r\n    //Please don't muck with this unless you TRULY understand what is happening.\r\n    function recur(userFn){\r\n        var recursingFn = j.either(j.identity, userFn, 'function'),\r\n            localRecursor = j.partial(recursor, recursingFn),\r\n            recurValue = j.apply(localRecursor, j.slice(1, arguments));\r\n\r\n        while(verifyRecurValue(recurValue = recurValue(localRecursor)) && recursingFn !== j.identity);\r\n\r\n        return recurValue;\r\n    }\r\n\r\n\t/*\r\n     * Reduce uses tail-optimized (while-trampolined, fully returning) recursion to resolve reductions.\r\n     * Reducer is a pure function for handling a single reduction step.\r\n     * Reduce manages the setup and recursion execution.\r\n     */\r\n    function reducer(userFn, recur, reduction, collection){\r\n        return collection.length === 0 ?\r\n                    reduction :\r\n                    recur(userFn(reduction, j.first(collection)),\r\n                          j.rest(collection));\r\n    }\r\n\r\n    function reduce(userFn, values){\r\n        var appliedReducer = j.partial(reducer, userFn),\r\n            initialState = arguments[2],\r\n            hasInitialState = typeof initialState !== 'undefined',\r\n            \r\n            initialValue = !hasInitialState ? j.first(values) : initialState,\r\n            remainder = !hasInitialState ? j.rest(values) : values;\r\n\r\n        return (Boolean(values) && values.length > 0) ? j.recur(appliedReducer, initialValue, remainder) : initialValue;\r\n    }\r\n\r\n    //Produces a function that returns f(g(x))\r\n    function compositor(f, g){\r\n        var $f = typeof f !== 'function' ? j.identity : f,\r\n            $g = typeof g !== 'function' ? j.identity : g;\r\n            \r\n        function compositeFn () {\r\n            return $f(j.apply($g, j.slice(0, arguments)));\r\n        }\r\n        \r\n        return compositeFn;\r\n    }\r\n\r\n    function compose(){\r\n        return reduce(compositor, j.slice(0, arguments), j.identity);\r\n    }\r\n\r\n    function pipeline(value){\r\n        return j.apply(compose, j.slice(1, arguments).reverse())(value);\r\n    }\r\n\r\n    function partialReverse(){\r\n        return j.apply(j.compose(j.reverseArgs, j.partial),\r\n                       j.slice(0, arguments));\r\n    }\r\n\r\n    function clone (originalValue, depth) {\r\n        var depthOkay = j.isUndefined(depth) || j.geq(depth, 0),\r\n            copyOkay = j.isType('object', originalValue) || j.isType('array', originalValue);\r\n        \r\n        function copy () {\r\n            var keys = Object.keys(originalValue),\r\n                container = j.isArray(originalValue) ? [] : {};\r\n            \r\n            j.each(function (key) {\r\n                var newDepth = j.isNumber(depth) ? depth - 1 : undefined;\r\n                \r\n                try {\r\n                    container[key] = clone(originalValue[key], newDepth);\r\n                } catch (err) {\r\n                    throw new RangeError('Object contains circular reference or is too deep to clone.');\r\n                }\r\n                \r\n            }, keys);\r\n            \r\n            return container;\r\n        }\r\n        \r\n        return copyOkay && depthOkay ? copy() : originalValue;\r\n    }\r\n\r\n    function maybeType (typeString) {\r\n        return j.curry(function (value) {\r\n            return j.maybe(value, typeString);\r\n        }).apply(j, j.slice(1, arguments));\r\n    }\r\n    \r\n    function eitherType (typeString) {\r\n        return j.curry(function (defaultValue, optionValue) {\r\n            return j.either(defaultValue, optionValue, typeString);\r\n        }).apply(j, j.slice(1, arguments));\r\n    }\r\n    \r\n    j.clone = clone;\r\n    j.compose = compose;\r\n    j.curry = curry;\r\n    j.eitherType = eitherType;\r\n    j.maybeType = maybeType;\r\n    j.partialReverse = partialReverse;\r\n    j.pipeline = pipeline;\r\n    j.recur = recur;\r\n    j.reduce = reduce;\r\n\r\n})(jfp);\r\n\r\n\r\n(function(j){\r\n\t\r\n    /*\r\n     * Map uses reduce to produce a new, completely reference-decoupled list of values\r\n     * Mapper handles a single update step for the final output array\r\n     */\r\n    function mapper(userFn, finalArray, value){\r\n        finalArray.push(userFn(value));\r\n        return finalArray;\r\n    }\r\n\r\n    function map (userFn, values) {\r\n        var mapperFn = j.partial(mapper, userFn);\r\n        return j.reduce(mapperFn, values, []);\r\n    }\r\n    \r\n    /*\r\n     * Filter uses reduce to produce a new, completely reference-decoupled list of values\r\n     * Filterer handles a single update step for the final output array\r\n     */\r\n    function filterer(userPredicate, finalArray, value){\r\n        return userPredicate(value) ? j.conj(value, finalArray) : finalArray;\r\n    }\r\n\r\n    function filter (predicate, values) {\r\n        var filterFn = j.partial(filterer, predicate);\r\n        return j.reduce(filterFn, values, []);\r\n    }\r\n    \r\n    function compact(valueList){\r\n        return filter(j.isTruthy, valueList);\r\n    }\r\n\r\n    function predicateAccumulator(predicate, total, value){\r\n        var sanitizedTotal = j.either(0, total, 'number');\r\n        return predicate(value) ? sanitizedTotal + 1 : sanitizedTotal;\r\n    }\r\n\r\n    function numberOf(predicate, valueSet){\r\n        var accumulator = j.partial(predicateAccumulator, predicate);\r\n        return j.reduce(accumulator, j.either([], valueSet), 0);\r\n    }\r\n\r\n    function captureUnique(finalList, value){\r\n        return j.last(finalList) === value ? finalList : j.conj(value, finalList);\r\n    }\r\n    \r\n    function unique(valueSet){\r\n        return j.reduce(captureUnique, j.sort(j.slice(0, valueSet)), []);\r\n    }\r\n\r\n    function union(set1, set2){\r\n        return j.compose(j.unique, j.concat)(set1, set2);\r\n    }\r\n\r\n    function addToHash(finalObject, value){\r\n        finalObject[value] = true;\r\n        return finalObject;\r\n    }\r\n\r\n    function buildValueHash(valueList){\r\n        return j.either({}, j.reduce(addToHash, valueList, {}));\r\n    }\r\n\r\n    function captureIntersection(valueHash, finalList, value){\r\n        return valueHash[value] ? j.conj(value, finalList) : finalList;\r\n    }\r\n    \r\n    function intersect(set1, set2){\r\n        var setHash = buildValueHash(j.either([], set2));\r\n        return j.reduce(j.partial(captureIntersection, setHash), set1, []); \r\n    }\r\n\r\n    function captureDifference(valueHash, finalList, value){\r\n        return !valueHash[value] ? j.conj(value, finalList) : finalList;\r\n    }\r\n    \r\n    function difference(set1, set2){\r\n        var setHash = buildValueHash(j.either([], set2));\r\n        return j.reduce(j.partial(captureDifference, setHash), set1, []);\r\n    }\r\n\r\n    function symmetricDifference(set1, set2){\r\n        var setUnion = union(set1, set2),\r\n            setIntersection = intersect(set1, set2);\r\n\r\n        return difference(setUnion, setIntersection);\r\n    }\r\n\r\n    function everyReducer (predicate, result, valueList){\r\n        return result && predicate(valueList);\r\n    }\r\n\r\n    function every (predicate, valueList){\r\n        var reducer = j.partial(everyReducer, predicate);\r\n        return Boolean(j.reduce(reducer, valueList, true));\r\n    }\r\n\r\n    function finder (recur, predicate, valueList) {\r\n        var done = !Boolean(valueList) || valueList.length === 0,\r\n            result = done ? null : j.first(valueList);\r\n        \r\n        return done || predicate(result) ? result : recur(predicate, j.rest(valueList));\r\n    }\r\n\r\n    function find (predicate, valueList){\r\n        return j.recur(finder, predicate, valueList);\r\n    }\r\n\r\n    function someRecur(recur, predicate, valueList){\r\n        var done = valueList.length === 0,\r\n            result = done ? false : predicate(j.first(valueList));\r\n            \r\n        return result || done ? result : recur(predicate, j.rest(valueList));\r\n    }\r\n\r\n    function some(predicate, valueList){\r\n        return Boolean(j.recur(someRecur, predicate, valueList));\r\n    }\r\n    \r\n    function contains(value, valueList){\r\n        return some(j.partial(j.equal, value), valueList);\r\n    }\r\n\r\n    function partitioner(predicate, partitions, value){\r\n        var index = predicate(value) ? 0 : 1;\r\n\r\n        partitions[index].push(value);\r\n\r\n        return partitions;\r\n    }\r\n\r\n    function partition(predicate, list){\r\n        var sanitizedPredicate = j.either(j.identity, predicate, 'function');\r\n        \r\n        return j.reduce(j.partial(partitioner, sanitizedPredicate),\r\n                        j.either([], list),\r\n                        [[], []]);\r\n    }\r\n\r\n    function multiPartitioner(predicate, partitions, value){\r\n        var partitionPredicate = j.rpartial(predicate, value),\r\n            computedPartitions = j.dropLast(partitions);\r\n        \r\n        return j.concat(computedPartitions, partition(partitionPredicate, j.last(partitions)));\r\n    }\r\n    \r\n    function multiPartition(predicate, predicateArgs, list){\r\n        var sanitizedArgs = j.either([], predicateArgs),\r\n            sanitizedPredicate = j.either(j.identity, predicate),\r\n            sanitizedList = j.either([], list);\r\n            \r\n        return !Boolean(list) ?\r\n                [[], []] :\r\n                j.reduce(j.partial(multiPartitioner, sanitizedPredicate),\r\n                         sanitizedArgs,\r\n                         [sanitizedList]);\r\n    }\r\n\r\n    function firstExists (list) {\r\n        return j.not(j.isNull(j.first(list)));\r\n    }\r\n\r\n    j.contains = contains;\r\n    j.compact = compact;\r\n    j.difference = difference;\r\n    j.every = every;\r\n\tj.filter = filter;\r\n    j.find = find;\r\n    j.firstExists = firstExists;\r\n    j.intersect = intersect;\r\n\tj.map = map;\r\n\tj.multiPartition = multiPartition;\r\n\tj.numberOf = numberOf;\r\n    j.partition = partition;\r\n    j.some = some;\r\n    j.symmetricDifference = symmetricDifference;\r\n    j.union = union;\r\n    j.unique = unique;\r\n\r\n})(jfp);\r\n\r\n(function (j) {\r\n\t'use strict';\r\n\t\r\n\t//Performs 'and' operation on valueSet\r\n    function ander(a, b){\r\n        return a && b;\r\n    }\r\n\r\n    function orer(a, b){\r\n        return a || b;\r\n    }\r\n\r\n    function reduceConditions(conditionArgs, operator, initialCondition) {\r\n        return j.pipeline(conditionArgs,\r\n                          j.partial(j.slice, 0),\r\n                          j.partial(j.map, Boolean),\r\n                          j.splitPartial(j.reduce, [operator], [initialCondition]),\r\n                          Boolean);\r\n    }\r\n\r\n    function and(a, b){\r\n        return reduceConditions(arguments, ander, true);\r\n    }\r\n\r\n    function or(a, b){\r\n        return reduceConditions(arguments, orer, false);\r\n    }\r\n\r\n    function xor(a, b){\r\n        var equivalent = Boolean(a) === Boolean(b);\r\n        return or(a, b) && !equivalent;\r\n    }\r\n    \r\n    function cond (conditionPair) {\r\n        var isTruthy = j.compose(j.truthy, j.partial(j.nth, 0)),\r\n            behavior = j.pipeline(arguments,\r\n                                  j.partial(j.slice, 0),\r\n                                  j.partial(j.filter, j.isPair),\r\n                                  j.partial(j.find, isTruthy),\r\n                                  j.partial(j.nth, 1));\r\n\r\n        return j.isType('function', behavior) ? behavior() : null;\r\n    }\r\n\r\n    function cleanConditionPairs (value, conditionPairs) {\r\n        var error = new Error('Match call does not contain expressions for all condition cases.'),\r\n            notEmpty = j.hasFirst(conditionPairs);\r\n\r\n        return cond([j.isUndefined(value), j.always([])],\r\n                    [notEmpty, j.partial(j.conj, \r\n                                         [j.always(true), function () { throw error; }],\r\n                                         conditionPairs)],\r\n                    ['else', j.partial(j.conj,\r\n                                       [j.always(true), j.always(value)],\r\n                                       conditionPairs)]);\r\n    }\r\n\r\n    function matchToCond (value, conditionPair) {\r\n        var condition = j.first(conditionPair),\r\n            result = j.last(conditionPair),\r\n            newPair = [\r\n                j.isType('function', condition) ? condition(value) : j.equal(condition, value),\r\n                j.isType('function', result) ? result : j.always(result)\r\n            ];\r\n        return !j.isPair(conditionPair) ? conditionPair : newPair;\r\n    }\r\n\r\n    function match (value, conditionPair) {\r\n        var conditionPairs = j.slice(1, arguments),\r\n            result = j.isUndefined(value) ? null : value;\r\n\r\n        return j.pipeline(conditionPairs,\r\n                          j.partial(cleanConditionPairs, result),\r\n                          j.partial(j.map, j.partial(matchToCond, value)),\r\n                          j.partial(j.apply, cond));\r\n    }\r\n\r\n    function composePredicate (predicateFn) {\r\n        var args = j.slice(0, arguments),\r\n        \r\n            combinator = match(j.last(args),\r\n                               [j.partial(j.equal, or), j.always(or)],                              \r\n                               [j.always(true), j.always(and)]),\r\n                               \r\n            predicateList = match(j.last(args),\r\n                                  [j.partial(j.equal, or), j.partial(j.dropLast, args)],\r\n                                  [j.partial(j.equal, and), j.partial(j.dropLast, args)],\r\n                                  [j.always(true), j.always(args)]);\r\n        \r\n        return function (value) {\r\n            var executor = j.rpartial(j.execute, value);\r\n            \r\n            return j.pipeline(predicateList,\r\n                              j.partial(j.map, executor),\r\n                              j.partial(j.reduce, combinator),\r\n                              Boolean);\r\n        };\r\n    }\r\n\r\n    // Predicate combinators\r\n\tj.and = and;\r\n\tj.or = or;\r\n\tj.xor = xor;\r\n\r\n    j.composePredicate = composePredicate;\r\n    j.cond = cond;\r\n    j.match = match;\r\n    \r\n})(jfp);\r\n\r\n(function (j) {\r\n\t'use strict';\r\n\t\r\n    /*\r\n     * toValues converts an object to an array of values\r\n     * This is necessary for reduce to convert objects into\r\n     * processible arrays in an upcoming version.\r\n     */\r\n\tfunction keyReduction (baseObj, finalList, key) {\r\n\t\treturn j.conj(baseObj[key], finalList);\r\n\t}\r\n\t\r\n\tfunction toValues (baseObj) {\r\n\t\tvar reducer = j.partial(keyReduction, baseObj);\r\n\t\treturn j.isNull(j.maybe(baseObj, 'object')) ? null : j.reduce(reducer, Object.keys(baseObj), []);\r\n\t}\r\n\r\n\tfunction dereferencer(dataObject, token){\r\n        var key = j.either('', token).trim();\r\n        return key === '' ? dataObject : j.pick(token, dataObject);\r\n    }\r\n\r\n    function internalDeref(key, baseData, defaultValue){\r\n        var sanitizedDefault = j.isUndefined(defaultValue) ? null : defaultValue,\r\n            keyTokens = key.split('.'),\r\n            result = j.reduce(dereferencer, keyTokens, baseData);\r\n        \r\n        return j.either(sanitizedDefault, result);\r\n    }\r\n    \r\n    function deref(key, baseData){\r\n        // Satisifes backwards-compatibility case where key an data are reversed\r\n        var defaultValue = arguments[2],\r\n            sanitizedKey = typeof key === 'string' ? key : baseData,\r\n            sanitizedData = typeof baseData === 'object' ? baseData : key;\r\n        \r\n        // Fully sanitize data before executing the dereference function\r\n        sanitizedKey = j.either('', sanitizedKey, 'string');\r\n        sanitizedData = j.either(null, sanitizedData, 'object');\r\n        \r\n        return internalDeref(j.either('', sanitizedKey), sanitizedData, defaultValue);\r\n    }\r\n    \r\n    function plucker (baseObj, finalObj, key){\r\n        finalObj[key] = baseObj[key];\r\n        return finalObj;\r\n    }\r\n    \r\n    function pluckKeys (keys, baseObj){\r\n        var sanitizedObject = j.either({}, baseObj, 'object');\r\n        return j.reduce(j.partial(plucker, sanitizedObject), keys, {});\r\n    }\r\n    \r\n    function pluck (key, baseObj) {\r\n        return pluckKeys([key], baseObj);\r\n    }\r\n\r\n    function transformer (obj, result, transformation) {\r\n        result[transformation[1]] = deref(transformation[0], obj);\r\n        return result;\r\n    }\r\n\r\n    function transform (transformation, obj) {\r\n        return j.pipeline(transformation,\r\n                          j.partial(j.filter, j.isPair),\r\n                          j.splitPartial(j.reduce, [j.partial(transformer, obj)], [{}]));\r\n    }\r\n\r\n\tj.deref = deref;\r\n    j.pluck = pluck;\r\n    j.pluckKeys = pluckKeys;\r\n    j.toValues = toValues;\r\n    j.transform = transform;\r\n\r\n})(jfp);\r\n\r\n(function(j){\r\n    'use strict';\r\n\r\n//This is a recursive add fn\r\n    function adder(recur, current, valueSet){\r\n        return (valueSet.length === 0) ?\r\n                current :\r\n                recur(current + j.first(valueSet), j.rest(valueSet));\r\n    }\r\n    \r\n    function add(a, b){\r\n        return j.recur(adder, 0, j.slice(0, arguments));\r\n    }\r\n    \r\n    //This is a recursive divide fn\r\n    function divider(recur, current, valueSet){\r\n        return (valueSet.length === 0) ?\r\n                current :\r\n                recur(current / j.first(valueSet), j.rest(valueSet));\r\n    }\r\n    \r\n    function divide(){\r\n        var args = j.slice(0, arguments),\r\n            first = args.length ? j.first(args) : 1;\r\n        return j.recur(divider, first, j.rest(args));\r\n    }\r\n    \r\n    //This is a recursive multiply fn\r\n    function multiplier(recur, current, valueSet){\r\n        return (valueSet.length === 0) ?\r\n                current :\r\n                recur(current * j.first(valueSet), j.rest(valueSet));\r\n    }\r\n    \r\n    function multiply(){\r\n        return j.recur(multiplier, 1, j.slice(0, arguments));\r\n    }\r\n    \r\n    //This is a recursive subtraction fn\r\n    function subtractor(recur, current, valueSet){\r\n        return (valueSet.length === 0) ?\r\n                current :\r\n                recur(current - j.first(valueSet), j.rest(valueSet));\r\n    }\r\n    \r\n    function subtract(){\r\n        var args = j.slice(0, arguments),\r\n            first = args.length ? j.first(args) : 0;\r\n        return j.recur(subtractor, first, j.rest(args));\r\n    }\r\n\r\n    //This is a recursive constructor function for ranges\r\n    function rangeRecurCheck(m, n, inc){\r\n        return inc > 0 ? (m + inc) < n : (m + inc) > n;\r\n    }\r\n\r\n    function rangeBuilder(recur, currentRange, m, n, inc){\r\n        var finalRange = rangeRecurCheck(m - inc, n, inc) ?\r\n                            j.conj(m, currentRange) :\r\n                            currentRange;\r\n        \r\n        return rangeRecurCheck(m, n, inc) ?\r\n                recur(finalRange, m + inc, n, inc) :\r\n                finalRange;\r\n    }\r\n    \r\n    function range(a, b, inc){\r\n        var start = j.isUndefined(b) ? 0 : a,\r\n            end = j.isUndefined(b) ? j.either(0, a) : b,\r\n            increment = (!inc) ? 1 : inc;\r\n            \r\n        return j.recur(rangeBuilder,\r\n                       [],\r\n                       j.either(0, start),\r\n                       j.either(0, end),\r\n                       increment);\r\n    }\r\n\r\n    function mod(a, b){\r\n        return j.isUndefined(b) ? j.either(0, a) : a%b;\r\n    }\r\n\r\n    function modulo(a, b){\r\n        var _a = j.either(0, a),\r\n            _b = j.either(0, b);\r\n\r\n        return (_a > 0) ? mod(_a, _b) : _b * (Math.floor(Math.abs(_a)/_b) + 1) + _a;\r\n    }\r\n\r\n    function truncate(value){\r\n        return (value > 0) ? Math.floor(value) : Math.floor(value) + 1;\r\n    }\r\n    \r\n    function max(a, b){\r\n        var maxValue = -Number.MAX_VALUE,\r\n            _a = j.isUndefined(a) ? maxValue : a,\r\n            _b = j.isUndefined(b) ? maxValue : b;\r\n            \r\n        maxValue = (_a > maxValue) ? _a : maxValue;\r\n        maxValue = (_b > maxValue) ? _b : maxValue;\r\n        \r\n        return maxValue;\r\n    }\r\n    \r\n    function min(a, b){\r\n        var minValue = Number.MAX_VALUE,\r\n            _a = j.isUndefined(a) ? minValue : a,\r\n            _b = j.isUndefined(b) ? minValue : b;\r\n        \r\n        minValue = (_a < minValue) ? _a : minValue;\r\n        minValue = (_b < minValue) ? _b : minValue;\r\n        \r\n        return minValue;\r\n    }\r\n\r\n    function fac(value){\r\n        var factorial = j.compose(j.partial(j.reduce, multiply),\r\n                                  j.partial(range, 1),\r\n                                  j.partial(add, 1));\r\n\r\n        return j.either(1, j.when(j.greater(value, 0), factorial, value));\r\n    }\r\n\r\n    j.add = add;\r\n    j.divide = divide;\r\n    j.fac = fac;\r\n    j.inc = j.partial(j.add, 1);\r\n    j.max = max;\r\n    j.min = min;\r\n    j.mod = mod;\r\n    j.modulo = modulo;\r\n    j.multiply = multiply;\r\n    j.range = range;\r\n    j.subtract = subtract;\r\n    j.truncate = truncate;\r\n\r\n})(jfp);\r\n\r\n\r\n(function(j){\r\n\r\n    function throwWhenNotComparable(a, b){\r\n        j.when(j.isUndefined(a) || j.isUndefined(b), function(){\r\n            throw new TypeError('Inequality comparisons require two values');\r\n        });\r\n    }\r\n\r\n    function greater(a, b){\r\n        throwWhenNotComparable(a, b);\r\n        return a > b;\r\n    }\r\n\r\n    function less(a, b){\r\n        throwWhenNotComparable(a, b);\r\n        return a < b;\r\n    }\r\n\r\n    function isInt(value){\r\n        return j.equal(j.truncate(value), value);\r\n    }\r\n\r\n    function isMultipleOf (base, test) {\r\n        return j.equal(0, j.mod(test, base));\r\n    }\r\n\r\n    var isNegative = j.partial(greater, 0),\r\n        isPositive = j.partial(less, 0),\r\n        isZero = j.partial(j.equal, 0),\r\n        isEven = j.compose(isZero, j.rpartial(j.mod, 2));\r\n\r\n    j.isEven = isEven;\r\n    j.isInt = isInt;\r\n    j.isMultipleOf = isMultipleOf;\r\n    j.isNegative = isNegative;\r\n    j.isNonNegative = j.compose(j.not, isNegative);\r\n    j.isNonPositive = j.compose(j.not, isPositive);\r\n    j.isNonZero = j.compose(j.not, isZero);\r\n    j.isOdd = j.compose(j.not, isEven);\r\n    j.isPositive = isPositive;\r\n    j.isZero = isZero;\r\n\r\n    //Special case predicate naming is intended for these functions\r\n    //There is a general expectation that these not be named with 'is'\r\n    j.geq = j.compose(j.not, less);\r\n    j.greater = greater;\r\n    j.leq = j.compose(j.not, greater);\r\n    j.less = less;\r\n\r\n})(jfp);\r\n\r\n(function (j) {\r\n\t'use strict';\r\n\t\r\n\tfunction attachFunction (module, j, key) {\r\n\t\tif(j.isUndefined(j[key]) && j.isType('function', module[key])) {\r\n\t\t\tj[key] = module[key];\r\n\t\t}\r\n\t\treturn j;\r\n\t}\r\n\t\r\n\tfunction addModule (provider) {\r\n\t\tvar module = j.either(j.always({}), provider, 'function')(),\r\n\t\t\tmoduleKeys = j.getKeys(module);\r\n\t\t\t\r\n\t\treturn function () {\r\n\t\t\treturn j.reduce(j.partial(attachFunction, module), moduleKeys, j);\r\n\t\t};\r\n\t}\r\n\t\r\n\tj.addModule = addModule;\r\n\t\r\n})(jfp);\r\n\r\nvar j = jfp;\r\n\r\nif(typeof module !== 'undefined' && Boolean(module.exports)){\r\n    // Node and CommonJS export\r\n    module.exports = j;\r\n} else if (typeof define === 'function' && Boolean(define.amd)) {\r\n    // AMD and Require.js module definition\r\n    define([], function () {\r\n        return jfp;\r\n    });\r\n}\r\n\r\n\r\n"]}