{"version":3,"file":"jfp.min.js","sources":["jfp.js"],"names":["jfp","resolveFunction","functionValue","args","slice","arguments","apply","curry","j","isBoolean","value","isFunction","testFn","isObject","isArray","Object","prototype","toString","call","isString","isEmptyString","isNull","isNumber","isNumeric","pattern","match","isTruthy","isUndefined","undefined","not","identity","begin","valueSet","end","values","Array","shortCircuit","defaultValue","userFn","testValue","maybe","type","typeOkay","either","when","checkValue","eitherIf","predicateValue","safePredicate","partial","eitherWhen","sanitizedFn","concat","original","extension","result","sanitizedExtension","i","length","push","basePartial","direction","appliedFunction","applicationArgs","reverseArgs","reverse","captureArguments","replace","split","countArguments","params","execute","rpartial","toValues","valueMap","finalArray","key","hasOwnProperty","conj","toDec","parseInt","copyArray","makeValueArray","dest","cons","source","each","userArray","sanitizedArray","filter","predicate","filterFn","find","finalValue","findFn","first","lastIndex","last","drop","index","finalIndex","sanitizedIndex","firstArray","secondArray","dropLast","map","mapFn","nth","rest","take","count","some","satisfied","someFn","contains","equal","every","everyFn","numberOf","accumulator","accumulate","naturalComparator","a","b","comparison","sort","optionValue","comparator","finalSet","union","set1","set2","compose","unique","buildValueHash","finalHash","intersect","seta","setbHash","difference","symmetricDifference","setUnion","setIntersection","dropFirst","init","pick","pickResult","pluckKeys","keys","finalOutput","sanitizedKeys","sanitizedValueMap","captureValue","pluck","merge","defaultObj","mergeData","finalObj","argumentCount","appliedFn","recursor","recurFn","recursorFn","localRecursor","verifyRecurValue","recurValue","recur","recursingFn","reduce","reducer","reduction","collection","ander","current","and","orer","or","xor","compositor","f","g","pipeline","finalValues","operator","partialReverse","partialAndReverse","compact","adder","add","divider","divide","multiplier","multiply","subtractor","subtract","rangeRecurCheck","m","n","inc","rangeBuilder","currentRange","finalRange","range","start","increment","mod","modulo","_a","_b","Math","floor","abs","truncate","max","maxValue","Number","MAX_VALUE","min","minValue","fac","factorial","greater","throwWhenNotComparable","TypeError","isNotUndefined","less","isEven","isPositive","isZero","isNegative","isInt","isNonNegative","isNonPositive","isNonZero","isOdd","geq","leq","module","exports"],"mappings":"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","sourcesContent":["var jfp = (function(){\n    'use strict';\n    \n    function resolveFunction(functionValue){\n        return typeof functionValue === 'string' ? jfp[functionValue] : functionValue;\n    }\n    \n    return function(){\n        var args = jfp.slice(0, arguments);\n        \n        args[0] = resolveFunction(args[0]);\n        \n        return jfp.apply(jfp.curry, args);\n    };\n    \n})();\n\n(function(j){\n    'use strict';\n    \n    function isBoolean(value){\n        return typeof value === 'boolean';\n    }\n\n    function isFunction(testFn){\n        return typeof testFn === 'function';\n    }\n    \n    function isObject(value){\n        return (typeof value == 'object');\n    }\n    \n    function isArray(value){\n        return (isObject(value) && Object.prototype.toString.call(value) === '[object Array]');\n    }\n    \n    function isString(value){\n        return typeof value === 'string';\n    }\n\n    function isEmptyString(value){\n        return isString(value) && value === '';\n    }\n    \n    function isNull(value){\n        return value === null;\n    }\n    \n    function isNumber(value){\n        return typeof value === 'number';\n    }\n    \n    function isNumeric(value){\n        var pattern = /^(0x)?[0-9]+((\\.[0-9]+)|(e\\-?[0-9]+))?$/;\n        return isNumber(value) || (isString(value) && !!value.match(pattern));\n    }\n    \n    function isTruthy(value){\n        return !!value;\n    }\n    \n    function isUndefined(value){\n        return value === undefined;\n    }\n\n    function not(value){\n        return !value;\n    }\n\n    j.isArray = isArray;\n    j.isBoolean = isBoolean;\n    j.isEmptyString = isEmptyString;\n    j.isFunction = isFunction;\n    j.isNull = isNull;\n    j.isNumber = isNumber;\n    j.isNumeric = isNumeric;\n    j.isObject = isObject;\n    j.isString = isString;\n    j.isTruthy = isTruthy;\n    j.isUndefined = isUndefined;\n    j.not = not;\n\n})(jfp);\n\n\n(function(j){\n    'use strict';\n\n    function identity(value){\n        return value;\n    }\n\n    function slice(begin, valueSet, end){\n        var values = j.not(j.isTruthy(valueSet)) ? [] : valueSet;\n\n        return j.not(j.isTruthy(end)) ?\n                    Array.prototype.slice.call(values, begin) :\n                    Array.prototype.slice.call(values, begin, end);\n    }\n\n    function shortCircuit(defaultValue, userFn, testValue){\n        return (j.isTruthy(testValue) || testValue === 0) ?\n            userFn(testValue) :\n            defaultValue;\n    }\n\n    function maybe(value){\n        var type = arguments[1],\n            typeOkay = typeof value === type;\n\n        return typeOkay || (!type && !!value) ? value : null;\n    }\n\n    function either(defaultValue, testValue){\n        var type = arguments[2];\n        return maybe(testValue, type) === null ? defaultValue : testValue;\n    }\n\n    function apply(userFn, args){\n        return userFn.apply(null, args);\n    }\n\n    function when(checkValue, userFn){\n        var args = slice(2, arguments);\n        return j.isTruthy(checkValue) ? apply(userFn, args) : null;\n    }\n\n    function eitherIf(defaultValue, testValue, predicateValue){\n        var safePredicate = j.isUndefined(predicateValue) ? true : predicateValue;\n\n        return j.either(defaultValue, j.when(safePredicate, j.partial(j.identity, testValue)));\n    }\n\n    function eitherWhen(defaultValue, predicateValue, userFn){\n        var sanitizedFn = eitherIf(j.identity, userFn, j.isFunction(userFn));\n\n        return j.either(defaultValue, j.when(predicateValue, sanitizedFn));\n    }\n\n    function concat(original, extension){\n        var result = slice(0, either([], original)),\n            sanitizedExtension = either([], extension),\n            i;\n\n        //This is the most performant way to handle concatenation. Trust me.\n        for(i = 0; i < sanitizedExtension.length; i++){\n            result.push(sanitizedExtension[i]);\n        }\n\n        return result;\n    }\n\n    function basePartial(direction, userFn){\n        var args = slice(2, arguments);\n\n        return function appliedFunction(){\n            var applicationArgs = (direction === 'left') ?\n                                    concat(args, slice(0, arguments)) :\n                                    concat(slice(0, arguments), args);\n\n            return apply(userFn, applicationArgs);\n        };\n    }\n\n    function reverseArgs(userFn){\n        return function(){\n            var args = j.slice(0, arguments).reverse();\n            j.apply(userFn, args);\n        };\n    }\n\n    function captureArguments(userFn){\n        return userFn.toString()\n            .replace(/((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/)|(\\s))/mg,'')\n            .match(/^function\\s*[^\\(]*\\(\\s*([^\\)]*)\\)/m)[1]\n            .split(/,/);\n    }\n\n    function countArguments(userFn){\n        var params = shortCircuit([], captureArguments, userFn);\n\n        params = (params.length === 1 && params[0] === '') ? [] : params;\n\n        return params.length;\n    }\n\n    function execute(userFn){\n        return j.apply(userFn, j.slice(1, arguments));\n    }\n\n    j.apply = apply;\n    j.concat = concat;\n    j.countArguments = countArguments;\n    j.either = either;\n    j.eitherIf = eitherIf;\n    j.eitherWhen = eitherWhen;\n    j.execute = execute;\n    j.identity = identity;\n    j.maybe = maybe;\n    j.partial = basePartial('left', basePartial, 'left');\n    j.reverseArgs = reverseArgs;\n    j.rpartial = basePartial('left', basePartial, 'right');\n    j.shortCircuit = shortCircuit;\n    j.slice = slice;\n    j.when = when;\n\n})(jfp);\n\n\n(function(j){\n    'use strict';\n\n    function toValues(valueMap){\n        var finalArray = [],\n            key;\n\n        j.when(j.isObject(valueMap), function(){\n            for(key in valueMap){\n                if(valueMap.hasOwnProperty(key) && j.isTruthy(valueMap[key])){\n                    finalArray = j.conj(valueMap[key], finalArray);\n                }\n            }\n        });\n\n        return j.either(null, j.when(j.isObject(valueMap), function(){ return finalArray; }));\n    }\n\n    function toDec(value){\n        return (j.isNumeric(value)) ? parseInt(value, 10) : null;\n    }\n\n    j.toDec = toDec;\n    j.toValues = toValues;\n\n})(jfp);\n\n(function(j){\n    'use strict';\n\n    function copyArray(valueSet){\n        return j.slice(0, valueSet);\n    }\n\n    function makeValueArray(value){\n        return j.not(j.isUndefined(value)) ? [value] : [];\n    }\n\n    function conj(value, dest){\n        return j.concat(copyArray(dest), makeValueArray(value));\n    }\n\n    function cons(value, source){\n        return j.concat(makeValueArray(value), source);\n    }\n\n    function each(userFn, userArray){\n        var sanitizedArray = j.either([], userArray),\n            sanitizedFn = j.either(j.identity, userFn),\n            i;\n\n        for(i = 0; i < sanitizedArray.length; i++){\n            if(sanitizedFn(sanitizedArray[i], i) === false){\n                break;\n            }\n        }\n\n        return sanitizedArray;\n    }\n\n    function filter(predicate, userArray){\n        var result = [];\n\n        function filterFn(value){\n            j.when(predicate(value), function(){\n                result = conj(value, result);\n            });\n        }\n\n        each(filterFn, userArray);\n\n        return result;\n    }\n\n    function find(predicate, valueSet){\n        var finalValue = null;\n\n        function findFn(value){\n            return j.not(j.when(predicate(value), function(){\n                            finalValue = value;\n                            return true;\n                         }));\n        }\n\n        each(findFn, j.either([], valueSet));\n\n        return finalValue;\n    }\n\n    function first(values){\n        return j.isArray(values) ? j.either(null, values[0]) : null;\n    }\n\n    function lastIndex(values){\n        return j.isArray(values) ? values.length - 1 : null;\n    }\n\n    function last(values){\n        return j.isArray(values) ? values[lastIndex(values)] : null;\n    }\n\n    function drop(index, valueSet){\n        var finalIndex = lastIndex(valueSet),\n\n            sanitizedIndex = (index === 0 || index === finalIndex) ?\n                index : j.either(1, index) - 1,\n\n            firstArray = (sanitizedIndex === 0) ?\n                [] : j.slice(0, valueSet, sanitizedIndex),\n\n            secondArray = (sanitizedIndex === finalIndex)?\n                [] : j.slice(sanitizedIndex + 1, valueSet);\n\n        return j.concat(firstArray, secondArray);\n    }\n\n    function dropLast(valueSet){\n        return drop(lastIndex(valueSet), valueSet);\n    }\n\n    function map(userFn, userArray){\n        var finalArray = [];\n\n        function mapFn(value){\n            finalArray = conj(userFn(value), finalArray);\n        }\n\n        each(mapFn, userArray);\n\n        return finalArray;\n    }\n\n    function nth(index, valueSet){\n        return j.either(null, j.either([], valueSet)[index]);\n    }\n\n    function rest(values){\n        return j.slice(1, values);\n    }\n\n    function take(count, values){\n        return j.isArray(values) ? j.slice(0, values, count) : null;\n    }\n\n    function some(predicate, valueSet){\n        var satisfied = false;\n\n        function someFn(value, index){\n            satisfied = predicate(value, index);\n            return !satisfied;\n        }\n\n        each(someFn, valueSet);\n\n        return satisfied;\n    }\n\n    function contains(value, valueSet){\n        return some(j.partial(j.equal, value), valueSet);\n    }\n\n    function every(predicate, valueSet){\n        var satisfied = false;\n\n        function everyFn(value, index){\n            satisfied = predicate(value, index);\n            return satisfied;\n        }\n\n        each(everyFn, valueSet);\n\n        return satisfied;\n    }\n\n    function numberOf(predicate, valueSet){\n        var accumulator = 0;\n\n        function accumulate(value){\n            accumulator += predicate(value) ? 1 : 0;\n        }\n\n        each(accumulate, valueSet);\n\n        return accumulator;\n    }\n\n    function naturalComparator(a, b){\n        var comparison = a < b ? -1 : 1;\n        return a === b ? 0 : comparison;\n    }\n\n    function sort(optionValue, valueSet){\n        var comparator = j.isFunction(optionValue) ? optionValue : naturalComparator,\n            finalSet = j.isArray(optionValue) ? j.slice(0, optionValue) : j.slice(0, valueSet);\n\n        return finalSet.sort(comparator);\n    }\n\n    function union(set1, set2){\n        return j.compose(j.unique, j.concat)(set1, set2);\n    }\n\n    function buildValueHash(valueSet){\n        var finalHash = {};\n\n        j.each(function(value){\n            finalHash[value] = true;\n        }, valueSet);\n\n        return finalHash;\n    }\n\n    function intersect(set1, set2){\n        var finalSet = [],\n            seta = j.unique(j.either([], set1)),\n            setbHash = buildValueHash(j.either([], set2)),\n            i = 0;\n\n        for(; i < seta.length; i++){\n            if(setbHash[seta[i]]){\n                finalSet.push(seta[i]);\n            }\n        }\n\n        return finalSet;\n    }\n\n    function difference(set1, set2){\n        var finalSet = [],\n            seta = j.unique(j.either([], set1)),\n            setbHash = buildValueHash(j.either([], set2)),\n            i = 0;\n\n        for(; i < seta.length; i++){\n            if(!setbHash[seta[i]]){\n                finalSet.push(seta[i]);\n            }\n        }\n\n        return finalSet;\n    }\n\n    function symmetricDifference(set1, set2){\n        var setUnion = union(set1, set2),\n            setIntersection = intersect(set1, set2);\n\n        return difference(setUnion, setIntersection);\n    }\n\n    j.conj = conj;\n    j.cons = cons;\n    j.contains = contains;\n    j.copyArray = copyArray;\n    j.difference = difference;\n    j.drop = drop;\n    j.dropFirst = j.partial(drop, 0);\n    j.dropLast = dropLast;\n    j.each = each;\n    j.every = every;\n    j.filter = filter;\n    j.find = find;\n    j.first = first;\n    j.init = j.dropLast;\n    j.intersect = intersect;\n    j.last = last;\n    j.lastIndex = lastIndex;\n    j.map = map;\n    j.nth = nth;\n    j.numberOf = numberOf;\n    j.rest = rest;\n    j.sort = sort;\n    j.some = some;\n    j.symmetricDifference = symmetricDifference;\n    j.take = take;\n    j.union = union;\n\n})(jfp);\n\n\n(function(j){\n    'use strict';\n\n    function pick(key, valueMap){\n        var pickResult = j.either({}, valueMap)[key];\n        return j.isUndefined(pickResult) ? null : pickResult;\n    }\n\n    function pluckKeys(keys, valueMap){\n        var finalOutput = {},\n            sanitizedKeys = j.either([], keys),\n            sanitizedValueMap = j.either({}, valueMap);\n\n        function captureValue(key){\n            finalOutput[key] = sanitizedValueMap[key];\n        }\n\n        j.each(captureValue, sanitizedKeys);\n\n        return finalOutput;\n    }\n\n    function pluck(key, valueMap){\n        return pluckKeys([key], valueMap);\n    }\n\n    function merge(defaultObj, mergeData){\n        var finalObj = {},\n            key;\n\n        for(key in j.either({}, defaultObj)){\n            finalObj[key] = defaultObj[key];\n        }\n\n        for(key in j.either({}, mergeData)){\n            finalObj[key] = mergeData[key];\n        }\n\n        return j.eitherIf(null, finalObj, j.isTruthy(defaultObj));\n    }\n\n    j.merge = merge;\n    j.pick = pick;\n    j.pluck = pluck;\n    j.pluckKeys = pluckKeys;\n\n})(jfp);\n\n\n(function(j){\n    'use strict';\n\n    //This is complicated and I don't expect people to grok it on first read.\n    function curry(userFn){\n        var args = j.slice(1, arguments),\n            argumentCount = j.shortCircuit(0, j.countArguments, userFn),\n            appliedFn = (args.length < argumentCount) ? j.apply(j.partial, j.concat([curry, userFn], args)) : null,\n            result = (!!userFn && args.length >= argumentCount) ? j.apply(userFn, args) : null;\n\n        return j.either(appliedFn, result);\n    }\n\n    //zOMG! TAIL RECURSION\n    function recursor(recurFn){\n        var args = j.slice(1, arguments);\n\n        //This is to make the returned function distinct and identifiable.\n        return function recursorFn(localRecursor){\n            return j.apply(recurFn, j.concat([localRecursor], args));\n        };\n    }\n\n    function verifyRecurValue(recurValue){\n        return typeof recurValue === 'function' &&\n            recurValue.toString().match('recursorFn');\n    }\n\n    //Tail optimization with managed recursion is really complicated.\n    //Please don't muck with this unless you TRULY understand what is happening.\n    function recur(userFn){\n        var recursingFn = j.either(j.identity, userFn),\n            localRecursor = j.partial(recursor, recursingFn),\n            recurValue = j.apply(localRecursor, j.slice(1, arguments));\n\n        while(verifyRecurValue(recurValue = recurValue(localRecursor)) && recursingFn !== j.identity);\n\n        return recurValue;\n    }\n\n    function reduce(userFn, values){\n        function reducer(recur, reduction, collection){\n            return (collection.length) ?\n                recur(userFn(reduction, j.first(collection)), j.rest(collection)) :\n                reduction;\n        }\n\n        return (!!values && values.length > 0) ? recur(reducer, j.first(values), j.rest(values)) : null;\n    }\n\n    //Performs 'and' operation on valueSet\n    function ander(recur, current, valueSet){\n        return (valueSet.length === 0) ?\n            current :\n            recur(current && !!j.first(valueSet), j.rest(valueSet));\n    }\n\n    function and(){\n        return recur(ander, true, j.slice(0, arguments));\n    }\n\n    //Performs 'or' operation on valueSet\n    function orer(recur, current, valueSet){\n        return (valueSet.length === 0) ?\n            current :\n            recur(current || !!j.first(valueSet), j.rest(valueSet));\n    }\n\n    function or(){\n        return recur(orer, false, j.slice(0, arguments));\n    }\n\n    function xor(a, b){\n        return !!(or(a, b) && j.not(j.isTruthy(a) === j.isTruthy(b)));\n    }\n\n    //Produces a function that returns f(g(x))\n    function compositor(f, g){\n        return function(){\n            return f(j.apply(g, j.slice(0, arguments)));\n        };\n    }\n\n    function compose(){\n        var args = j.slice(0, arguments);\n        return (args.length >= 1) ? reduce(compositor, args) : j.identity;\n    }\n\n    function pipeline(value){\n        return j.apply(compose, j.slice(1, arguments).reverse())(value);\n    }\n\n    function unique(valueSet){\n        var values = j.slice(0, valueSet).sort(),\n            finalValues = [];\n\n        function operator(value){\n            finalValues = j.eitherIf(finalValues,\n                                     j.conj(value, finalValues),\n                                     j.compose(j.not,\n                                               j.partial(j.equal, value),\n                                               j.last)(finalValues));\n        }\n\n        j.each(operator, values);\n\n        return finalValues;\n    }\n\n    function partialReverse(){\n        var args = j.slice(0, arguments),\n            partialAndReverse = j.compose(j.reverseArgs, j.partial);\n            \n        return j.apply(partialAndReverse, args);\n    }\n\n\n    j.and = and;\n    j.compact = j.partial(j.filter, j.isTruthy);\n    j.compose = compose;\n    j.curry = curry;\n    j.or = or;\n    j.partialReverse = partialReverse;\n    j.pipeline = pipeline;\n    j.recur = recur;\n    j.reduce = reduce;\n    j.unique = unique;\n    j.xor = xor;\n\n})(jfp);\n\n\n(function(j){\n    'use strict';\n\n//This is a recursive add fn\n    function adder(recur, current, valueSet){\n        return (valueSet.length === 0) ?\n                current :\n                recur(current + j.first(valueSet), j.rest(valueSet));\n    }\n    \n    function add(a, b){\n        return j.recur(adder, 0, j.slice(0, arguments));\n    }\n    \n    //This is a recursive divide fn\n    function divider(recur, current, valueSet){\n        return (valueSet.length === 0) ?\n                current :\n                recur(current / j.first(valueSet), j.rest(valueSet));\n    }\n    \n    function divide(){\n        var args = j.slice(0, arguments),\n            first = args.length ? j.first(args) : 1;\n        return j.recur(divider, first, j.rest(args));\n    }\n    \n    //This is a recursive multiply fn\n    function multiplier(recur, current, valueSet){\n        return (valueSet.length === 0) ?\n                current :\n                recur(current * j.first(valueSet), j.rest(valueSet));\n    }\n    \n    function multiply(){\n        return j.recur(multiplier, 1, j.slice(0, arguments));\n    }\n    \n    //This is a recursive subtraction fn\n    function subtractor(recur, current, valueSet){\n        return (valueSet.length === 0) ?\n                current :\n                recur(current - j.first(valueSet), j.rest(valueSet));\n    }\n    \n    function subtract(){\n        var args = j.slice(0, arguments),\n            first = args.length ? j.first(args) : 0;\n        return j.recur(subtractor, first, j.rest(args));\n    }\n\n    //This is a recursive constructor function for ranges\n    function rangeRecurCheck(m, n, inc){\n        return inc > 0 ? (m + inc) < n : (m + inc) > n;\n    }\n\n    function rangeBuilder(recur, currentRange, m, n, inc){\n        var finalRange = rangeRecurCheck(m - inc, n, inc) ?\n                            j.conj(m, currentRange) :\n                            currentRange;\n        \n        return rangeRecurCheck(m, n, inc) ?\n                recur(finalRange, m + inc, n, inc) :\n                finalRange;\n    }\n    \n    function range(a, b, inc){\n        var start = j.isUndefined(b) ? 0 : a,\n            end = j.isUndefined(b) ? j.either(0, a) : b,\n            increment = (!inc) ? 1 : inc;\n            \n        return j.recur(rangeBuilder,\n                       [],\n                       j.either(0, start),\n                       j.either(0, end),\n                       increment);\n    }\n\n    function mod(a, b){\n        return j.isUndefined(b) ? j.either(0, a) : a%b;\n    }\n\n    function modulo(a, b){\n        var _a = j.either(0, a),\n            _b = j.either(0, b);\n\n        return (_a > 0) ? mod(_a, _b) : _b * (Math.floor(Math.abs(_a)/_b) + 1) + _a;\n    }\n\n    function truncate(value){\n        return (value > 0) ? Math.floor(value) : Math.floor(value) + 1;\n    }\n    \n    function max(a, b){\n        var maxValue = -Number.MAX_VALUE,\n            _a = j.isUndefined(a) ? maxValue : a,\n            _b = j.isUndefined(b) ? maxValue : b;\n            \n        maxValue = (_a > maxValue) ? _a : maxValue;\n        maxValue = (_b > maxValue) ? _b : maxValue;\n        \n        return maxValue;\n    }\n    \n    function min(a, b){\n        var minValue = Number.MAX_VALUE,\n            _a = j.isUndefined(a) ? minValue : a,\n            _b = j.isUndefined(b) ? minValue : b;\n        \n        minValue = (_a < minValue) ? _a : minValue;\n        minValue = (_b < minValue) ? _b : minValue;\n        \n        return minValue;\n    }\n\n    function fac(value){\n        var factorial = j.compose(j.partial(j.reduce, multiply),\n                                  j.partial(range, 1),\n                                  j.partial(add, 1));\n\n        return j.either(1, j.when(j.greater(value, 0), factorial, value));\n    }\n\n    j.add = add;\n    j.divide = divide;\n    j.fac = fac;\n    j.inc = j.partial(j.add, 1);\n    j.max = max;\n    j.min = min;\n    j.mod = mod;\n    j.modulo = modulo;\n    j.multiply = multiply;\n    j.range = range;\n    j.subtract = subtract;\n    j.truncate = truncate;\n\n})(jfp);\n\n\n(function(j){\n\n    function throwWhenNotComparable(a, b){\n        j.when(j.isUndefined(a) || j.isUndefined(b), function(){\n            throw new TypeError('Inequality comparisons require two values');\n        });\n    }\n\n    function equal(a, b){\n        var isNotUndefined = j.compose(j.not, j.isUndefined);\n        return (isNotUndefined(a) && isNotUndefined(b)) ? a === b : false;\n    }\n\n    function greater(a, b){\n        throwWhenNotComparable(a, b);\n        return a > b;\n    }\n\n    function less(a, b){\n        throwWhenNotComparable(a, b);\n        return a < b;\n    }\n\n    function isEven(value){\n        return equal(0, j.mod(value, 2));\n    }\n\n    function isPositive(value){\n        return greater(value, 0);\n    }\n\n    function isZero(value){\n        return value === 0;\n    }\n\n    function isNegative(value){\n        return j.compose(j.not, j.or)(isPositive(value), isZero(value));\n    }\n\n    function isInt(value){\n        return equal(j.truncate(value), value);\n    }\n\n    j.isEven = isEven;\n    j.isInt = isInt;\n    j.isNegative = isNegative;\n    j.isNonNegative = j.compose(j.not, isNegative);\n    j.isNonPositive = j.compose(j.not, isPositive);\n    j.isNonZero = j.compose(j.not, isZero);\n    j.isOdd = j.compose(j.not, isEven);\n    j.isPositive = isPositive;\n    j.isZero = isZero;\n\n    //Special case predicate naming is intended for these functions\n    //There is a general expectation that these not be named with 'is'\n    j.equal = equal;\n    j.geq = j.compose(j.not, less);\n    j.greater = greater;\n    j.leq = j.compose(j.not, greater);\n    j.less = less;\n\n})(jfp);\n\nvar j = jfp;\n\nif(typeof module !== 'undefined' && !!module.exports){\n    module.exports = j;\n}\n\n\n"]}