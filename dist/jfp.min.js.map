{"version":3,"sources":["jfp.js"],"names":["jfp","resolveFunction","functionValue","curryAlias","args","slice","arguments","apply","curry","pickAlias","key","value","cleanKey","Boolean","pick","partial","chooseResolver","resolveToPick","charAt","resolver","j","isUndefined","undefined","not","equal","a","b","missingValues","isType","typeString","getType","isNumeric","pattern","number","numericString","match","isTruthy","typeCheckReduction","result","isPrimitive","primitiveNames","reduce","bind","isTuple","size","list","length","hasFirst","either","isEmptyString","isNull","isArray","isBoolean","isFunction","isNumber","isObject","isString","isPair","isSingle","isTriple","identity","valueType","Object","prototype","toString","call","empty","array","boolean","null","object","string","none","just","begin","valueSet","end","values","Array","maybe","type","typeOkay","defaultValue","testValue","option","shortCircuit","fn","optionValue","userFn","when","checkValue","eitherIf","predicateValue","safePredicate","eitherWhen","sanitizedFn","concat","original","extension","sanitizedExtension","i","push","basePartial","direction","appliedFunction","applicationArgs","splitPartial","baseFn","left","right","leftApplied","reverseArgs","reverse","countArguments","execute","rpartial","toDec","parseInt","copyArray","makeValueArray","conj","dest","cons","source","first","lastIndex","last","drop","index","finalIndex","sanitizedIndex","firstArray","secondArray","dropLast","nth","rest","take","count","naturalComparator","comparison","sort","comparator","finalSet","each","userArray","sanitizedArray","dropFirst","init","valueMap","pickResult","getKeys","obj","keys","mergeValue","dataObj","mergedObj","merge","baseObj","mergeData","finalObj","argumentCount","appliedFn","recursor","recurFn","recursorFn","localRecursor","verifyRecurValue","recurValue","recur","recursingFn","reducer","reduction","collection","appliedReducer","initialState","hasInitialState","initialValue","remainder","compositor","f","g","$f","$g","compositeFn","compose","pipeline","partialReverse","clone","originalValue","depth","depthOkay","geq","copyOkay","copy","container","newDepth","err","RangeError","maybeType","optionType","eitherType","mapper","finalArray","map","mapperFn","filterer","userPredicate","filter","predicate","filterFn","compact","valueList","predicateAccumulator","total","sanitizedTotal","numberOf","accumulator","captureUnique","finalList","unique","union","set1","set2","addToHash","finalObject","buildValueHash","captureIntersection","valueHash","intersect","setHash","captureDifference","difference","symmetricDifference","setUnion","setIntersection","everyReducer","every","finder","done","find","someRecur","some","contains","partitioner","partitions","partition","sanitizedPredicate","multiPartitioner","partitionPredicate","computedPartitions","multiPartition","predicateArgs","sanitizedArgs","sanitizedList","firstExists","ander","orer","reduceConditions","conditionArgs","operator","initialCondition","and","or","xor","equivalent","keyReduction","toValues","dereferencer","dataObject","token","trim","internalDeref","baseData","sanitizedDefault","keyTokens","split","deref","sanitizedKey","sanitizedData","plucker","pluckKeys","sanitizedObject","pluck","transformer","transformation","transform","adder","current","add","divider","divide","multiplier","multiply","subtractor","subtract","rangeRecurCheck","m","n","inc","rangeBuilder","currentRange","finalRange","range","start","increment","mod","modulo","_a","_b","Math","floor","abs","truncate","max","maxValue","Number","MAX_VALUE","min","minValue","fac","factorial","greater","throwWhenNotComparable","TypeError","less","isInt","isNegative","isPositive","isZero","isEven","isNonNegative","isNonPositive","isNonZero","isOdd","leq","module","exports"],"mappings":"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","file":"jfp.min.js","sourcesContent":["var jfp = (function(){\n    'use strict';\n    \n    function resolveFunction(functionValue){\n        return typeof functionValue === 'string' ? jfp[functionValue] : functionValue;\n    }\n    \n    function curryAlias(){\n        var args = jfp.slice(0, arguments);\n\n        args[0] = resolveFunction(args[0]);\n        \n        return jfp.apply(jfp.curry, args);\n    }\n    \n    function pickAlias(key, value){\n        var cleanKey = key.slice(1);\n        \n        return Boolean(value) ? jfp.pick(cleanKey, value) : jfp.partial(jfp.pick, cleanKey);\n    }\n    \n    function chooseResolver(value){\n        var resolveToPick = typeof value === 'string' && value.charAt(0) === ':';\n        \n        return resolveToPick ? pickAlias : curryAlias;\n    }\n    \n    return function(){\n        var args = jfp.slice(0, arguments),\n            resolver = chooseResolver(args[0]);\n        \n        return jfp.apply(resolver, args);\n    };\n    \n})();\n\n(function(j){\n    'use strict';\n\n    function isUndefined(value){\n        return value === undefined;\n    }\n    \n    function not(value){\n        return !Boolean(value);\n    }\n    \n    function equal (a, b) {\n        var missingValues = isUndefined(a) || isUndefined(b);\n        return not(missingValues) && a === b;\n    }\n\n    function isType (typeString, value) {\n        return j.equal(j.getType(value), typeString);\n    }\n    \n    function isNumeric(value){\n        var pattern = /^(0x)?[0-9]+((\\.[0-9]+)|(e\\-?[0-9]+))?$/,\n            number = isType('number', value),\n            numericString = isType('string', value) && Boolean(value.match(pattern));\n            \n        return number || numericString;\n    }\n    \n    function isTruthy(value){\n        return Boolean(value);\n    }\n    \n    function typeCheckReduction (value, result, typeString){\n        return result || isType(typeString, value);\n    }\n    \n    function isPrimitive (value) {\n        var primitiveNames = ['number',\n                              'string',\n                              'boolean',\n                              'undefined'];\n\n        return primitiveNames.reduce(typeCheckReduction.bind(null, value), equal(null, value));\n    }\n\n    function isTuple (size, list) {\n        return isType('array', list) && list.length === size;\n    }\n    \n    function hasFirst (list) {\n        return not(isUndefined(j.either([], list, 'array')[0]));\n    }\n\n    // Equality\n    j.equal = equal;\n    j.isEmptyString = equal.bind(null, '');\n    j.isNull = equal.bind(null, null);\n\n    // Types\n    j.isType = isType;\n    j.isArray = isType.bind(null, 'array');\n    j.isBoolean = isType.bind(null, 'boolean');\n    j.isFunction = isType.bind(null, 'function');\n    j.isNumber = isType.bind(null, 'number');\n    j.isObject = isType.bind(null, 'object');\n    j.isString = isType.bind(null, 'string');\n    j.isUndefined = isType.bind(null, 'undefined');\n\n    // Tuples\n    j.isTuple = isTuple;\n    j.isPair = isTuple.bind(null, 2);\n    j.isSingle = isTuple.bind(null, 1);\n    j.isTriple = isTuple.bind(null, 3);\n\n    //Other predicates\n    j.hasFirst = hasFirst;\n    j.isNumeric = isNumeric;\n    j.isPrimitive = isPrimitive;\n    j.isTruthy = isTruthy;\n    j.not = not;\n\n})(jfp);\n\n\n(function(j){\n    'use strict';\n\n    function identity(value){\n        return value;\n    }\n\n    function getType (value) {\n        var valueType = typeof value,\n            isArray = valueType === 'object' && Object.prototype.toString.call(value) === '[object Array]';\n            \n        return isArray ? 'array' : valueType;\n    }\n\n    function empty (typeString) {\n        return {\n                array: [],\n                boolean: false,\n                'null': null,\n                number: 0,\n                object: {},\n                string: ''\n            }[typeString];\n    }\n\n    function none (typeString) {\n        var result = empty(typeString);\n        return getType(result) !== 'undefined' ? result : null;\n    }\n\n    function just(value) {\n        return getType(value) !== 'undefined' ? identity(value) : none();\n    }\n\n    function slice(begin, valueSet, end){\n        var values = j.not(j.isTruthy(valueSet)) ? [] : valueSet;\n\n        return j.not(j.isTruthy(end)) ?\n                    Array.prototype.slice.call(values, begin) :\n                    Array.prototype.slice.call(values, begin, end);\n    }\n\n    function maybe(value){\n        var type = arguments[1],\n            valueType = getType(value),\n            typeOkay = valueType === type || valueType === 'array' && type === 'object';\n        \n        return typeOkay || (!type && Boolean(value)) ? value : null;\n    }\n\n    function either(defaultValue, testValue){\n        var type = arguments[2];\n        return maybe(testValue, type) === null ? defaultValue : testValue;\n    }\n    \n    function option (value, typeString) {\n        return either(none(typeString), maybe(value, typeString));\n    }\n    \n    function shortCircuit(defaultValue, fn, optionValue){\n        var type = optionValue === 0 ? 'number' : arguments[3];\n        return maybe(optionValue, type) !== null ? fn(optionValue) : defaultValue;\n    }\n\n    function apply(userFn, args){\n        return userFn.apply(null, args);\n    }\n\n    function when(checkValue, userFn){\n        var args = slice(2, arguments);\n        return j.isTruthy(checkValue) ? apply(userFn, args) : null;\n    }\n\n    function eitherIf(defaultValue, testValue, predicateValue){\n        var safePredicate = j.isUndefined(predicateValue) ? true : predicateValue;\n\n        return j.either(defaultValue, j.when(safePredicate, j.partial(j.identity, testValue)));\n    }\n\n    function eitherWhen(defaultValue, predicateValue, userFn){\n        var sanitizedFn = eitherIf(j.identity, userFn, j.isFunction(userFn));\n\n        return j.either(defaultValue, j.when(predicateValue, sanitizedFn));\n    }\n\n    function concat(original, extension){\n        var result = slice(0, either([], original)),\n            sanitizedExtension = either([], extension),\n            i;\n\n        //This is the most performant way to handle concatenation. Trust me.\n        for(i = 0; i < sanitizedExtension.length; i++){\n            result.push(sanitizedExtension[i]);\n        }\n\n        return result;\n    }\n\n    function basePartial(direction, userFn){\n        var args = slice(2, arguments);\n\n        return function appliedFunction(){\n            var applicationArgs = (direction === 'left') ?\n                                    concat(args, slice(0, arguments)) :\n                                    concat(slice(0, arguments), args);\n\n            return apply(userFn, applicationArgs);\n        };\n    }\n\n    function splitPartial (baseFn, left, right) {\n        var leftApplied = apply(basePartial, concat(['left', baseFn], left));\n        return apply(basePartial, concat(['right', leftApplied], right));\n    }\n\n    function reverseArgs(userFn){\n        return function(){\n            var args = j.slice(0, arguments).reverse();\n            return j.apply(userFn, args);\n        };\n    }\n\n    function countArguments(userFn){\n        return either(function(){}, userFn).length;\n    }\n\n    function execute(userFn){\n        return j.apply(userFn, j.slice(1, arguments));\n    }\n    \n    j.apply = apply;\n    j.concat = concat;\n    j.countArguments = countArguments;\n    j.either = either;\n    j.eitherIf = eitherIf;\n    j.eitherWhen = eitherWhen;\n    j.empty = empty;\n    j.execute = execute;\n    j.getType = getType;\n    j.identity = identity;\n    j.just = just;\n    j.maybe = maybe;\n    j.none = none;\n    j.option = option;\n    j.partial = basePartial('left', basePartial, 'left');\n    j.reverseArgs = reverseArgs;\n    j.rpartial = basePartial('left', basePartial, 'right');\n    j.shortCircuit = shortCircuit;\n    j.slice = slice;\n    j.splitPartial = splitPartial;\n    j.when = when;\n\n})(jfp);\n\n\n(function(j){\n    'use strict';\n\n    function toDec(value){\n        return (j.isNumeric(value)) ? parseInt(value, 10) : null;\n    }\n\n    j.toDec = toDec;\n\n})(jfp);\n\n(function(j){\n    'use strict';\n\n    function copyArray(valueSet){\n        return j.slice(0, valueSet);\n    }\n\n    function makeValueArray(value){\n        return j.not(j.isUndefined(value)) ? [value] : [];\n    }\n\n    function conj(value, dest){\n        return j.concat(copyArray(dest), makeValueArray(value));\n    }\n\n    function cons(value, source){\n        return j.concat(makeValueArray(value), source);\n    }\n\n    function first(values){\n        return j.isArray(values) ? j.either(null, values[0]) : null;\n    }\n\n    function lastIndex(values){\n        return j.isArray(values) ? values.length - 1 : null;\n    }\n\n    function last(values){\n        return j.isArray(values) ? values[lastIndex(values)] : null;\n    }\n\n    function drop(index, valueSet){\n        var finalIndex = lastIndex(valueSet),\n\n            sanitizedIndex = (index === 0 || index === finalIndex) ?\n                index : j.either(1, index) - 1,\n\n            firstArray = (sanitizedIndex === 0) ?\n                [] : j.slice(0, valueSet, sanitizedIndex),\n\n            secondArray = (sanitizedIndex === finalIndex)?\n                [] : j.slice(sanitizedIndex + 1, valueSet);\n\n        return j.concat(firstArray, secondArray);\n    }\n\n    function dropLast(valueSet){\n        return drop(lastIndex(valueSet), valueSet);\n    }\n\n    function nth(index, valueSet){\n        return j.either(null, j.either([], valueSet)[index]);\n    }\n\n    function rest(values){\n        return j.slice(1, values);\n    }\n\n    function take(count, values){\n        return j.isArray(values) ? j.slice(0, values, count) : null;\n    }\n\n    function naturalComparator(a, b){\n        var comparison = a < b ? -1 : 1;\n        return a === b ? 0 : comparison;\n    }\n\n    function sort(optionValue, valueSet){\n        var comparator = j.isFunction(optionValue) ? optionValue : naturalComparator,\n            finalSet = j.isArray(optionValue) ? j.slice(0, optionValue) : j.slice(0, valueSet);\n\n        return finalSet.sort(comparator);\n    }\n\n    function each(userFn, userArray){\n        var sanitizedArray = j.either([], userArray),\n            sanitizedFn = j.either(j.identity, userFn),\n            i;\n\n        for(i = 0; i < sanitizedArray.length; i++){\n            if(sanitizedFn(sanitizedArray[i], i) === false){\n                break;\n            }\n        }\n\n        return sanitizedArray;\n    }\n\n    j.conj = conj;\n    j.cons = cons;\n    j.copyArray = copyArray;\n    j.drop = drop;\n    j.dropFirst = j.partial(drop, 0);\n    j.dropLast = dropLast;\n    j.each = each;\n    j.first = first;\n    j.init = j.dropLast;\n    j.last = last;\n    j.lastIndex = lastIndex;\n    j.nth = nth;\n    j.rest = rest;\n    j.sort = sort;\n    j.take = take;\n\n})(jfp);\n\n\n(function(j){\n    'use strict';\n\n    function pick(key, valueMap){\n        var pickResult = j.either({}, valueMap)[key];\n        return j.isUndefined(pickResult) ? null : pickResult;\n    }\n\n    function getKeys (obj) {\n        return Object.keys(j.either({}, obj, 'object'));\n    }\n\n    function mergeValue (dataObj, mergedObj, key) {\n        mergedObj[key] = dataObj[key];\n        return mergedObj;\n    }\n\n    function merge(baseObj, mergeData){\n        var finalObj = null;\n        \n        if (j.maybe(baseObj) !== null) {\n            finalObj = getKeys(baseObj).reduce(j.partial(mergeValue, baseObj), {});\n            finalObj = getKeys(mergeData).reduce(j.partial(mergeValue, mergeData), finalObj);\n        }\n\n        return finalObj;\n    }\n\n    j.getKeys = getKeys;\n    j.merge = merge;\n    j.pick = pick;\n\n})(jfp);\n\n\n(function(j){\n    'use strict';\n\n    //This is complicated and I don't expect people to grok it on first read.\n    function curry(userFn){\n        var args = j.slice(1, arguments),\n            argumentCount = j.countArguments(userFn),\n            appliedFn = (args.length < argumentCount) ? j.apply(j.partial, j.concat([curry, userFn], args)) : null,\n            result = (Boolean(userFn) && args.length >= argumentCount) ? j.apply(userFn, args) : null;\n\n        return j.either(appliedFn, result);\n    }\n\n    //zOMG! TAIL OPTIMIZED RECURSION\n    function recursor(recurFn){\n        var args = j.slice(1, arguments);\n\n        //This is to make the returned function distinct and identifiable.\n        return function recursorFn(localRecursor){\n            return j.apply(recurFn, j.concat([localRecursor], args));\n        };\n    }\n\n    function verifyRecurValue(recurValue){\n        return typeof recurValue === 'function' &&\n            recurValue.toString().match('recursorFn');\n    }\n\n    //Tail optimization with managed recursion is really complicated.\n    //Please don't muck with this unless you TRULY understand what is happening.\n    function recur(userFn){\n        var recursingFn = j.either(j.identity, userFn, 'function'),\n            localRecursor = j.partial(recursor, recursingFn),\n            recurValue = j.apply(localRecursor, j.slice(1, arguments));\n\n        while(verifyRecurValue(recurValue = recurValue(localRecursor)) && recursingFn !== j.identity);\n\n        return recurValue;\n    }\n\n\t/*\n     * Reduce uses tail-optimized (while-trampolined, fully returning) recursion to resolve reductions.\n     * Reducer is a pure function for handling a single reduction step.\n     * Reduce manages the setup and recursion execution.\n     */\n    function reducer(userFn, recur, reduction, collection){\n        return collection.length === 0 ?\n                    reduction :\n                    recur(userFn(reduction, j.first(collection)),\n                          j.rest(collection));\n    }\n\n    function reduce(userFn, values){\n        var appliedReducer = j.partial(reducer, userFn),\n            initialState = arguments[2],\n            hasInitialState = typeof initialState !== 'undefined',\n            \n            initialValue = !hasInitialState ? j.first(values) : initialState,\n            remainder = !hasInitialState ? j.rest(values) : values;\n\n        return (Boolean(values) && values.length > 0) ? j.recur(appliedReducer, initialValue, remainder) : initialValue;\n    }\n\n    //Produces a function that returns f(g(x))\n    function compositor(f, g){\n        var $f = typeof f !== 'function' ? j.identity : f,\n            $g = typeof g !== 'function' ? j.identity : g;\n            \n        function compositeFn () {\n            return $f(j.apply($g, j.slice(0, arguments)));\n        }\n        \n        return compositeFn;\n    }\n\n    function compose(){\n        return reduce(compositor, j.slice(0, arguments), j.identity);\n    }\n\n    function pipeline(value){\n        return j.apply(compose, j.slice(1, arguments).reverse())(value);\n    }\n\n    function partialReverse(){\n        return j.apply(j.compose(j.reverseArgs, j.partial),\n                       j.slice(0, arguments));\n    }\n\n    function clone (originalValue, depth) {\n        var depthOkay = j.isUndefined(depth) || j.geq(depth, 0),\n            copyOkay = j.isType('object', originalValue) || j.isType('array', originalValue);\n        \n        function copy () {\n            var keys = Object.keys(originalValue),\n                container = j.isArray(originalValue) ? [] : {};\n            \n            j.each(function (key) {\n                var newDepth = j.isNumber(depth) ? depth - 1 : undefined;\n                \n                try {\n                    container[key] = clone(originalValue[key], newDepth);\n                } catch (err) {\n                    throw new RangeError('Object contains circular reference or is too deep to clone.');\n                }\n                \n            }, keys);\n            \n            return container;\n        }\n        \n        return copyOkay && depthOkay ? copy() : originalValue;\n    }\n\n    function maybeType (typeString) {\n        return j.curry(function (value) {\n            return j.maybe(value, typeString);\n        }).apply(j, j.slice(1, arguments));\n    }\n    \n    function optionType (typeString, value) {\n        return !j.isUndefined(value) ? j.option(value, typeString) : j.rpartial(j.option, typeString);\n    }\n    \n    function eitherType (typeString) {\n        return j.curry(function (defaultValue, optionValue) {\n            return j.either(defaultValue, optionValue, typeString);\n        }).apply(j, j.slice(1, arguments));\n    }\n    \n    j.clone = clone;\n    j.compose = compose;\n    j.curry = curry;\n    j.eitherType = eitherType;\n    j.maybeType = maybeType;\n    j.optionType = optionType;\n    j.partialReverse = partialReverse;\n    j.pipeline = pipeline;\n    j.recur = recur;\n    j.reduce = reduce;\n\n})(jfp);\n\n\n(function(j){\n\t\n    /*\n     * Map uses reduce to produce a new, completely reference-decoupled list of values\n     * Mapper handles a single update step for the final output array\n     */\n    function mapper(userFn, finalArray, value){\n        finalArray.push(userFn(value));\n        return finalArray;\n    }\n\n    function map (userFn, values) {\n        var mapperFn = j.partial(mapper, userFn);\n        return j.reduce(mapperFn, values, []);\n    }\n    \n    /*\n     * Filter uses reduce to produce a new, completely reference-decoupled list of values\n     * Filterer handles a single update step for the final output array\n     */\n    function filterer(userPredicate, finalArray, value){\n        return userPredicate(value) ? j.conj(value, finalArray) : finalArray;\n    }\n\n    function filter (predicate, values) {\n        var filterFn = j.partial(filterer, predicate);\n        return j.reduce(filterFn, values, []);\n    }\n    \n    function compact(valueList){\n        return filter(j.isTruthy, valueList);\n    }\n\n    function predicateAccumulator(predicate, total, value){\n        var sanitizedTotal = j.either(0, total, 'number');\n        return predicate(value) ? sanitizedTotal + 1 : sanitizedTotal;\n    }\n\n    function numberOf(predicate, valueSet){\n        var accumulator = j.partial(predicateAccumulator, predicate);\n        return j.reduce(accumulator, j.either([], valueSet), 0);\n    }\n\n    function captureUnique(finalList, value){\n        return j.last(finalList) === value ? finalList : j.conj(value, finalList);\n    }\n    \n    function unique(valueSet){\n        return j.reduce(captureUnique, j.sort(j.slice(0, valueSet)), []);\n    }\n\n    function union(set1, set2){\n        return j.compose(j.unique, j.concat)(set1, set2);\n    }\n\n    function addToHash(finalObject, value){\n        finalObject[value] = true;\n        return finalObject;\n    }\n\n    function buildValueHash(valueList){\n        return j.either({}, j.reduce(addToHash, valueList, {}));\n    }\n\n    function captureIntersection(valueHash, finalList, value){\n        return valueHash[value] ? j.conj(value, finalList) : finalList;\n    }\n    \n    function intersect(set1, set2){\n        var setHash = buildValueHash(j.either([], set2));\n        return j.reduce(j.partial(captureIntersection, setHash), set1, []); \n    }\n\n    function captureDifference(valueHash, finalList, value){\n        return !valueHash[value] ? j.conj(value, finalList) : finalList;\n    }\n    \n    function difference(set1, set2){\n        var setHash = buildValueHash(j.either([], set2));\n        return j.reduce(j.partial(captureDifference, setHash), set1, []);\n    }\n\n    function symmetricDifference(set1, set2){\n        var setUnion = union(set1, set2),\n            setIntersection = intersect(set1, set2);\n\n        return difference(setUnion, setIntersection);\n    }\n\n    function everyReducer (predicate, result, valueList){\n        return result && predicate(valueList);\n    }\n\n    function every (predicate, valueList){\n        var reducer = j.partial(everyReducer, predicate);\n        return Boolean(j.reduce(reducer, valueList, true));\n    }\n\n    function finder (recur, predicate, valueList) {\n        var done = !Boolean(valueList) || valueList.length === 0,\n            result = done ? null : j.first(valueList);\n        \n        return done || predicate(result) ? result : recur(predicate, j.rest(valueList));\n    }\n\n    function find (predicate, valueList){\n        return j.recur(finder, predicate, valueList);\n    }\n\n    function someRecur(recur, predicate, valueList){\n        var done = valueList.length === 0,\n            result = done ? false : predicate(j.first(valueList));\n            \n        return result || done ? result : recur(predicate, j.rest(valueList));\n    }\n\n    function some(predicate, valueList){\n        return Boolean(j.recur(someRecur, predicate, valueList));\n    }\n    \n    function contains(value, valueList){\n        return some(j.partial(j.equal, value), valueList);\n    }\n\n    function partitioner(predicate, partitions, value){\n        var index = predicate(value) ? 0 : 1;\n\n        partitions[index].push(value);\n\n        return partitions;\n    }\n\n    function partition(predicate, list){\n        var sanitizedPredicate = j.either(j.identity, predicate, 'function');\n        \n        return j.reduce(j.partial(partitioner, sanitizedPredicate),\n                        j.either([], list),\n                        [[], []]);\n    }\n\n    function multiPartitioner(predicate, partitions, value){\n        var partitionPredicate = j.rpartial(predicate, value),\n            computedPartitions = j.dropLast(partitions);\n        \n        return j.concat(computedPartitions, partition(partitionPredicate, j.last(partitions)));\n    }\n    \n    function multiPartition(predicate, predicateArgs, list){\n        var sanitizedArgs = j.either([], predicateArgs),\n            sanitizedPredicate = j.either(j.identity, predicate),\n            sanitizedList = j.either([], list);\n            \n        return !Boolean(list) ?\n                [[], []] :\n                j.reduce(j.partial(multiPartitioner, sanitizedPredicate),\n                         sanitizedArgs,\n                         [sanitizedList]);\n    }\n\n    function firstExists (list) {\n        return j.not(j.isNull(j.first(list)));\n    }\n\n    j.contains = contains;\n    j.compact = compact;\n    j.difference = difference;\n    j.every = every;\n\tj.filter = filter;\n    j.find = find;\n    j.firstExists = firstExists;\n    j.intersect = intersect;\n\tj.map = map;\n\tj.multiPartition = multiPartition;\n\tj.numberOf = numberOf;\n    j.partition = partition;\n    j.some = some;\n    j.symmetricDifference = symmetricDifference;\n    j.union = union;\n    j.unique = unique;\n\n})(jfp);\n\n(function (j) {\n\t'use strict';\n\t\n\t//Performs 'and' operation on valueSet\n    function ander(a, b){\n        return a && b;\n    }\n\n    function orer(a, b){\n        return a || b;\n    }\n\n    function reduceConditions(conditionArgs, operator, initialCondition){\n        var args = j.map(Boolean, j.slice(0, conditionArgs));\n        return Boolean(j.reduce(operator, args, initialCondition));\n    }\n\n    function and(a, b){\n        return reduceConditions(arguments, ander, true);\n    }\n\n    function or(a, b){\n        return reduceConditions(arguments, orer, false);\n    }\n\n    function xor(a, b){\n        var equivalent = Boolean(a) === Boolean(b);\n        return or(a, b) && j.not(equivalent);\n    }\n\n\tj.and = and;\n\tj.or = or;\n\tj.xor = xor;\n\n})(jfp);\n\n(function (j) {\n\t'use strict';\n\t\n    /*\n     * toValues converts an object to an array of values\n     * This is necessary for reduce to convert objects into\n     * processible arrays in an upcoming version.\n     */\n\tfunction keyReduction (baseObj, finalList, key) {\n\t\treturn j.conj(baseObj[key], finalList);\n\t}\n\t\n\tfunction toValues (baseObj) {\n\t\tvar reducer = j.partial(keyReduction, baseObj);\n\t\treturn j.isNull(j.maybe(baseObj, 'object')) ? null : j.reduce(reducer, Object.keys(baseObj), []);\n\t}\n\n\tfunction dereferencer(dataObject, token){\n        var key = j.either('', token).trim();\n        return key === '' ? dataObject : j.pick(token, dataObject);\n    }\n\n    function internalDeref(key, baseData, defaultValue){\n        var sanitizedDefault = defaultValue === undefined ? null : defaultValue,\n            keyTokens = key.split('.'),\n            result = j.reduce(dereferencer, keyTokens, baseData);\n        \n        return j.either(sanitizedDefault, result);\n    }\n    \n    function deref(key, baseData, defaultValue){\n        // Satisifes backwards-compatibility case where key an data are reversed\n        var sanitizedKey = typeof key === 'string' ? key : baseData,\n            sanitizedData = typeof baseData === 'object' ? baseData : key;\n        \n        // Fully sanitize data before executing the dereference function\n        sanitizedKey = j.either('', sanitizedKey, 'string');\n        sanitizedData = j.either(null, sanitizedData, 'object');\n        \n        return internalDeref(j.either('', sanitizedKey), sanitizedData, defaultValue);\n    }\n    \n    function plucker (baseObj, finalObj, key){\n        finalObj[key] = baseObj[key];\n        return finalObj;\n    }\n    \n    function pluckKeys (keys, baseObj){\n        var sanitizedObject = j.either({}, baseObj, 'object');\n        return j.reduce(j.partial(plucker, sanitizedObject), keys, {});\n    }\n    \n    function pluck (key, baseObj) {\n        return pluckKeys([key], baseObj);\n    }\n\n    function transformer (obj, result, transformation) {\n        result[transformation[1]] = deref(transformation[0], obj);\n        return result;\n    }\n\n    function transform (transformation, obj) {\n        return j.pipeline(transformation,\n                          j.partial(j.filter, j.isPair),\n                          j.splitPartial(j.reduce, [j.partial(transformer, obj)], [{}]));\n    }\n\n\tj.deref = deref;\n    j.pluck = pluck;\n    j.pluckKeys = pluckKeys;\n    j.toValues = toValues;\n    j.transform = transform;\n\n})(jfp);\n\n(function(j){\n    'use strict';\n\n//This is a recursive add fn\n    function adder(recur, current, valueSet){\n        return (valueSet.length === 0) ?\n                current :\n                recur(current + j.first(valueSet), j.rest(valueSet));\n    }\n    \n    function add(a, b){\n        return j.recur(adder, 0, j.slice(0, arguments));\n    }\n    \n    //This is a recursive divide fn\n    function divider(recur, current, valueSet){\n        return (valueSet.length === 0) ?\n                current :\n                recur(current / j.first(valueSet), j.rest(valueSet));\n    }\n    \n    function divide(){\n        var args = j.slice(0, arguments),\n            first = args.length ? j.first(args) : 1;\n        return j.recur(divider, first, j.rest(args));\n    }\n    \n    //This is a recursive multiply fn\n    function multiplier(recur, current, valueSet){\n        return (valueSet.length === 0) ?\n                current :\n                recur(current * j.first(valueSet), j.rest(valueSet));\n    }\n    \n    function multiply(){\n        return j.recur(multiplier, 1, j.slice(0, arguments));\n    }\n    \n    //This is a recursive subtraction fn\n    function subtractor(recur, current, valueSet){\n        return (valueSet.length === 0) ?\n                current :\n                recur(current - j.first(valueSet), j.rest(valueSet));\n    }\n    \n    function subtract(){\n        var args = j.slice(0, arguments),\n            first = args.length ? j.first(args) : 0;\n        return j.recur(subtractor, first, j.rest(args));\n    }\n\n    //This is a recursive constructor function for ranges\n    function rangeRecurCheck(m, n, inc){\n        return inc > 0 ? (m + inc) < n : (m + inc) > n;\n    }\n\n    function rangeBuilder(recur, currentRange, m, n, inc){\n        var finalRange = rangeRecurCheck(m - inc, n, inc) ?\n                            j.conj(m, currentRange) :\n                            currentRange;\n        \n        return rangeRecurCheck(m, n, inc) ?\n                recur(finalRange, m + inc, n, inc) :\n                finalRange;\n    }\n    \n    function range(a, b, inc){\n        var start = j.isUndefined(b) ? 0 : a,\n            end = j.isUndefined(b) ? j.either(0, a) : b,\n            increment = (!inc) ? 1 : inc;\n            \n        return j.recur(rangeBuilder,\n                       [],\n                       j.either(0, start),\n                       j.either(0, end),\n                       increment);\n    }\n\n    function mod(a, b){\n        return j.isUndefined(b) ? j.either(0, a) : a%b;\n    }\n\n    function modulo(a, b){\n        var _a = j.either(0, a),\n            _b = j.either(0, b);\n\n        return (_a > 0) ? mod(_a, _b) : _b * (Math.floor(Math.abs(_a)/_b) + 1) + _a;\n    }\n\n    function truncate(value){\n        return (value > 0) ? Math.floor(value) : Math.floor(value) + 1;\n    }\n    \n    function max(a, b){\n        var maxValue = -Number.MAX_VALUE,\n            _a = j.isUndefined(a) ? maxValue : a,\n            _b = j.isUndefined(b) ? maxValue : b;\n            \n        maxValue = (_a > maxValue) ? _a : maxValue;\n        maxValue = (_b > maxValue) ? _b : maxValue;\n        \n        return maxValue;\n    }\n    \n    function min(a, b){\n        var minValue = Number.MAX_VALUE,\n            _a = j.isUndefined(a) ? minValue : a,\n            _b = j.isUndefined(b) ? minValue : b;\n        \n        minValue = (_a < minValue) ? _a : minValue;\n        minValue = (_b < minValue) ? _b : minValue;\n        \n        return minValue;\n    }\n\n    function fac(value){\n        var factorial = j.compose(j.partial(j.reduce, multiply),\n                                  j.partial(range, 1),\n                                  j.partial(add, 1));\n\n        return j.either(1, j.when(j.greater(value, 0), factorial, value));\n    }\n\n    j.add = add;\n    j.divide = divide;\n    j.fac = fac;\n    j.inc = j.partial(j.add, 1);\n    j.max = max;\n    j.min = min;\n    j.mod = mod;\n    j.modulo = modulo;\n    j.multiply = multiply;\n    j.range = range;\n    j.subtract = subtract;\n    j.truncate = truncate;\n\n})(jfp);\n\n\n(function(j){\n\n    function throwWhenNotComparable(a, b){\n        j.when(j.isUndefined(a) || j.isUndefined(b), function(){\n            throw new TypeError('Inequality comparisons require two values');\n        });\n    }\n\n    function greater(a, b){\n        throwWhenNotComparable(a, b);\n        return a > b;\n    }\n\n    function less(a, b){\n        throwWhenNotComparable(a, b);\n        return a < b;\n    }\n\n    function isInt(value){\n        return j.equal(j.truncate(value), value);\n    }\n\n    var isNegative = j.partial(greater, 0),\n        isPositive = j.partial(less, 0),\n        isZero = j.partial(j.equal, 0),\n        isEven = j.compose(isZero, j.rpartial(j.mod, 2));\n\n    j.isEven = isEven;\n    j.isInt = isInt;\n    j.isNegative = isNegative;\n    j.isNonNegative = j.compose(j.not, isNegative);\n    j.isNonPositive = j.compose(j.not, isPositive);\n    j.isNonZero = j.compose(j.not, isZero);\n    j.isOdd = j.compose(j.not, isEven);\n    j.isPositive = isPositive;\n    j.isZero = isZero;\n\n    //Special case predicate naming is intended for these functions\n    //There is a general expectation that these not be named with 'is'\n    j.geq = j.compose(j.not, less);\n    j.greater = greater;\n    j.leq = j.compose(j.not, greater);\n    j.less = less;\n\n})(jfp);\n\nvar j = jfp;\n\nif(typeof module !== 'undefined' && Boolean(module.exports)){\n    module.exports = j;\n}\n\n\n"]}