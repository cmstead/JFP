<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>JFP - Javascript Function Processor</title>
  <meta name="description" content="JFP, the Javascript Function Processor is a language as a library functional programming utility for Javascript
">

  <link rel="stylesheet" href="/JFP/css/screen.css">
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/default.min.css">
  <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">

  <link rel="stylesheet" href="/JFP/page-includes/prism.css">

  <link rel="canonical" href="http://localhost:4000/JFP/api/">
  <link rel="alternate" type="application/rss+xml" title="JFP - Javascript Function Processor" href="http://localhost:4000/JFP/feed.xml" />
</head>


  <body class="language-javascript">

    <div class="head-wrapper">
    <a href="/JFP/">
        <img src="/JFP/images/jfp-logo-small.png" alt="JFP Logo" class="top-logo" />
    </a>
    
    <div class="title">
        <h1>JFP</h1>
        <ul>
            <li><a href="/JFP/v2.x">Visit v2.x docs</a></li>
        </ul>
        <h2>The Javascript Function Processor</h2>
    </div>
</div>

<div class="library-links">
</div>

    <div class="body-container">
      <div id="function-list">
    <h3>Types</h3>

<ul>
    <li><a href="/JFP/api/#either">either</a></li>
    <li><a href="/JFP/api/#either-built-ins">eitherArray</a></li>
    <li><a href="/JFP/api/#either-built-ins">eitherBoolean</a></li>
    <li><a href="/JFP/api/#either-built-ins">eitherFunction</a></li>
    <li><a href="/JFP/api/#either-built-ins">eitherInt</a></li>
    <li><a href="/JFP/api/#either-built-ins">eitherNatural</a></li>
    <li><a href="/JFP/api/#either-built-ins">eitherNumber</a></li>
    <li><a href="/JFP/api/#either-built-ins">eitherObject</a></li>
    <li><a href="/JFP/api/#either-built-ins">eitherString</a></li>
    <li><a href="/JFP/api/#either-built-ins">eitherConcatable</a></li>
    <li><a href="/JFP/api/#either-built-ins">eitherObjectInstance</a></li>
    <li><a href="/JFP/api/#either-built-ins">eitherReferencible</a></li>
    <li><a href="/JFP/api/#either-built-ins">eitherDefined</a></li>
    <li><a href="/JFP/api/#either-built-ins">eitherNotNull</a></li>
    <li><a href="/JFP/api/#enforce">enforce</a></li>
    <li><a href="/JFP/api/#istypeof">isTypeOf</a></li>
    <li><a href="/JFP/api/#maybe">maybe</a></li>
    <li><a href="/JFP/api/#maybeDefined">maybeDefined</a></li>
    <li><a href="/JFP/api/#setjfptypes">setJfpTypes</a></li>
    <li><a href="/JFP/api/#sign">sign</a></li>
    <li><a href="/JFP/api/#typeChain">typeChain</a></li>
    <li><a href="/JFP/api/#type-list">type list</a></li>
</ul>

<h3>Predicates</h3>

<ul>
    <li><a href="/JFP/api/#and">and</a></li>
    <li><a href="/JFP/api/#equal">equal</a></li>
    <li><a href="/JFP/api/#exists">exists</a></li>
    <li><a href="/JFP/api/#invert">invert</a></li>
    <li><a href="/JFP/api/#type-predicates">isArray</a></li>
    <li><a href="/JFP/api/#type-predicates">isBoolean</a></li>
    <li><a href="/JFP/api/#type-predicates">isFunction</a></li>
    <li><a href="/JFP/api/#type-predicates">isNull</a></li>
    <li><a href="/JFP/api/#type-predicates">isNumber</a></li>
    <li><a href="/JFP/api/#type-predicates">isObject</a></li>
    <li><a href="/JFP/api/#type-predicates">isObjectInstance</a></li>
    <li><a href="/JFP/api/#type-predicates">isString</a></li>
    <li><a href="/JFP/api/#type-predicates">isUndefined</a></li>
    <li><a href="/JFP/api/#type-predicates">isNil</a></li>
    <li><a href="/JFP/api/#type-predicates">isPair</a></li>
    <li><a href="/JFP/api/#type-predicates">isPredicate</a></li>
    <li><a href="/JFP/api/#type-predicates">isInt</a></li>
    <li><a href="/JFP/api/#type-predicates">isNatural</a></li>
    <li><a href="/JFP/api/#type-predicates">isObjectInstance</a></li>
    <li><a href="/JFP/api/#type-predicates">isNotNull</a></li>
    <li><a href="/JFP/api/#type-predicates">isNotNil</a></li>
    <li><a href="/JFP/api/#type-predicates">isConcatable</a></li>
    <li><a href="/JFP/api/#type-predicates">isDefined</a></li>
    <li><a href="/JFP/api/#type-predicates">isComparable</a></li>
    <li><a href="/JFP/api/#type-predicates">isNumeric</a></li>
    <li><a href="/JFP/api/#type-predicates">isReferencible</a></li>
    <li><a href="/JFP/api/#not">not</a></li>
    <li><a href="/JFP/api/#or">or</a></li>
    <li><a href="/JFP/api/#xor">xor</a></li>
</ul>

<h3>Core</h3>

<ul>
    <li><a href="/JFP/api/#always">always</a></li>
    <li><a href="/JFP/api/#apply">apply</a></li>
    <li><a href="/JFP/api/#argumentsToArray">argumentsToArray</a></li>
    <li><a href="/JFP/api/#compose">compose</a></li>
    <li><a href="/JFP/api/#concat">concat</a></li>
    <li><a href="/JFP/api/#cond">cond</a></li>
    <li><a href="/JFP/api/#conj">conj</a></li>
    <li><a href="/JFP/api/#cons">cons</a></li>
    <li><a href="/JFP/api/#curry">curry</a></li>
    <li><a href="/JFP/api/#foldlCompose">foldlCompose</a></li>
    <li><a href="/JFP/api/#foldrCompose">foldrCompose</a></li>
    <li><a href="/JFP/api/#identity">identity</a></li>
    <li><a href="/JFP/api/#partial">partial</a></li>
    <li><a href="/JFP/api/#pick">pick</a></li>
    <li><a href="/JFP/api/#rcompose">rcompose</a></li>
    <li><a href="/JFP/api/#recur">recur</a></li>
    <li><a href="/JFP/api/#repeat">repeat</a></li>
    <li><a href="/JFP/api/#reverseArgs">reverseArgs</a></li>
    <li><a href="/JFP/api/#rpartial">rpartial</a></li>
    <li><a href="/JFP/api/#slice">slice</a></li>
</ul>

<h3>Math</h3>

<ul>
    <li><a href="/JFP/api/#add">add</a></li>
    <li><a href="/JFP/api/#addBy">addBy</a></li>
    <li><a href="/JFP/api/#between">between</a></li>
    <li><a href="/JFP/api/#divide">divide</a></li>
    <li><a href="/JFP/api/#divideBy">divideBy</a></li>
    <li><a href="/JFP/api/#dec">dec</a></li>
    <li><a href="/JFP/api/#geq">geq</a></li>
    <li><a href="/JFP/api/#gt">gt</a></li>
    <li><a href="/JFP/api/#inc">inc</a></li>
    <li><a href="/JFP/api/#leq">leq</a></li>
    <li><a href="/JFP/api/#lt">lt</a></li>
    <li><a href="/JFP/api/#max">max</a></li>
    <li><a href="/JFP/api/#min">min</a></li>
    <li><a href="/JFP/api/#mod">mod</a></li>
    <li><a href="/JFP/api/#modBy">modBy</a></li>
    <li><a href="/JFP/api/#multiply">multiply</a></li>
    <li><a href="/JFP/api/#multiplyBy">multiplyBy</a></li>
    <li><a href="/JFP/api/#range">range</a></li>
    <li><a href="/JFP/api/#subtract">subtract</a></li>
    <li><a href="/JFP/api/#subtractBy">subtractBy</a></li>
</ul>

<h3>Array</h3>

<ul>
    <li><a href="/JFP/api/#all">all</a></li>
    <li><a href="/JFP/api/#compact">compact</a></li>
    <li><a href="/JFP/api/#dropLast">dropLast</a></li>
    <li><a href="/JFP/api/#dropNth">dropNth</a></li>
    <li><a href="/JFP/api/#filter">filter</a></li>
    <li><a href="/JFP/api/#first">first</a></li>
    <li><a href="/JFP/api/#find">find</a></li>
    <li><a href="/JFP/api/#foldl">foldl</a></li>
    <li><a href="/JFP/api/#foldr">foldr</a></li>
    <li><a href="/JFP/api/#lastIndexOf">lastIndexOf</a></li>
    <li><a href="/JFP/api/#map">map</a></li>
    <li><a href="/JFP/api/#none">none</a></li>
    <li><a href="/JFP/api/#nth">nth</a></li>
    <li><a href="/JFP/api/#partition">partition</a></li>
    <li><a href="/JFP/api/#pushUnsafe">pushUnsafe</a></li>
    <li><a href="/JFP/api/#rest">rest</a></li>
    <li><a href="/JFP/api/#reverse">reverse</a></li>
    <li><a href="/JFP/api/#rfilter">rfilter</a></li>
    <li><a href="/JFP/api/#rmap">rmap</a></li>
    <li><a href="/JFP/api/#rpartition">rpartition</a></li>
    <li><a href="/JFP/api/#rreduce">rreduce</a></li>
    <li><a href="/JFP/api/#some">some</a></li>
    <li><a href="/JFP/api/#sort">sort</a></li>
    <li><a href="/JFP/api/#take">take</a></li>
    <li><a href="/JFP/api/#takeUntil">takeUntil</a></li>
    <li><a href="/JFP/api/#until">until</a></li>

</ul>

<h3>Object</h3>

<ul>
    <li><a href="/JFP/api/#clone">clone</a></li>
    <li><a href="/JFP/api/#deref">deref</a></li>
    <li><a href="/JFP/api/#merge">merge</a></li>
    <li><a href="/JFP/api/#mergeToUnsafe">mergeToUnsafe</a></li>
    <li><a href="/JFP/api/#shallowClone">shallowClone</a></li>
    <li><a href="/JFP/api/#toArray">toArray</a></li>
    <li><a href="/JFP/api/#toObject">toObject</a></li>
    <li><a href="/JFP/api/#toValues">toValues</a></li>
</ul>

</div>

<div id="function-info">
    
    <h2 id="signatures">Signatures</h2>

<p>JFP is enforced with Signet types and function signatures. Signature metadata can be accessed via the signature property.
All type signature information presented in the documentation reflects the Signet signatures attached to the functions.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>j.isTypeOf.signature; // string =&gt; * =&gt; boolean
j.slice.signature; // index =&gt; array&lt;*&gt; =&gt; array&lt;*&gt;
</code></pre>
</div>

<h2 id="types">Types</h2>

<h3 id="enforce">enforce</h3>

<ul>
  <li>Performance: O(n) (for n = number of leaves in type tree)</li>
  <li>Signature: <code class="highlighter-rouge">string, function =&gt; function</code></li>
  <li>Description: Enforces intended function contract</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>var add = j.enforce('number, number =&gt; number', function add (a, b) { return a + b; });
</code></pre>
</div>

<h3 id="either">either</h3>

<ul>
  <li>Performance: O(1)</li>
  <li>Signature: <code class="highlighter-rouge">taggedUnion&lt;typeString;predicate&gt; =&gt; * =&gt; * =&gt; *</code></li>
  <li>Description: Tests type of test value and returns test value if true and default value if false</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>j.either('number')(5)(0); // 0
j.either('number')(5)('foo'); // 5
</code></pre>
</div>

<h3 id="either-built-ins">either built-ins</h3>

<p>JFP provides several pre-loaded either type functions both for speed and to help keep your code slim and trim</p>

<ul>
  <li>eitherArray – <code class="highlighter-rouge">j.either('array')</code></li>
  <li>eitherBoolean – <code class="highlighter-rouge">j.either('boolean')</code></li>
  <li>eitherFunction – <code class="highlighter-rouge">j.either('function')</code></li>
  <li>eitherInt – <code class="highlighter-rouge">j.either('int')</code></li>
  <li>eitherNatural – <code class="highlighter-rouge">j.either('natural')</code></li>
  <li>eitherNumber – <code class="highlighter-rouge">j.either('number')</code></li>
  <li>eitherObject – <code class="highlighter-rouge">j.either('object')</code></li>
  <li>eitherString – <code class="highlighter-rouge">j.either('string')</code></li>
  <li>eitherConcatable – <code class="highlighter-rouge">j.either('concatable')</code></li>
  <li>eitherObjectInstance – <code class="highlighter-rouge">j.either('objectInstance')</code></li>
  <li>eitherReferencible – <code class="highlighter-rouge">j.either('referencible')</code></li>
  <li>eitherDefined – <code class="highlighter-rouge">j.either('defined')</code></li>
  <li>eitherNotNull – <code class="highlighter-rouge">j.either('notNull')</code></li>
</ul>

<h3 id="istypeof">isTypeOf</h3>

<ul>
  <li>Performance: O(1)</li>
  <li>Signature: <code class="highlighter-rouge">string =&gt; * =&gt; boolean</code></li>
  <li>Description: Checks the type of a value</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>j.isTypeOf('string')(5); // false
j.isTypeOf('nil')(j.nil); // true
</code></pre>
</div>

<h3 id="maybe">maybe</h3>

<ul>
  <li>Performance: O(1)</li>
  <li>Signature: <code class="highlighter-rouge">taggedUnion&lt;typeString;predicate&gt; =&gt; * =&gt; maybe&lt;defined&gt;</code></li>
  <li>Description: Tests type of test value and returns test value if true and nil if false</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>j.maybe('string')('foo'); // 'foo'
j.maybe('number')('foo'); // j.nil

function isEven (x) {
    return j.isTypeOf('number')(x) &amp;&amp; x % 2 === 0;
}

j.maybe(isEven)(5); // nill
j.maybe(isEven)(5); // nill
</code></pre>
</div>

<h3 id="maybe-built-ins">maybe built-ins</h3>

<p>JFP provides a pre-loaded maybe defined type function both for speed and to help keep your code slim and trim</p>

<ul>
  <li>maybeDefined – <code class="highlighter-rouge">j.maybe('defined')</code></li>
</ul>

<h3 id="setjfptypes">setJfpTypes</h3>

<ul>
  <li>Performance: O(1)</li>
  <li>Signature: <code class="highlighter-rouge">signet =&gt; signet</code></li>
  <li>Description: Sets all JFP types on a local instance of signet</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>var signetFactory = require('signet');

var signet = setJfpTypes(signetFactory());
</code></pre>
</div>

<h3 id="sign">sign</h3>

<ul>
  <li>Performance: O(n) (for n = number of leaves in type tree)</li>
  <li>Signature: <code class="highlighter-rouge">string, function =&gt; function</code></li>
  <li>Description: Signs function with contract string</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>var add = j.sign('number, number =&gt; number', function add (a, b) { return a + b; });
</code></pre>
</div>

<h3 id="typechain">typeChain</h3>

<ul>
  <li>Performance: O(n) – linear performance based on the depth of the type chain</li>
  <li>Signature: <code class="highlighter-rouge">string =&gt; string</code></li>
  <li>Description: Provides an API to view the inheritance chain for a specified type</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>typeChain('boundedInt'); // * -&gt; number -&gt; int -&gt; boundedInt
typeChain('array'); // * -&gt; object -&gt; array
</code></pre>
</div>

<h3 id="type-list">Type List</h3>

<ul>
  <li><code class="highlighter-rouge">()</code></li>
  <li><code class="highlighter-rouge">*</code></li>
  <li><code class="highlighter-rouge">arguments</code></li>
  <li><code class="highlighter-rouge">array</code></li>
  <li><code class="highlighter-rouge">boolean</code></li>
  <li><code class="highlighter-rouge">bounded&lt;&gt;</code></li>
  <li><code class="highlighter-rouge">boundedInt&lt;&gt;</code></li>
  <li><code class="highlighter-rouge">boundedString&lt;&gt;</code></li>
  <li><code class="highlighter-rouge">comparable</code></li>
  <li><code class="highlighter-rouge">defined</code></li>
  <li><code class="highlighter-rouge">exists</code></li>
  <li><code class="highlighter-rouge">formattedString&lt;&gt;</code></li>
  <li><code class="highlighter-rouge">function</code></li>
  <li><code class="highlighter-rouge">index</code></li>
  <li><code class="highlighter-rouge">int</code></li>
  <li><code class="highlighter-rouge">maybe</code></li>
  <li><code class="highlighter-rouge">nil</code></li>
  <li><code class="highlighter-rouge">notNull</code></li>
  <li><code class="highlighter-rouge">notNil</code></li>
  <li><code class="highlighter-rouge">null</code></li>
  <li><code class="highlighter-rouge">number</code></li>
  <li><code class="highlighter-rouge">numeric</code></li>
  <li><code class="highlighter-rouge">object</code></li>
  <li><code class="highlighter-rouge">objectKey</code></li>
  <li><code class="highlighter-rouge">pair</code></li>
  <li><code class="highlighter-rouge">predicate</code></li>
  <li><code class="highlighter-rouge">string</code></li>
  <li><code class="highlighter-rouge">symbol</code></li>
  <li><code class="highlighter-rouge">taggedUnion&lt;&gt;</code></li>
  <li><code class="highlighter-rouge">tuple&lt;&gt;</code></li>
  <li><code class="highlighter-rouge">typeString</code></li>
  <li><code class="highlighter-rouge">undefined</code></li>
</ul>

<h2 id="predicates">Predicates</h2>

<h3 id="and">and</h3>

<ul>
  <li>Performance: O(1)</li>
  <li>Signature: <code class="highlighter-rouge">comparable =&gt; comparable =&gt; boolean</code></li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>j.and(true, true); // true
j.and(true, false); // false
</code></pre>
</div>

<h3 id="equal">equal</h3>

<ul>
  <li>Performance: O(1)</li>
  <li>Signature: <code class="highlighter-rouge">comparable =&gt; comparable =&gt; boolean</code></li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>j.equal(5, 5); // true;
j.equal(5, 7); // false;
j.equal(5)(7); // false;
</code></pre>
</div>

<h3 id="exists">exists</h3>

<ul>
  <li>Performance: O(1)</li>
  <li>Signature: <code class="highlighter-rouge">* =&gt; boolean</code></li>
  <li>Description: Returns true if value is not undefined and not null</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>j.exists('a string); // true
j.exists(0); // true
j.exists(null); // false
j.exists(undefined); // false
</code></pre>
</div>

<h3 id="invert">invert</h3>

<ul>
  <li>Performance: O(1)</li>
  <li>Signature: <code class="highlighter-rouge">function =&gt; function</code></li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>j.invert(j.isTypeOf('string')('foo')); // false
</code></pre>
</div>

<h3 id="or">or</h3>

<ul>
  <li>Performance: O(1)</li>
  <li>Signature: <code class="highlighter-rouge">comparable =&gt; comparable =&gt; boolean</code></li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>j.or(true, true); // true
j.or(true, false); // true
j.or(false, false); // false
</code></pre>
</div>

<h3 id="xor">xor</h3>

<ul>
  <li>Performance: O(1)</li>
  <li>Signature: <code class="highlighter-rouge">comparable =&gt; comparable =&gt; boolean</code></li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>j.xor(true, true); // false
j.xor(true, false); // true
j.xor(false, false); // false
</code></pre>
</div>

<h3 id="not">not</h3>

<ul>
  <li>Performance: O(1)</li>
  <li>Signature: <code class="highlighter-rouge">comparable =&gt; boolean</code></li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>j.not(true); // false
j.not(5); // false
</code></pre>
</div>

<h3 id="type-predicates">Type Predicates</h3>

<p>JFP provides several type type predicates, all of which are pre-loaded isTypeOf function returns:</p>

<ul>
  <li>isArray – <code class="highlighter-rouge">j.isTypeOf('array')</code></li>
  <li>isBoolean – <code class="highlighter-rouge">j.isTypeOf('boolean')</code></li>
  <li>isFunction – <code class="highlighter-rouge">j.isTypeOf('function')</code></li>
  <li>isNull – <code class="highlighter-rouge">j.isTypeOf('null')</code></li>
  <li>isNumber – <code class="highlighter-rouge">j.isTypeOf('number')</code></li>
  <li>isObject – <code class="highlighter-rouge">j.isTypeOf('object')</code></li>
  <li>isObjectInstance – <code class="highlighter-rouge">j.isTypeOf('objectInstance')</code></li>
  <li>isString – <code class="highlighter-rouge">j.isTypeOf('string')</code></li>
  <li>isUndefined – <code class="highlighter-rouge">j.isTypeOf('undefined')</code></li>
  <li>isNil – <code class="highlighter-rouge">j.isTypeOf('nil')</code></li>
  <li>isPair – <code class="highlighter-rouge">j.isTypeOf('pair')</code></li>
  <li>isPredicate – <code class="highlighter-rouge">j.isTypeOf('predicate')</code></li>
  <li>isInt – <code class="highlighter-rouge">j.isTypeOf('int')</code></li>
  <li>isNatural – <code class="highlighter-rouge">j.isTypeOf('natural')</code></li>
  <li>isNotNull – <code class="highlighter-rouge">j.isTypeOf('notNull')</code></li>
  <li>isNotNil – <code class="highlighter-rouge">j.isTypeOf('notNil')</code></li>
  <li>isConcatable – <code class="highlighter-rouge">j.isTypeOf('concatable')</code></li>
  <li>isDefined – <code class="highlighter-rouge">j.isTypeOf('defined')</code></li>
  <li>isComparable – <code class="highlighter-rouge">j.isTypeOf('comparable')</code></li>
  <li>isNumeric – <code class="highlighter-rouge">j.isTypeOf('numeric')</code></li>
  <li>isReferencible – <code class="highlighter-rouge">j.isTypeOf('referencible')</code></li>
</ul>

<h2 id="core">Core</h2>

<h3 id="always">always</h3>

<ul>
  <li>Performance: O(1)</li>
  <li>Signature: <code class="highlighter-rouge">* =&gt; [*] =&gt; *</code></li>
  <li>Description: Returns a function which always returns the originally provided value</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>var alwaysTrue = j.always(true);

alwaysTrue(); // true
alwaysTrue('over 9000'); // true
</code></pre>
</div>

<h3 id="apply">apply</h3>

<ul>
  <li>Performance: O(1)</li>
  <li>Signature: <code class="highlighter-rouge">function, array&lt;*&gt; =&gt; *</code></li>
  <li>Description: Applies array of arguments to a function</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>j.apply(add, [1, 2]); // 3
</code></pre>
</div>

<h3 id="argumentstoarray">argumentsToArray</h3>

<ul>
  <li>Performance: O(1)</li>
  <li>Signature: <code class="highlighter-rouge">variant&lt;array; arguments&gt; =&gt; array</code></li>
  <li>Description: Slices arguments or array at 0</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>j.argumentsToArray(arguments); // [object Array]
</code></pre>
</div>

<h3 id="compose">compose</h3>

<ul>
  <li>Performance: O(n) (for n = length of function list)</li>
  <li>Signature: <code class="highlighter-rouge">function, function =&gt; function</code></li>
  <li>Description: Composes two functions: compose(f, g)(x) = f(g(x))</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>var isNotNumber = j.compose(j.not, j.isNumber);

isNotNumber(5); // false
isNotNumber('string'); // true
</code></pre>
</div>

<h3 id="concat">concat</h3>

<ul>
  <li>Performance: O(n)</li>
  <li>Signature: <code class="highlighter-rouge">array&lt;*&gt;, array&lt;*&gt; =&gt; array&lt;*&gt;</code></li>
  <li>Description: Concatenates two arrays together; good for reducing over multiple arrays to concatenate them all</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>var arr1 = [1, 2, 3];
var arr2 = [4, 5, 6];
var newArr = j.concat(arr1, arr2); // [1, 2, 3, 4, 5, 6]

arr1 === newArr; // false
arr2 === newArr; // false
</code></pre>
</div>

<h3 id="conj">conj</h3>

<ul>
  <li>Performance: O(n) (based on slice performance)</li>
  <li>Signature: <code class="highlighter-rouge">*, array&lt;*&gt; =&gt; array&lt;*&gt;</code></li>
  <li>Description: Postpends value onto array of original values; this is a non-destructive action</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>var originalArray = [1, 2, 3];
var newArray = j.conj(4, originalArray); // [1, 2, 3, 4];

newArray === originalArray; // false
</code></pre>
</div>

<h3 id="cons">cons</h3>

<ul>
  <li>Performance: O(n) (based on slice performance)</li>
  <li>Signature: <code class="highlighter-rouge">*, array&lt;*&gt; =&gt; array&lt;*&gt;</code></li>
  <li>Description: Prepends value onto array of original values; this is a non-destructive action</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>var originalArray = [1, 2, 3];
var newArray = j.cons(4, originalArray); // [4, 1, 2, 3];

newArray === originalArray; // false
</code></pre>
</div>

<h3 id="curry">curry</h3>

<ul>
  <li>Performance: O(1)</li>
  <li>Signature: <code class="highlighter-rouge">function, [int], [array&lt;*&gt;] =&gt; [*] =&gt; *</code></li>
  <li>Description: Converts function into an optionally curried function</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>function add  (a, b) {
    return a + b;
}

j.curry(add)(1)(2); // 3
j.curry(add)(1, 2); // 3
j.curry(add, 3)(1)(2)(3); // 3
</code></pre>
</div>

<h3 id="foldlcompose">foldlCompose</h3>

<ul>
  <li>Performance: O(n)</li>
  <li>Signature: <code class="highlighter-rouge">function, function, ... =&gt; function</code></li>
  <li>Description: Composes multiple functions together left to right: foldlCompose(f, g, h)(x) = f(g(h(x)))</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>var compute = j.foldlCompose(
    j.addBy(1),
    j.multiplyBy(3),
    j.divideBy(2)
);

compute(12); // 19
</code></pre>
</div>

<h3 id="foldrcompose">foldrCompose</h3>

<ul>
  <li>Performance: O(n)</li>
  <li>Signature: <code class="highlighter-rouge">function, function, ... =&gt; function</code></li>
  <li>Description: Composes multiple functions together right to left: foldrCompose(f, g, h)(x) = h(g(f(x)))</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>var compute = j.foldrCompose(
    j.addBy(1),
    j.multiplyBy(3),
    j.divideBy(2)
);

compute(5); // 9
</code></pre>
</div>

<h3 id="rcurry">rcurry</h3>

<ul>
  <li>Performance: O(1)</li>
  <li>Signature: <code class="highlighter-rouge">function, [int], [array&lt;*&gt;] =&gt; [*] =&gt; *</code></li>
  <li>Description: Curries function as above, but each value in the original function is filled right to left instead of left to right; Multiple arguments are inserted in left to right order as received</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>function divide (a, b) {
return a / b;
}

j.rcurry(divide)(1)(2); // 2
j.rcurry(divide)(1, 2); // 0.5
j.rcurry(divide)(2)(1); // 0.5
</code></pre>
</div>

<h3 id="identity">identity</h3>

<ul>
  <li>Performance: O(1)</li>
  <li>
    <p>Signature: <code class="highlighter-rouge">* =&gt; *</code></p>
  </li>
  <li>Description: Accepts value <code class="highlighter-rouge">a</code> and returns value <code class="highlighter-rouge">a</code></li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>j.identity('foo'); // foo
j.identity(42); // 42
</code></pre>
</div>

<h3 id="partial">partial</h3>

<ul>
  <li>Performance: O(1)</li>
  <li>Signature: <code class="highlighter-rouge">function, [*] =&gt; [*] =&gt; *</code></li>
  <li>Description: Accepts a function and values to apply, returns a function which will apply remaining arguments and return a result</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>function add (a, b) {
return a + b;
}

var inc = j.partial(add, 1);

inc(1); // 2
inc(5); // 6

inc(inc(inc(inc(1)))); // 4
</code></pre>
</div>

<h3 id="pick">pick</h3>

<ul>
  <li>Performance: O(1)</li>
  <li>Signature: <code class="highlighter-rouge">string =&gt; object =&gt; maybe&lt;defined&gt;</code></li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>j.pick('foo')({ foo: 'bar' }); // bar
j.pick('foo')({ baz: 'bar' }); // j.nil
</code></pre>
</div>

<h3 id="rcompose">rcompose</h3>

<ul>
  <li>Performance: O(1);</li>
  <li>Signature: <code class="highlighter-rouge">function, function =&gt; function</code></li>
  <li>Description: Composes two functions right to left: compose(f, g)(x) = g(f(x))</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>j.compose(j.addBy(1), j.divideBy(3))(8); // 3
</code></pre>
</div>

<h3 id="recur">recur</h3>

<ul>
  <li>Performance: O(1)</li>
  <li>Signature: <code class="highlighter-rouge">function =&gt; function</code></li>
  <li>Description: Tail-optimized recursion function which allows for the writing of recursive, over looping, algorithms</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>var isUndefined = j.isTypeOf('undefined');
var isNil = j.isTypeOf('nil');

var sum = j.recur(function (recur, values, total) {
var result = isUndefined(total) ? 0 : total;
return isNil(values) ? total : recur(j.rest(values), total + j.first(values));
});
</code></pre>
</div>

<h3 id="repeat">repeat</h3>

<ul>
  <li>Performance: O(n)</li>
  <li>Signature: <code class="highlighter-rouge">function =&gt; number =&gt; * =&gt; *</code></li>
  <li>Description: Repeats provided function n times applying the result from the previous operation</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>var isEven = j.isTypeOf(function (value) {
    return j.isTypeOf('int')(value) &amp;&amp; value % 2 === 0;
});

function threeXPlusOneProblem (value) {
    return isEven(value) ? (value / 2) : (3 * value + 1);
}

j.repeat(threeXPlusOneProblem)(15)(7); // 1
j.repeat(j.concat('foo'))(3)(''); // "foofoofoo"
</code></pre>
</div>

<h3 id="reverseargs">reverseArgs</h3>

<ul>
  <li>Performance: O(n)</li>
  <li>Signature: <code class="highlighter-rouge">function =&gt; [*] =&gt; *</code></li>
  <li>Description: Accepts a function and returns a function which takes arguments in reverse order</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>function divide (a, b) {
return a / b;
}

j.reverseArgs(divide)(2, 12); // 6
</code></pre>
</div>

<h3 id="rpartial">rpartial</h3>

<ul>
  <li>Performance: O(1)</li>
  <li>Signature: <code class="highlighter-rouge">function, [*] =&gt; [*] =&gt; *</code></li>
  <li>Description: Similar to partial, but applies arguments in groups from right to left</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>function divide (a, b) {
    return a / b;
}

var divBy2 = j.rpartial(divide, 2);

divBy2(1); // 0.5
divBy2(4); // 2

divBy2(divBy2(divBy2(divBy2(12)))); // 0.75
</code></pre>
</div>

<h3 id="slice">slice</h3>

<ul>
  <li>Performance: O(n) (estimated JS performance characteristic)</li>
  <li>Signature: <code class="highlighter-rouge">int, [int] =&gt; taggedUnion&lt;array&lt;*&gt;;arguments&gt; =&gt; array&lt;*&gt;</code></li>
  <li>Description: Partial application implementation of slice with optional start and end values applied at beginning of function call</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>j.slice(1)([1, 2, 3, 4]); // [2, 3, 4]

function foo() {
var args = j.slice(0)(arguments);
// ...
}
</code></pre>
</div>

<h3 id="cond">cond</h3>

<ul>
  <li>Performance: O(n) (for n = number of conditions)</li>
  <li>Signature: <code class="highlighter-rouge">function&lt;function;function;boolean&gt; =&gt; *</code></li>
  <li>Description: Conditional expression which uses where, then and default to express conditional behaviors</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>j.cond(function(where, then, _default){
    when(j.isTypeOf(number)(a), then(j.multiplyBy(3), a));
    when(_default, then(j.always(a)));
});
</code></pre>
</div>

<h2 id="array">Array</h2>

<h3 id="all">all</h3>

<ul>
  <li>Performance: O(n)</li>
  <li>Signature: <code class="highlighter-rouge">function =&gt; array&lt;*&gt; =&gt; boolean</code></li>
  <li>Description: Verify all values in array satisfy predicate</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>j.all(j.isTypeOf('string'), ['foo', 'bar', 'baz']); // true
j.all(j.isTypeOf('string'), ['foo', 'bar', 42]); // false
</code></pre>
</div>

<h3 id="compact">compact</h3>

<ul>
  <li>Performance: O(n)</li>
  <li>Signature: <code class="highlighter-rouge">[array] =&gt; array&lt;*&gt;</code></li>
  <li>Description: Removes falsey values from array</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>j.compact([1, 2, 0, '', false, null, 3]); // [1, 2, 3]
</code></pre>
</div>

<h3 id="droplast">dropLast</h3>

<ul>
  <li>Performance: O(n) (based on the performance of slice)</li>
  <li>Signature: <code class="highlighter-rouge">array&lt;*&gt; =&gt; array&lt;*&gt;</code></li>
  <li>Description: Drops last value of array</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>j.dropLast([1, 2, 3, 4]); // [1, 2, 3];
</code></pre>
</div>

<h3 id="dropnth">dropNth</h3>

<ul>
  <li>Performance: O(n) (based on the performance of splice)</li>
  <li>Signature: <code class="highlighter-rouge">index =&gt; array&lt;*&gt; =&gt; array&lt;*&gt;</code></li>
  <li>Description: Drops value at nth index from array</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>j.dropNth(0)([1, 2, 3, 4]); // [2, 3, 4];
j.dropNth(2)([1, 2, 3, 4]); // [1, 2, 4];
</code></pre>
</div>

<h3 id="filter">filter</h3>

<ul>
  <li>Performance: O(n)</li>
  <li>Signature: <code class="highlighter-rouge">function =&gt; array&lt;*&gt; =&gt; array&lt;*&gt;</code></li>
  <li>Description: Filters values from array which fail to pass predicate check</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>var isEven = j.compose(j.equal(0), j.modBy(2));
j.filter(isEven)([1, 2, 3, 4]); // [2, 4]
</code></pre>
</div>

<h3 id="first">first</h3>

<ul>
  <li>Performance: O(1)</li>
  <li>Signature: <code class="highlighter-rouge">array&lt;*&gt; =&gt; maybe&lt;defined&gt;</code></li>
  <li>Description: Returns first value of an array if it exists, otherwise returns nil</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>j.first([1, 2, 3, 4]); // 1
</code></pre>
</div>

<h3 id="find">find</h3>

<ul>
  <li>Performance: O(n)</li>
  <li>Signature: <code class="highlighter-rouge">function&lt;*&gt; =&gt; array&lt;*&gt; =&gt; maybe&lt;defined&gt;</code></li>
  <li>Description: finds first value satisfying predicate or</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>var divisibleBy3 = j.compose(j.equal(0), j.modBy(3));
j.find(divisibleBy3, [1, 2, 4, 5, 6]); 6
j.find(divisibleBy3, [1, 2, 4, 5, 7]); j.nil
</code></pre>
</div>

<h3 id="foldl">foldl</h3>

<ul>
  <li>Performance: O(n)</li>
  <li>Signature: <code class="highlighter-rouge">function, [*] =&gt; array&lt;*&gt; =&gt; *</code></li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>j.foldl(j.add)([1, 2, 3, 4]); // 10
j.foldl(j.add, 5)([1, 2, 3, 4]); // 15
</code></pre>
</div>

<h3 id="foldr">foldr</h3>

<ul>
  <li>Performance: O(n)</li>
  <li>Signature: <code class="highlighter-rouge">function, [*] =&gt; array&lt;*&gt; =&gt; *</code></li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>j.foldr(j.mod)([2, 5, 8]); // 1
j.foldr(j.mod)([8, 5, 2]); // 2
</code></pre>
</div>

<h3 id="lastindexof">lastIndexOf</h3>

<ul>
  <li>Performance: O(1)</li>
  <li>Signature: <code class="highlighter-rouge">array&lt;*&gt; =&gt; index</code></li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>j.lastIndexOf([1, 2, 3, 4]); // 3
</code></pre>
</div>

<h3 id="map">map</h3>

<ul>
  <li>Performance: O(n)</li>
  <li>Signature: <code class="highlighter-rouge">function =&gt; array&lt;*&gt; =&gt; array&lt;*&gt;</code></li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>j.map(j.divideBy(3))([3, 6, 9, 12]); // [1, 2, 3, 4]
</code></pre>
</div>

<h3 id="none">none</h3>

<ul>
  <li>Performance: O(n)</li>
  <li>Signature: <code class="highlighter-rouge">function =&gt; array&lt;*&gt; =&gt; boolean</code></li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>j.none(j.isTypeOf('number'), ['foo', 'bar', 'baz']); // true
j.none(j.isTypeOf('number'), ['foo', 'bar', 51]); // false
</code></pre>
</div>

<h3 id="nth">nth</h3>

<ul>
  <li>Performance: O(1)</li>
  <li>Signature: <code class="highlighter-rouge">index =&gt; array&lt;*&gt; =&gt; maybe&lt;defined&gt;</code></li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>j.nth(2)([1, 2, 3, 4]); // 3;
</code></pre>
</div>

<h3 id="partition">partition</h3>

<ul>
  <li>Performance: O(n)</li>
  <li>Signature: <code class="highlighter-rouge">predicate =&gt; array =&gt; tuple&lt;array;array&gt;</code></li>
  <li>Description: Partitions an array on a predicate</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>var isEven = j.compose(j.equal(0), j.modBy(2));

j.partition(isEven)([1, 2, 3, 4]); // [[2, 4], [1, 3]]
</code></pre>
</div>

<h3 id="pushunsafe">pushUnsafe</h3>

<ul>
  <li>Performance: unknown</li>
  <li>Signature: <code class="highlighter-rouge">array =&gt; * =&gt; array</code></li>
  <li>Description: Pushes value into array</li>
</ul>

<p>** Warning: This function will mutate your array **</p>

<div class="highlighter-rouge"><pre class="highlight"><code>var myArray = [1, 2, 3, 4];
j.pushUnsafe(myArray)(5); // [1, 2, 3, 4, 5]
console.log(myArray); // [1, 2, 3, 4, 5]
</code></pre>
</div>

<h3 id="rest">rest</h3>

<ul>
  <li>Performance: O(n) (based on performance of slice)</li>
  <li>Signature: <code class="highlighter-rouge">taggedUnion&lt;array&lt;*&gt;;arguments&gt; =&gt; array&lt;*&gt;</code></li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>j.rest([1, 2, 3, 4]); // [2, 3, 4]
</code></pre>
</div>

<h3 id="reverse">reverse</h3>

<ul>
  <li>Performance: O(n)</li>
  <li>Signature: <code class="highlighter-rouge">array&lt;*&gt; =&gt; array&lt;*&gt;</code></li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>j.reverse([1, 2, 3, 4]); // [4, 3, 2, 1]
</code></pre>
</div>

<h3 id="rfilter">rfilter</h3>

<ul>
  <li>Performance: O(n)</li>
  <li>Signature: <code class="highlighter-rouge">function =&gt; array&lt;*&gt; =&gt; array&lt;*&gt;</code></li>
  <li>Description: Filters values from multi-dimensional array which fail to pass predicate check</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>var isEven = j.compose(j.equal(0), j.modBy(2));
j.filter(isEven)([1, [2, [3, 4]]]); // [2, 4]
</code></pre>
</div>

<h3 id="rmap">rmap</h3>

<ul>
  <li>Performance: O(n)</li>
  <li>Signature: <code class="highlighter-rouge">function =&gt; array&lt;*&gt; =&gt; array&lt;*&gt;</code></li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>j.rmap(j.divideBy(3))([3, 6, [9, 12]]); // [1, 2, 3, 4]
</code></pre>
</div>

<h3 id="rreduce">rreduce</h3>

<ul>
  <li>Performance: O(n)</li>
  <li>Signature: <code class="highlighter-rouge">function, [*] =&gt; array&lt;*&gt; =&gt; *</code></li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>j.rreduce(j.add)([1, [2, 3, [4]]]); // 10
j.rreduce(j.add, 5)([1, [2, 3, [4]]]); // 15
</code></pre>
</div>

<h3 id="some">some</h3>

<ul>
  <li>Performance: O(n)</li>
  <li>Signature: <code class="highlighter-rouge">function =&gt; array&lt;*&gt; =&gt; boolean</code></li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>j.none(j.isTypeOf('number'), ['foo', 'bar', 'baz']); // false
j.none(j.isTypeOf('number'), ['foo', 'bar', 51]); // true
</code></pre>
</div>

<h3 id="sort">sort</h3>

<ul>
  <li>Performance: O(n) + quicksort perf</li>
  <li>Signature: <code class="highlighter-rouge">[*] =&gt; array&lt;*&gt; =&gt; array&lt;*&gt;</code></li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>j.sort()([2, 4, 1, 3, 5]); // [1, 2, 3, 4, 5]
j.sort(j.reverseArgs(j.subtract))([2, 4, 1, 3, 5]); // [5, 4, 3, 2, 1]
</code></pre>
</div>

<h3 id="take">take</h3>

<ul>
  <li>Performance: O(n) (based on performance of slice)</li>
  <li>Signature: <code class="highlighter-rouge">[index] =&gt; function&lt;array&lt;*&gt;&gt;</code></li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>j.take(3)([1, 2, 3, 4, 5]); // [1, 2, 3];
</code></pre>
</div>

<h3 id="takeuntil">takeUntil</h3>

<ul>
  <li>Performance: O(n);</li>
  <li>Signature: <code class="highlighter-rouge">predicate =&gt; array =&gt; array</code></li>
  <li>Description: Takes values from source array and adds them to returned array until predicate is satisfied</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>var isEven = j.compose(j.equal(0), j.modBy(2));
j.takeUntil(isEven)([1, 3, 5, 6, 7, 9]); // [1, 3, 5]
</code></pre>
</div>

<h3 id="until">until</h3>

<ul>
  <li>Performance: O(n);</li>
  <li>Signature: <code class="highlighter-rouge">predicate =&gt; function, * =&gt; array =&gt; *</code></li>
  <li>Description: Performs action until predicate is satisified</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>var isEven = j.compose(j.equal(0), j.modBy(2));

function takeAndDouble(result, value){
    return j.conj(result, value * 2);
}

j.until(isEven)(takeAndDouble, [])([1, 3, 5, 6, 7, 9]); // [2, 6, 10]
</code></pre>
</div>

<h2 id="math">Math</h2>

<h3 id="add">add</h3>

<ul>
  <li>Performance: O(1)</li>
  <li>Signature: <code class="highlighter-rouge">number, number =&gt; number</code></li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>j.add(1, 2); // 3
j.add(3)(4); // 7
</code></pre>
</div>

<h3 id="divide">divide</h3>

<ul>
  <li>Performance: O(1)</li>
  <li>Signature: <code class="highlighter-rouge">number, number =&gt; number</code></li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>j.divide(6, 3); // 2
j.divide(8)(2); // 4
</code></pre>
</div>

<h3 id="mod">mod</h3>

<ul>
  <li>Performance: O(1)</li>
  <li>Signature: <code class="highlighter-rouge">number, number =&gt; number</code></li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>j.mod(4, 3); // 1
j.mod(7)(5); // 2
</code></pre>
</div>

<h3 id="multiply">multiply</h3>

<ul>
  <li>Performance: O(1)</li>
  <li>Signature: <code class="highlighter-rouge">number, number =&gt; number</code></li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>j.multiply(2, 4); // 8
j.multiply(3)(5); // 15
</code></pre>
</div>

<h3 id="subtract">subtract</h3>

<ul>
  <li>Performance: O(1)</li>
  <li>Signature: <code class="highlighter-rouge">number, number =&gt; number</code></li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>j.subtract(5, 4); // 1
j.subtract(3)(5); // -2
</code></pre>
</div>

<h3 id="addby">addBy</h3>

<ul>
  <li>Performance: O(1)</li>
  <li>Signature: <code class="highlighter-rouge">number =&gt; number =&gt; number</code></li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>j.addBy(5)(6); // 11
</code></pre>
</div>

<h3 id="divideby">divideBy</h3>

<ul>
  <li>Performance: O(1)</li>
  <li>Signature: <code class="highlighter-rouge">number =&gt; number =&gt; number</code></li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>j.divideBy(3)(12); // 4
</code></pre>
</div>

<h3 id="modby">modBy</h3>

<ul>
  <li>Performance: O(1)</li>
  <li>Signature: <code class="highlighter-rouge">number =&gt; number =&gt; number</code></li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>j.modBy(5)(7); // 2
</code></pre>
</div>

<h3 id="multiplyby">multiplyBy</h3>

<ul>
  <li>Performance: O(1)</li>
  <li>Signature: <code class="highlighter-rouge">number =&gt; number =&gt; number</code></li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>j.multiplyBy(7)(8); // 56
</code></pre>
</div>

<h3 id="subtractby">subtractBy</h3>

<ul>
  <li>Performance: O(1)</li>
  <li>Signature: <code class="highlighter-rouge">number =&gt; number =&gt; number</code></li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>j.subtractBy(3)(7); // 4
</code></pre>
</div>

<h3 id="min">min</h3>

<ul>
  <li>Performance: O(1)</li>
  <li>Signature: <code class="highlighter-rouge">number =&gt; number =&gt; number</code></li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>j.min(5, 6); // 5
j.min(9)(4); // 4
</code></pre>
</div>

<h3 id="max">max</h3>

<ul>
  <li>Performance: O(1)</li>
  <li>Signature: <code class="highlighter-rouge">number =&gt; number =&gt; number</code></li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>j.max(7, 2); // 7
j.max(8)(5); // 8
</code></pre>
</div>

<h3 id="inc">inc</h3>

<ul>
  <li>Performance: O(1)</li>
  <li>Signature: <code class="highlighter-rouge">int =&gt; int</code></li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>j.inc(4); // 5
</code></pre>
</div>

<h3 id="dec">dec</h3>

<ul>
  <li>Performance: O(1)</li>
  <li>Signature: <code class="highlighter-rouge">int =&gt; int</code></li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>j.dec(9); // 8
</code></pre>
</div>

<h3 id="range">range</h3>

<ul>
  <li>Performance: O(1)</li>
  <li>Signature: <code class="highlighter-rouge">int, [int] =&gt; int =&gt; array&lt;int&gt;</code></li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>j.range(1)(10); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
j.range(1, 3)(10); // [1, 4, 7, 10] 
</code></pre>
</div>

<h3 id="gt">gt</h3>

<ul>
  <li>Performance: O(1)</li>
  <li>Signature: <code class="highlighter-rouge">number =&gt; number =&gt; boolean</code></li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>j.gt(5)(2); // true
j.gt(5)(7); // false
</code></pre>
</div>

<h3 id="geq">geq</h3>

<ul>
  <li>Performance: O(1)</li>
  <li>Signature: <code class="highlighter-rouge">number =&gt; number =&gt; boolean</code></li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>j.geq(5)(2); // true
j.geq(5)(5); // true
j.geq(5)(7); // false
</code></pre>
</div>

<h3 id="lt">lt</h3>

<ul>
  <li>Performance: O(1)</li>
  <li>Signature: <code class="highlighter-rouge">number =&gt; number =&gt; boolean</code></li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>j.gt(5)(2); // false
j.gt(5)(7); // true
</code></pre>
</div>

<h3 id="leq">leq</h3>

<ul>
  <li>Performance: O(1)</li>
  <li>Signature: <code class="highlighter-rouge">number =&gt; number =&gt; boolean</code></li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>j.geq(5)(2); // false
j.geq(5)(5); // true
j.geq(5)(7); // true
</code></pre>
</div>

<h3 id="between">between</h3>

<ul>
  <li>Performance: O(1)</li>
  <li>Signature: <code class="highlighter-rouge">number, number =&gt; number =&gt; boolean</code></li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>j.between(1, 5)(4); // true
j.between(1, 5)(5); // true
j.between(1, 5)(10); // false
</code></pre>
</div>

<h2 id="object">Object</h2>

<h3 id="clone">clone</h3>

<ul>
  <li>Performance: O(n) for n = leaves on object tree</li>
  <li>Signature: <code class="highlighter-rouge">object =&gt; object</code></li>
  <li>Description: Deep clones an object, fails on particularly deep or circular objects</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>j.clone({foo: 'bar', baz: 'quux'}); {foo: 'bar', baz: 'quux'}
</code></pre>
</div>

<h3 id="deref">deref</h3>

<ul>
  <li>Performance: O(n) (depends on key token length)</li>
  <li>Signature: <code class="highlighter-rouge">string =&gt; object =&gt; maybe&lt;defined&gt;</code></li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>var testObj = {
foo: {
bar: {
baz: [1, 2, 3]
}
}
};

j.deref('foo.bar.baz')(testObj); // [1, 2, 3]
j.deref('foo.bar.baz.1')(testObj); // 2
j.deref('foo.bar.baz.4')(testObj); // j.nil
</code></pre>
</div>

<h3 id="merge">merge</h3>

<ul>
  <li>Performance: O(n)</li>
  <li>Signature: <code class="highlighter-rouge">object, object =&gt; object</code></li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>var testObj1 = {
foo: 'bar',
baz: 'quux'
};

var testObj2 = {
baz: 'foo',
quux: 'bar'
};

j.merge(testObj1, testObj2);

// {
// foo: 'bar',
// baz: 'foo',
// quux: 'bar'
// }
</code></pre>
</div>

<h3 id="mergetounsafe">mergeToUnsafe</h3>

<ul>
  <li>Performance: O(n) for n = key count in source object</li>
  <li>Signature: <code class="highlighter-rouge">object =&gt; object =&gt; object</code></li>
  <li>Description: Merges properties from right object onto left, modifies original object</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>var myObj = {};

j.mergeToUnsafe(myObj)({foo: 'bar'}); // {foo: 'bar'};
console.log(myObj); // {foo: 'bar'}
</code></pre>
</div>

<h3 id="shallowclone">shallowClone</h3>

<ul>
  <li>Performance: O(n) for n = key count in source object</li>
  <li>Signature: <code class="highlighter-rouge">object =&gt; object</code></li>
  <li>Description: Creates a shallow clone of original object, deep pointers are preserved</li>
</ul>

<h3 id="toarray">toArray</h3>

<ul>
  <li>Performance: O(n) (for n = number of keys)</li>
  <li>Signature: <code class="highlighter-rouge">object =&gt; array&lt;tuple&lt;objectKey;*&gt;&gt;</code></li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>var testObj = {
foo: 'bar',
baz: 'quux'
};

j.toArray(testObj); // [['foo', 'bar'], ['baz', 'quux']]
</code></pre>
</div>

<h3 id="toobject">toObject</h3>

<ul>
  <li>Performance: O(n) (for n = length of array)</li>
  <li>Signature: <code class="highlighter-rouge">array&lt;tuple&lt;objectKey;*&gt;&gt; =&gt; object</code></li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>var testArray = [['foo', 'bar'], ['baz', 'quux']];

j.toObject(testArray); // { foo: 'bar', baz: 'quux' }
</code></pre>
</div>

<h3 id="tovalues">toValues</h3>

<ul>
  <li>Performance: O(n) (for n = number of keys)</li>
  <li>Signature: <code class="highlighter-rouge">object =&gt; array</code></li>
  <li>Description: Returns top-level values in object as array</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>var testObj = {
foo: 'bar',
baz: 'quux'
};

j.toValues(testObj); // ['bar', 'quux']
</code></pre>
</div>


</div>

    </div>

    <script src="/JFP/page-includes/prism.js"></script>

  </body>

</html>
